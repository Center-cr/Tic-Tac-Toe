# 井字棋联机
关联项目
[[五子棋.md]]五子棋
[[socket]] socket

## 源码

```python
import pygame
import ctypes

# 初始化 pygame
pygame.init()

# 定义颜色
blue = (78, 140, 243)
light_blue = (100, 100, 255)
red = (242, 89, 97)
light_red = (255, 100, 100)
dark_grey = (85, 85, 85)
light_grey = (100, 100, 100)
background_color = (225, 225, 225)

# 创建窗口
screen = pygame.display.set_mode((600, 650))
pygame.display.set_caption('井字棋')

# 游戏图片
crossImg = pygame.image.load('Images/crossImg.png')
crossImg_rect = crossImg.get_rect()
crossImg_rect.center = (200, 300)
circleImg = pygame.image.load('Images/circleImg.png')
circleImg_rect = crossImg.get_rect()
circleImg_rect.center = (400, 300)
previewCrossImg = pygame.image.load('Images/prev_crossImg.png')
previewCircleImg = pygame.image.load('Images/prev_circleImg.png')

# 按钮图片
restartImg = pygame.image.load('Images/restart.png')
restartHoveredImg = pygame.image.load('Images/restart_hovered.png')

# 定义棋盘
board = [['', '', ''],
         ['', '', ''],
         ['', '', '']]

# 定义计分板
score = {'X': 0, 'O': 0}
font = pygame.font.Font('freesansbold.ttf', 32)
X_score = pygame.image.load('Images/X_scoreImg.png')
O_score = pygame.image.load('Images/O_scoreImg.png')

# 菜单图片
buttom1 = pygame.image.load('Images/button1Img.png')
buttom1_rect = buttom1.get_rect()
buttom1_rect.center = (300, 312)
buttom2 = pygame.image.load('Images/button2Img.png')
buttom2_rect = buttom2.get_rect()
buttom2_rect.center = (300, 472)
logo = pygame.image.load('Images/logo.png')

# 选择菜单图片
chooseImg = pygame.image.load('Images/choose.png')


def menu():
    running = True
    while running:
        screen.fill(background_color)
        mx, my = pygame.mouse.get_pos()
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if buttom1_rect.collidepoint((mx, my)):
                    game(0, 'X')
                elif buttom2_rect.collidepoint((mx, my)):
                    player = choose()
                    if player is not None:
                        game(1, player)
        screen.blit(logo, (8, 25))
        screen.blit(buttom1, (100, 250))
        screen.blit(buttom2, (100, 410))
        pygame.display.update()


def game(gameMode, player):
    my = player
    player = 'X'
    running = True
    previewImg = previewCrossImg
    while running:
        mouse = pygame.mouse.get_pos()
        row, col = int(mouse[0] / 200), int(mouse[1] / 200)
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                resetGame()
                running = False
            elif isBoardFull():
                ctypes.windll.user32.MessageBoxW(0, '平局', '提示', 0)
                resetBoard()
            elif gameMode == 1 and player != my:
                computerMove(player)
                drawBoard()
                pygame.display.update()
                if verifyWinner(player):
                    player = 'X'
                    previewImg = previewCrossImg
                else:
                    player, previewImg = updatePlayer(player)
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if row < 3 and col < 3 and board[row][col] == '':
                    playerMove(player, row, col)
                    drawBoard()
                    pygame.display.update()
                    if verifyWinner(player):
                        player = 'X'
                        previewImg = previewCrossImg
                    else:
                        player, previewImg = updatePlayer(player)
                elif 550 < mouse[0] < 582 and 610 < mouse[1] < 642:
                    resetGame()
        screen.fill(background_color)
        drawBoard()
        drawBottomMenu(mouse)
        if row < 3 and col < 3:
            visualizeMove(row, col, previewImg)
        pygame.display.update()


def choose():
    player = None
    running = True
    while running:
        mouse = pygame.mouse.get_pos()
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if crossImg_rect.collidepoint((mouse[0], mouse[1])):
                    player = 'X'
                    running = False
                elif circleImg_rect.collidepoint((mouse[0], mouse[1])):
                    player = 'O'
                    running = False
        screen.blit(crossImg, (80, 300))
        screen.blit(circleImg, (340, 300))
        screen.blit(chooseImg, (8, 25))
        pygame.display.update()
    return player


def drawBoard():
    # 画棋子
    for row in range(3):
        for col in range(3):
            pos = (row * 200 + 12, col * 200 + 12)
            if board[row][col] == 'X':
                screen.blit(crossImg, pos)
            elif board[row][col] == 'O':
                screen.blit(circleImg, pos)
    # 画网格
    width = 10
    color = dark_grey
    pygame.draw.line(screen, color, (200, 0), (200, 600), width)
    pygame.draw.line(screen, color, (400, 0), (400, 600), width)
    pygame.draw.line(screen, color, (0, 200), (600, 200), width)
    pygame.draw.line(screen, color, (0, 400), (600, 400), width)
    # 画边框
    pygame.draw.rect(screen, color, (0, 0, 10, 600))
    pygame.draw.rect(screen, color, (0, 0, 600, 10))
    pygame.draw.rect(screen, color, (590, 0, 10, 600))


def drawBottomMenu(mouse):
    pygame.draw.rect(screen, dark_grey, (0, 600, 600, 100))
    pygame.draw.rect(screen, light_grey, (10, 610, 580, 80))
    screen.blit(restartImg, (550, 610))
    # Hover animation
    if 550 < mouse[0] < 582 and 610 < mouse[1] < 642:
        screen.blit(restartHoveredImg, (548, 608))
    screen.blit(X_score, (200, 610))
    screen.blit(O_score, (370, 610))
    scoreboard = font.render(': %d x %d :' % (score['X'], score['O']), True, background_color, light_grey)
    screen.blit(scoreboard, (244, 610))


def visualizeMove(row, col, previewImg):
    if board[row][col] == '':
        screen.blit(previewImg, (row * 200 + 12, col * 200 + 12))


def playerMove(player, row, col):
    board[row][col] = player


def computerMove(player):
    bestScore = float('inf')
    for row in range(3):
        for col in range(3):
            if board[row][col] == '':
                board[row][col] = 'O'
                score = minimax(board, 'X')
                board[row][col] = ''
                if score < bestScore:
                    bestScore = score
                    bestMove = (row, col)
    board[bestMove[0]][bestMove[1]] = player


scores = {'X': 1, 'O': -1, 'tie': 0}


def minimax(board, cur_player):
    if isWinner('X'):
        return scores['X']
    elif isWinner('O'):
        return scores['O']
    elif isBoardFull():
        return scores['tie']
    if cur_player == 'X':
        bestScore = float('-inf')
        nextPlayer = 'O'
        minORmax = max
    else:
        bestScore = float('inf')
        nextPlayer = 'X'
        minORmax = min
    for row in range(3):
        for col in range(3):
            if board[row][col] == '':
                board[row][col] = cur_player
                score = minimax(board, nextPlayer)
                board[row][col] = ''
                bestScore = minORmax(score, bestScore)
            if bestScore == scores[cur_player]:
                return bestScore
    return bestScore


def updatePlayer(player):
    if player == 'X':
        newPlayer = 'O'
        previewImg = previewCircleImg
    else:
        newPlayer = 'X'
        previewImg = previewCrossImg
    return newPlayer, previewImg



def isWinner(player):
    return ((board[0][0] == player and board[0][1] == player and board[0][2] == player) or
            (board[1][0] == player and board[1][1] == player and board[1][2] == player) or
            (board[2][0] == player and board[2][1] == player and board[2][2] == player) or
            (board[0][0] == player and board[1][0] == player and board[2][0] == player) or
            (board[0][1] == player and board[1][1] == player and board[2][1] == player) or
            (board[0][2] == player and board[1][2] == player and board[2][2] == player) or
            (board[0][0] == player and board[1][1] == player and board[2][2] == player) or
            (board[0][2] == player and board[1][1] == player and board[2][0] == player))


def verifyWinner(player):
    if isWinner(player):
        score[player] += 1
        ctypes.windll.user32.MessageBoxW(0, player + ' 获胜！', '提示', 0)
        resetBoard()
        return True
    return False


def isBoardFull():
    for i in range(3):
        for j in range(3):
            if board[i][j] == '':
                return False
    return True


def resetBoard():
    for i in range(3):
        for j in range(3):
            board[i][j] = ''


def resetGame():
    resetBoard()
    score['X'] = 0
    score['O'] = 0


menu()
```

源码能实现人机对战

## 需要增加的功能

网络接口，TCP通信

## 历史版本

### 初步实现通信

服务端

```python
import pygame
import ctypes
# 导入socket 库
from socket import *
import threading
import time

# 主机地址为空字符串，表示绑定本机所有网络接口ip地址
# 等待客户端来连接
IP = ''
# 端口号
PORT = 50000
# 定义一次从socket缓冲区最多读入512个字节数据
BUFLEN = 512

# 实例化一个socket对象
# 参数 AF_INET 表示该socket网络层使用IP协议
# 参数 SOCK_STREAM 表示该socket传输层使用TCP协议
listenSocket = socket(AF_INET, SOCK_STREAM)

# socket绑定地址和端口
listenSocket.bind((IP, PORT))


# 使socket处于监听状态，等待客户端的连接请求
# 参数 8 表示 最多接受多少个等待连接的客户端
listenSocket.listen(8)
print(f'服务端启动成功，在{PORT}端口等待客户端连接...')

dataSocket, addr = listenSocket.accept()
print('接受一个客户端连接:', addr)


global Send_Flag
# 初始化 pygame
pygame.init()

# 定义颜色
blue = (78, 140, 243)
light_blue = (100, 100, 255)
red = (242, 89, 97)
light_red = (255, 100, 100)
dark_grey = (85, 85, 85)
light_grey = (100, 100, 100)
background_color = (225, 225, 225)
Send_Flag = 0
# 创建窗口
screen = pygame.display.set_mode((600, 800))
pygame.display.set_caption('井字棋')

# 游戏图片
crossImg = pygame.image.load('Images/crossImg.png')
crossImg_rect = crossImg.get_rect()
crossImg_rect.center = (200, 300)
circleImg = pygame.image.load('Images/circleImg.png')
circleImg_rect = crossImg.get_rect()
circleImg_rect.center = (400, 300)
previewCrossImg = pygame.image.load('Images/prev_crossImg.png')
previewCircleImg = pygame.image.load('Images/prev_circleImg.png')

# 按钮图片
restartImg = pygame.image.load('Images/restart.png')
restartHoveredImg = pygame.image.load('Images/restart_hovered.png')

# 定义棋盘
board = [['', '', ''],
         ['', '', ''],
         ['', '', '']]

# 定义计分板
score = {'X': 0, 'O': 0}
font = pygame.font.Font('freesansbold.ttf', 32)
X_score = pygame.image.load('Images/X_scoreImg.png')
O_score = pygame.image.load('Images/O_scoreImg.png')

# 菜单图片
buttom1 = pygame.image.load('Images/button1Img.png')
buttom1_rect = buttom1.get_rect()
buttom1_rect.center = (300, 312)
buttom2 = pygame.image.load('Images/button2Img.png')
buttom2_rect = buttom2.get_rect()
buttom2_rect.center = (300, 472)

buttom3 = pygame.image.load('Images/button3Img.png')
buttom3_rect = buttom3.get_rect()
buttom3_rect.center = (300, 632)

logo = pygame.image.load('Images/logo.png')

# 选择菜单图片
chooseImg = pygame.image.load('Images/choose.png')


def menu():
    running = True
    while running:
        screen.fill(background_color)
        mx, my = pygame.mouse.get_pos()
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if buttom1_rect.collidepoint((mx, my)):
                    game(0, 'X')
                elif buttom2_rect.collidepoint((mx, my)):
                    player = choose()
                    if player is not None:
                        game(1, player)
                elif buttom3_rect.collidepoint((mx, my)):
                    game(2, 'X')
        screen.blit(logo, (8, 25))
        screen.blit(buttom1, (100, 250))
        screen.blit(buttom2, (100, 410))
        screen.blit(buttom3, (100, 570))
        pygame.display.update()


def game(gameMode, player):
    global send_row, send_col ,Send_Flag,row, col
    my = player
    player = 'X'
    running = True
    previewImg = previewCrossImg
    while running:
        mouse = pygame.mouse.get_pos()
        row, col = int(mouse[0] / 200), int(mouse[1] / 200)
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                resetGame()
                running = False
            elif isBoardFull():
                ctypes.windll.user32.MessageBoxW(0, '平局', '提示', 0)
                resetBoard()
            elif gameMode == 1 and player != my:
                computerMove(player)
                drawBoard()
                pygame.display.update()
                if verifyWinner(player):
                    player = 'X'
                    previewImg = previewCrossImg
                else:
                    player, previewImg = updatePlayer(player)
            elif gameMode == 2 and player != my:

                # CounterMove(counter_row, counter_col)
                drawBoard()
                pygame.display.update()
                if verifyWinner(player):
                    player = 'X'
                    previewImg = previewCrossImg
                else:
                    player, previewImg = updatePlayer(player)
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if row < 3 and col < 3 and board[row][col] == '':
                    send_row = row
                    send_col = col
                    playerMove(player, row, col)
                    drawBoard()
                    Send_Flag = 1
                    pygame.display.update()
                    if verifyWinner(player):
                        player = 'X'
                        previewImg = previewCrossImg
                    else:
                        player, previewImg = updatePlayer(player)
                elif 550 < mouse[0] < 582 and 610 < mouse[1] < 642:
                    resetGame()
        screen.fill(background_color)
        drawBoard()
        drawBottomMenu(mouse)
        if row < 3 and col < 3:
            visualizeMove(row, col, previewImg)
        pygame.display.update()


def choose():
    player = None
    running = True
    while running:
        mouse = pygame.mouse.get_pos()
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if crossImg_rect.collidepoint((mouse[0], mouse[1])):
                    player = 'X'
                    running = False
                elif circleImg_rect.collidepoint((mouse[0], mouse[1])):
                    player = 'O'
                    running = False
        screen.blit(crossImg, (80, 300))
        screen.blit(circleImg, (340, 300))
        screen.blit(chooseImg, (8, 25))
        pygame.display.update()
    return player


def drawBoard():
    # 画棋子
    for row in range(3):
        for col in range(3):
            pos = (row * 200 + 12, col * 200 + 12)
            if board[row][col] == 'X':
                screen.blit(crossImg, pos)
            elif board[row][col] == 'O':
                screen.blit(circleImg, pos)
    # 画网格
    width = 10
    color = dark_grey
    pygame.draw.line(screen, color, (200, 0), (200, 600), width)
    pygame.draw.line(screen, color, (400, 0), (400, 600), width)
    pygame.draw.line(screen, color, (0, 200), (600, 200), width)
    pygame.draw.line(screen, color, (0, 400), (600, 400), width)
    # 画边框
    pygame.draw.rect(screen, color, (0, 0, 10, 600))
    pygame.draw.rect(screen, color, (0, 0, 600, 10))
    pygame.draw.rect(screen, color, (590, 0, 10, 600))


def drawBottomMenu(mouse):
    pygame.draw.rect(screen, dark_grey, (0, 600, 600, 100))
    pygame.draw.rect(screen, light_grey, (10, 610, 580, 80))
    screen.blit(restartImg, (550, 610))
    # Hover animation
    if 550 < mouse[0] < 582 and 610 < mouse[1] < 642:
        screen.blit(restartHoveredImg, (548, 608))
    screen.blit(X_score, (200, 610))
    screen.blit(O_score, (370, 610))
    scoreboard = font.render(': %d x %d :' % (score['X'], score['O']), True, background_color, light_grey)
    screen.blit(scoreboard, (244, 610))


def visualizeMove(row, col, previewImg):
    if board[row][col] == '':
        screen.blit(previewImg, (row * 200 + 12, col * 200 + 12))


def playerMove(player, row, col):
    board[row][col] = player

def CounterMove(row, col):
    board[row][col] = "O"


def computerMove(player):
    bestScore = float('inf')
    for row in range(3):
        for col in range(3):
            if board[row][col] == '':
                board[row][col] = 'O'
                score = minimax(board, 'X')
                board[row][col] = ''
                if score < bestScore:
                    bestScore = score
                    bestMove = (row, col)
    board[bestMove[0]][bestMove[1]] = player


scores = {'X': 1, 'O': -1, 'tie': 0}


def minimax(board, cur_player):
    if isWinner('X'):
        return scores['X']
    elif isWinner('O'):
        return scores['O']
    elif isBoardFull():
        return scores['tie']
    if cur_player == 'X':
        bestScore = float('-inf')
        nextPlayer = 'O'
        minORmax = max
    else:
        bestScore = float('inf')
        nextPlayer = 'X'
        minORmax = min
    for row in range(3):
        for col in range(3):
            if board[row][col] == '':
                board[row][col] = cur_player
                score = minimax(board, nextPlayer)
                board[row][col] = ''
                bestScore = minORmax(score, bestScore)
            if bestScore == scores[cur_player]:
                return bestScore
    return bestScore


def updatePlayer(player):
    if player == 'X':
        newPlayer = 'O'
        previewImg = previewCircleImg
    else:
        newPlayer = 'X'
        previewImg = previewCrossImg
    return newPlayer, previewImg



def isWinner(player):
    return ((board[0][0] == player and board[0][1] == player and board[0][2] == player) or
            (board[1][0] == player and board[1][1] == player and board[1][2] == player) or
            (board[2][0] == player and board[2][1] == player and board[2][2] == player) or
            (board[0][0] == player and board[1][0] == player and board[2][0] == player) or
            (board[0][1] == player and board[1][1] == player and board[2][1] == player) or
            (board[0][2] == player and board[1][2] == player and board[2][2] == player) or
            (board[0][0] == player and board[1][1] == player and board[2][2] == player) or
            (board[0][2] == player and board[1][1] == player and board[2][0] == player))


def verifyWinner(player):
    if isWinner(player):
        score[player] += 1
        ctypes.windll.user32.MessageBoxW(0, player + ' 获胜！', '提示', 0)
        resetBoard()
        return True
    return False


def isBoardFull():
    for i in range(3):
        for j in range(3):
            if board[i][j] == '':
                return False
    return True


def resetBoard():
    for i in range(3):
        for j in range(3):
            board[i][j] = ''


def resetGame():
    resetBoard()
    score['X'] = 0
    score['O'] = 0

def TCP_Server():
    global send_row, send_col ,Send_Flag,row, col
    while True:
        # 尝试读取对方发送的消息
        # BUFLEN 指定从接收缓冲里最多读取多少字节
        # recved = dataSocket.recv(BUFLEN)
        #
        # # 如果返回空bytes，表示对方关闭了连接
        # # 退出循环，结束消息收发
        # if not recved:
        #     break

        # 读取的字节数据是bytes类型，需要解码为字符串
        # info = recved.decode()
        # print(f'收到对方信息： {info}')
        #
        # # 发送的数据类型必须是bytes，所以要编码
        # dataSocket.send(f'服务端接收到了信息 '.encode())

        # 从终端读入用户输入的字符串
        # toSend = input('>>> ')
        # if toSend == 'exit':
        #     break
        # # 发送消息，也要编码为 bytes
        if Send_Flag == 1:
            toSend = "r"+str(send_row)+"c"+str(send_col)
            dataSocket.send(toSend.encode())
            Send_Flag == 0
            time.sleep(0.5)

    #
    # # 服务端也调用close()关闭socket
    # dataSocket.close()
    # listenSocket.close()

server_thread = threading.Thread(target = TCP_Server )
server_thread.start()
menu()
dataSocket.close()
listenSocket.close()
```

客户端

```python
import pygame
import ctypes
#  === TCP 客户端程序 client.py ===

from socket import *
import threading
IP = '127.0.0.1'
SERVER_PORT = 50000
BUFLEN = 1024

# 实例化一个socket对象，指明协议
dataSocket = socket(AF_INET, SOCK_STREAM)

# 连接服务端socket
dataSocket.connect((IP, SERVER_PORT))
# 初始化 pygame
pygame.init()

# 定义颜色
blue = (78, 140, 243)
light_blue = (100, 100, 255)
red = (242, 89, 97)
light_red = (255, 100, 100)
dark_grey = (85, 85, 85)
light_grey = (100, 100, 100)
background_color = (225, 225, 225)

# 创建窗口
screen = pygame.display.set_mode((600, 650))
pygame.display.set_caption('井字棋-客户端')

# 游戏图片
crossImg = pygame.image.load('Images/crossImg.png')
crossImg_rect = crossImg.get_rect()
crossImg_rect.center = (200, 300)
circleImg = pygame.image.load('Images/circleImg.png')
circleImg_rect = crossImg.get_rect()
circleImg_rect.center = (400, 300)
previewCrossImg = pygame.image.load('Images/prev_crossImg.png')
previewCircleImg = pygame.image.load('Images/prev_circleImg.png')

# 按钮图片
restartImg = pygame.image.load('Images/restart.png')
restartHoveredImg = pygame.image.load('Images/restart_hovered.png')

# 定义棋盘
board = [['', '', ''],
         ['', '', ''],
         ['', '', '']]

# 定义计分板
score = {'X': 0, 'O': 0}
font = pygame.font.Font('freesansbold.ttf', 32)
X_score = pygame.image.load('Images/X_scoreImg.png')
O_score = pygame.image.load('Images/O_scoreImg.png')

# 菜单图片
buttom1 = pygame.image.load('Images/button1Img.png')
buttom1_rect = buttom1.get_rect()
buttom1_rect.center = (300, 312)
buttom2 = pygame.image.load('Images/button2Img.png')
buttom2_rect = buttom2.get_rect()
buttom2_rect.center = (300, 472)
buttom3 = pygame.image.load('Images/button3Img.png')
buttom3_rect = buttom3.get_rect()
buttom3_rect.center = (300, 632)
logo = pygame.image.load('Images/logo.png')

# 选择菜单图片
chooseImg = pygame.image.load('Images/choose.png')


def menu():
    running = True
    while running:
        screen.fill(background_color)
        mx, my = pygame.mouse.get_pos()
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if buttom1_rect.collidepoint((mx, my)):
                    game(0, 'X')
                elif buttom2_rect.collidepoint((mx, my)):
                    player = choose()
                    if player is not None:
                        game(1, player)
                elif buttom3_rect.collidepoint((mx, my)):
                    game(2, 'O')
        screen.blit(logo, (8, 25))
        screen.blit(buttom1, (100, 250))
        screen.blit(buttom2, (100, 410))
        screen.blit(buttom3, (100, 570))
        pygame.display.update()


def game(gameMode, player):
    my = player
    player = 'O'
    running = True
    previewImg = previewCrossImg
    while running:
        mouse = pygame.mouse.get_pos()
        row, col = int(mouse[0] / 200), int(mouse[1] / 200)
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                resetGame()
                running = False
            elif isBoardFull():
                ctypes.windll.user32.MessageBoxW(0, '平局', '提示', 0)
                resetBoard()
            elif gameMode == 1 and player != my:
                computerMove(player)
                drawBoard()
                pygame.display.update()
                if verifyWinner(player):
                    player = 'O'
                    previewImg = previewCrossImg
                else:
                    player, previewImg = updatePlayer(player)
            # elif gameMode == 2 and player != my:
            #     CounterMove(player)
            #     drawBoard()
            #     pygame.display.update()
            #     if verifyWinner(player):
            #         player = 'O'
            #         previewImg = previewCrossImg
            #     else:
            #         player, previewImg = updatePlayer(player)
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if row < 3 and col < 3 and board[row][col] == '':
                    playerMove(player, row, col)
                    drawBoard()
                    pygame.display.update()
                    if verifyWinner(player):
                        player = 'O'
                        previewImg = previewCrossImg
                    else:
                        player, previewImg = updatePlayer(player)
                elif 550 < mouse[0] < 582 and 610 < mouse[1] < 642:
                    resetGame()
        screen.fill(background_color)
        drawBoard()
        drawBottomMenu(mouse)
        if row < 3 and col < 3:
            visualizeMove(row, col, previewImg)
        pygame.display.update()


def choose():
    player = None
    running = True
    while running:
        mouse = pygame.mouse.get_pos()
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if crossImg_rect.collidepoint((mouse[0], mouse[1])):
                    player = 'X'
                    running = False
                elif circleImg_rect.collidepoint((mouse[0], mouse[1])):
                    player = 'O'
                    running = False
        screen.blit(crossImg, (80, 300))
        screen.blit(circleImg, (340, 300))
        screen.blit(chooseImg, (8, 25))
        pygame.display.update()
    return player


def drawBoard():
    # 画棋子
    for row in range(3):
        for col in range(3):
            pos = (row * 200 + 12, col * 200 + 12)
            if board[row][col] == 'X':
                screen.blit(crossImg, pos)
            elif board[row][col] == 'O':
                screen.blit(circleImg, pos)
    # 画网格
    width = 10
    color = dark_grey
    pygame.draw.line(screen, color, (200, 0), (200, 600), width)
    pygame.draw.line(screen, color, (400, 0), (400, 600), width)
    pygame.draw.line(screen, color, (0, 200), (600, 200), width)
    pygame.draw.line(screen, color, (0, 400), (600, 400), width)
    # 画边框
    pygame.draw.rect(screen, color, (0, 0, 10, 600))
    pygame.draw.rect(screen, color, (0, 0, 600, 10))
    pygame.draw.rect(screen, color, (590, 0, 10, 600))


def drawBottomMenu(mouse):
    pygame.draw.rect(screen, dark_grey, (0, 600, 600, 100))
    pygame.draw.rect(screen, light_grey, (10, 610, 580, 80))
    screen.blit(restartImg, (550, 610))
    # Hover animation
    if 550 < mouse[0] < 582 and 610 < mouse[1] < 642:
        screen.blit(restartHoveredImg, (548, 608))
    screen.blit(X_score, (200, 610))
    screen.blit(O_score, (370, 610))
    scoreboard = font.render(': %d x %d :' % (score['X'], score['O']), True, background_color, light_grey)
    screen.blit(scoreboard, (244, 610))


def visualizeMove(row, col, previewImg):
    if board[row][col] == '':
        screen.blit(previewImg, (row * 200 + 12, col * 200 + 12))


def playerMove(player, row, col):
    board[row][col] = player


def computerMove(player):
    bestScore = float('inf')
    for row in range(3):
        for col in range(3):
            if board[row][col] == '':
                board[row][col] = 'O'
                score = minimax(board, 'X')
                board[row][col] = ''
                if score < bestScore:
                    bestScore = score
                    bestMove = (row, col)
    board[bestMove[0]][bestMove[1]] = player


scores = {'X': 1, 'O': -1, 'tie': 0}


def minimax(board, cur_player):
    if isWinner('X'):
        return scores['X']
    elif isWinner('O'):
        return scores['O']
    elif isBoardFull():
        return scores['tie']
    if cur_player == 'X':
        bestScore = float('-inf')
        nextPlayer = 'O'
        minORmax = max
    else:
        bestScore = float('inf')
        nextPlayer = 'X'
        minORmax = min
    for row in range(3):
        for col in range(3):
            if board[row][col] == '':
                board[row][col] = cur_player
                score = minimax(board, nextPlayer)
                board[row][col] = ''
                bestScore = minORmax(score, bestScore)
            if bestScore == scores[cur_player]:
                return bestScore
    return bestScore


def updatePlayer(player):
    if player == 'X':
        newPlayer = 'O'
        previewImg = previewCircleImg
    else:
        newPlayer = 'X'
        previewImg = previewCrossImg
    return newPlayer, previewImg



def isWinner(player):
    return ((board[0][0] == player and board[0][1] == player and board[0][2] == player) or
            (board[1][0] == player and board[1][1] == player and board[1][2] == player) or
            (board[2][0] == player and board[2][1] == player and board[2][2] == player) or
            (board[0][0] == player and board[1][0] == player and board[2][0] == player) or
            (board[0][1] == player and board[1][1] == player and board[2][1] == player) or
            (board[0][2] == player and board[1][2] == player and board[2][2] == player) or
            (board[0][0] == player and board[1][1] == player and board[2][2] == player) or
            (board[0][2] == player and board[1][1] == player and board[2][0] == player))


def verifyWinner(player):
    if isWinner(player):
        score[player] += 1
        ctypes.windll.user32.MessageBoxW(0, player + ' 获胜！', '提示', 0)
        resetBoard()
        return True
    return False


def isBoardFull():
    for i in range(3):
        for j in range(3):
            if board[i][j] == '':
                return False
    return True


def resetBoard():
    for i in range(3):
        for j in range(3):
            board[i][j] = ''


def resetGame():
    resetBoard()
    score['X'] = 0
    score['O'] = 0

def TCP_Client():
    global counter_row,counter_col
    while True:
        # 从终端读入用户输入的字符串
        # toSend = input('>>> ')
        # if toSend == 'exit':
        #     break
        # # 发送消息，也要编码为 bytes
        # dataSocket.send(toSend.encode())

        # 等待接收服务端的消息
        recved = dataSocket.recv(BUFLEN)
        # 如果返回空bytes，表示对方关闭了连接
        if not recved:
            break
        # 打印读取的信息
        print(recved.decode())
        rec=recved.decode()
        counter_row= int(rec[1])
        counter_col =int(rec[3])
        board[counter_row][counter_col] = "X"
        drawBoard()
        pygame.display.update()

client_thread = threading.Thread(target=TCP_Client)
client_thread.start()

menu()
dataSocket.close()
```

### 决出胜负

服务端

```python
import pygame
import ctypes
# 导入socket 库
from socket import *
import threading
import time

# 主机地址为空字符串，表示绑定本机所有网络接口ip地址
# 等待客户端来连接
IP = ''
# 端口号
PORT = 50000
# 定义一次从socket缓冲区最多读入512个字节数据
BUFLEN = 512

# 实例化一个socket对象
# 参数 AF_INET 表示该socket网络层使用IP协议
# 参数 SOCK_STREAM 表示该socket传输层使用TCP协议
listenSocket = socket(AF_INET, SOCK_STREAM)

# socket绑定地址和端口
listenSocket.bind((IP, PORT))


# 使socket处于监听状态，等待客户端的连接请求
# 参数 8 表示 最多接受多少个等待连接的客户端
listenSocket.listen(8)
print(f'服务端启动成功，在{PORT}端口等待客户端连接...')

dataSocket, addr = listenSocket.accept()
print('接受一个客户端连接:', addr)


global Send_Flag,Receive_Flag
# 初始化 pygame
pygame.init()

# 定义颜色
blue = (78, 140, 243)
light_blue = (100, 100, 255)
red = (242, 89, 97)
light_red = (255, 100, 100)
dark_grey = (85, 85, 85)
light_grey = (100, 100, 100)
background_color = (225, 225, 225)
Send_Flag = 0
Receive_Flag = 0
# 创建窗口
screen = pygame.display.set_mode((600, 800))
pygame.display.set_caption('井字棋')

# 游戏图片
crossImg = pygame.image.load('Images/crossImg.png')
crossImg_rect = crossImg.get_rect()
crossImg_rect.center = (200, 300)
circleImg = pygame.image.load('Images/circleImg.png')
circleImg_rect = crossImg.get_rect()
circleImg_rect.center = (400, 300)
previewCrossImg = pygame.image.load('Images/prev_crossImg.png')
previewCircleImg = pygame.image.load('Images/prev_circleImg.png')

# 按钮图片
restartImg = pygame.image.load('Images/restart.png')
restartHoveredImg = pygame.image.load('Images/restart_hovered.png')

# 定义棋盘
board = [['', '', ''],
         ['', '', ''],
         ['', '', '']]

# 定义计分板
score = {'X': 0, 'O': 0}
font = pygame.font.Font('freesansbold.ttf', 32)
X_score = pygame.image.load('Images/X_scoreImg.png')
O_score = pygame.image.load('Images/O_scoreImg.png')

# 菜单图片
buttom1 = pygame.image.load('Images/button1Img.png')
buttom1_rect = buttom1.get_rect()
buttom1_rect.center = (300, 312)
buttom2 = pygame.image.load('Images/button2Img.png')
buttom2_rect = buttom2.get_rect()
buttom2_rect.center = (300, 472)

buttom3 = pygame.image.load('Images/button3Img.png')
buttom3_rect = buttom3.get_rect()
buttom3_rect.center = (300, 632)

logo = pygame.image.load('Images/logo.png')

# 选择菜单图片
chooseImg = pygame.image.load('Images/choose.png')


def menu():
    running = True
    while running:
        screen.fill(background_color)
        mx, my = pygame.mouse.get_pos()
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if buttom1_rect.collidepoint((mx, my)):
                    game(0, 'X')
                elif buttom2_rect.collidepoint((mx, my)):
                    player = choose()
                    if player is not None:
                        game(1, player)
                elif buttom3_rect.collidepoint((mx, my)):
                    game(2, 'X')
        screen.blit(logo, (8, 25))
        screen.blit(buttom1, (100, 250))
        screen.blit(buttom2, (100, 410))
        screen.blit(buttom3, (100, 570))
        pygame.display.update()


def game(gameMode, player):
    global send_row, send_col ,Send_Flag,row, col,Receive_Flag
    my = player
    player = 'X'
    running = True
    previewImg = previewCrossImg
    while running:
        mouse = pygame.mouse.get_pos()
        row, col = int(mouse[0] / 200), int(mouse[1] / 200)
        for event in pygame.event.get():
            if verifyWinner('X'):
                player = 'X'
                previewImg = previewCrossImg
            if verifyWinner('O'):
                player = 'O'
                previewImg = previewCrossImg
            if event.type == pygame.QUIT:
                resetGame()
                running = False
            elif isBoardFull():
                ctypes.windll.user32.MessageBoxW(0, '平局', '提示', 0)
                resetBoard()
            elif gameMode == 1 and player != my:
                computerMove(player)
                drawBoard()
                pygame.display.update()
                if verifyWinner(player):
                    player = 'X'
                    previewImg = previewCrossImg
                else:
                    player, previewImg = updatePlayer(player)
            # elif gameMode == 2 and player != my:
            #
            #     # CounterMove(counter_row, counter_col)
            #     drawBoard()
            #     pygame.display.update()
                if verifyWinner(player):
                    player = 'X'
                    previewImg = previewCrossImg
                else:
                    player, previewImg = updatePlayer(player)
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if row < 3 and col < 3 and board[row][col] == '':
                    send_row = row
                    send_col = col
                    playerMove(player, row, col)
                    drawBoard()
                    Send_Flag = 1
                    pygame.display.update()
                    time.sleep(0.5)
                    if verifyWinner(player):
                        player = 'X'
                        previewImg = previewCrossImg
                    elif gameMode != 2:
                        player, previewImg = updatePlayer(player)
                    else:
                        Receive_Flag = 1
                elif 550 < mouse[0] < 582 and 610 < mouse[1] < 642:
                    resetGame()

        screen.fill(background_color)
        drawBoard()
        drawBottomMenu(mouse)
        if row < 3 and col < 3:
            visualizeMove(row, col, previewImg)
        pygame.display.update()


def choose():
    player = None
    running = True
    while running:
        mouse = pygame.mouse.get_pos()
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if crossImg_rect.collidepoint((mouse[0], mouse[1])):
                    player = 'X'
                    running = False
                elif circleImg_rect.collidepoint((mouse[0], mouse[1])):
                    player = 'O'
                    running = False
        screen.blit(crossImg, (80, 300))
        screen.blit(circleImg, (340, 300))
        screen.blit(chooseImg, (8, 25))
        pygame.display.update()
    return player


def drawBoard():
    # 画棋子
    for row in range(3):
        for col in range(3):
            pos = (row * 200 + 12, col * 200 + 12)
            if board[row][col] == 'X':
                screen.blit(crossImg, pos)
            elif board[row][col] == 'O':
                screen.blit(circleImg, pos)
    # 画网格
    width = 10
    color = dark_grey
    pygame.draw.line(screen, color, (200, 0), (200, 600), width)
    pygame.draw.line(screen, color, (400, 0), (400, 600), width)
    pygame.draw.line(screen, color, (0, 200), (600, 200), width)
    pygame.draw.line(screen, color, (0, 400), (600, 400), width)
    # 画边框
    pygame.draw.rect(screen, color, (0, 0, 10, 600))
    pygame.draw.rect(screen, color, (0, 0, 600, 10))
    pygame.draw.rect(screen, color, (590, 0, 10, 600))


def drawBottomMenu(mouse):
    pygame.draw.rect(screen, dark_grey, (0, 600, 600, 100))
    pygame.draw.rect(screen, light_grey, (10, 610, 580, 80))
    screen.blit(restartImg, (550, 610))
    # Hover animation
    if 550 < mouse[0] < 582 and 610 < mouse[1] < 642:
        screen.blit(restartHoveredImg, (548, 608))
    screen.blit(X_score, (200, 610))
    screen.blit(O_score, (370, 610))
    scoreboard = font.render(': %d x %d :' % (score['X'], score['O']), True, background_color, light_grey)
    screen.blit(scoreboard, (244, 610))


def visualizeMove(row, col, previewImg):
    if board[row][col] == '':
        screen.blit(previewImg, (row * 200 + 12, col * 200 + 12))


def playerMove(player, row, col):
    board[row][col] = player

def CounterMove(row, col):
    board[row][col] = "O"


def computerMove(player):
    bestScore = float('inf')
    for row in range(3):
        for col in range(3):
            if board[row][col] == '':
                board[row][col] = 'O'
                score = minimax(board, 'X')
                board[row][col] = ''
                if score < bestScore:
                    bestScore = score
                    bestMove = (row, col)
    board[bestMove[0]][bestMove[1]] = player


scores = {'X': 1, 'O': -1, 'tie': 0}


def minimax(board, cur_player):
    if isWinner('X'):
        return scores['X']
    elif isWinner('O'):
        return scores['O']
    elif isBoardFull():
        return scores['tie']
    if cur_player == 'X':
        bestScore = float('-inf')
        nextPlayer = 'O'
        minORmax = max
    else:
        bestScore = float('inf')
        nextPlayer = 'X'
        minORmax = min
    for row in range(3):
        for col in range(3):
            if board[row][col] == '':
                board[row][col] = cur_player
                score = minimax(board, nextPlayer)
                board[row][col] = ''
                bestScore = minORmax(score, bestScore)
            if bestScore == scores[cur_player]:
                return bestScore
    return bestScore


def updatePlayer(player):
    if player == 'X':
        newPlayer = 'O'
        previewImg = previewCircleImg
    else:
        newPlayer = 'X'
        previewImg = previewCrossImg
    return newPlayer, previewImg



def isWinner(player):
    return ((board[0][0] == player and board[0][1] == player and board[0][2] == player) or
            (board[1][0] == player and board[1][1] == player and board[1][2] == player) or
            (board[2][0] == player and board[2][1] == player and board[2][2] == player) or
            (board[0][0] == player and board[1][0] == player and board[2][0] == player) or
            (board[0][1] == player and board[1][1] == player and board[2][1] == player) or
            (board[0][2] == player and board[1][2] == player and board[2][2] == player) or
            (board[0][0] == player and board[1][1] == player and board[2][2] == player) or
            (board[0][2] == player and board[1][1] == player and board[2][0] == player))


def verifyWinner(player):
    if isWinner(player):
        score[player] += 1
        ctypes.windll.user32.MessageBoxW(0, player + ' 获胜！', '提示', 0)
        resetBoard()
        return True
    return False


def isBoardFull():
    for i in range(3):
        for j in range(3):
            if board[i][j] == '':
                return False
    return True


def resetBoard():
    for i in range(3):
        for j in range(3):
            board[i][j] = ''


def resetGame():
    resetBoard()
    score['X'] = 0
    score['O'] = 0
global i
i = 0
def TCP_Server():
    global send_row, send_col ,Send_Flag,row, col,Receive_Flag,i
    while True:
        # i = 0
        # time.sleep(1)
        # print("Server....Alive",i)
        # i +=1
        # 尝试读取对方发送的消息
        # BUFLEN 指定从接收缓冲里最多读取多少字节
        # recved = dataSocket.recv(BUFLEN)
        #
        # # 如果返回空bytes，表示对方关闭了连接
        # # 退出循环，结束消息收发
        # if not recved:
        #     break

        # 读取的字节数据是bytes类型，需要解码为字符串
        # info = recved.decode()
        # print(f'收到对方信息： {info}')
        #
        # # 发送的数据类型必须是bytes，所以要编码
        # dataSocket.send(f'服务端接收到了信息 '.encode())

        # 从终端读入用户输入的字符串
        # toSend = input('>>> ')
        # if toSend == 'exit':
        #     break
        # # 发送消息，也要编码为 bytes

        # recved = dataSocket.recv(BUFLEN)
        if Receive_Flag == 1:
            print("waiting for receiving...........")
            recved = dataSocket.recv(BUFLEN)
            if  not recved:
                break
            # 打印读取的信息
                print("receive,....",recved)
                print("not yet received.....")
            Receive_Flag = 0
            print(recved.decode())
            rec = recved.decode()
            counter_row = int(rec[1])
            counter_col = int(rec[3])
            board[counter_row][counter_col] = "O"
            drawBoard()
            pygame.display.update()

        if Send_Flag == 1:
            toSend = "r"+str(send_row)+"c"+str(send_col)
            print(" toSend ", toSend)
            dataSocket.send(toSend.encode())
            Send_Flag = 0
            time.sleep(0.5)

        # recved = dataSocket.recv(BUFLEN)
        # if  recved:
        # # 打印读取的信息
        #     print(recved.decode())
        #     rec=recved.decode()
        #     counter_row= int(rec[1])
        #     counter_col =int(rec[3])
        #     board[counter_row][counter_col] = "O"
        #     drawBoard()
        #     pygame.display.update()




    #
    # # 服务端也调用close()关闭socket
    # dataSocket.close()
    # listenSocket.close()

server_thread = threading.Thread(target = TCP_Server )
server_thread.start()
menu()
dataSocket.close()
listenSocket.close()
```

客户端

```python
import pygame
import ctypes
#  === TCP 客户端程序 client.py ===
import time
from socket import *
import threading
IP = '127.0.0.1'
SERVER_PORT = 50000
BUFLEN = 1024

# 实例化一个socket对象，指明协议
dataSocket = socket(AF_INET, SOCK_STREAM)
global Send_Flag,Receive_Flag
Send_Flag = 0
Receive_Flag = 1
# 连接服务端socket
dataSocket.connect((IP, SERVER_PORT))
# 初始化 pygame
pygame.init()

# 定义颜色
blue = (78, 140, 243)
light_blue = (100, 100, 255)
red = (242, 89, 97)
light_red = (255, 100, 100)
dark_grey = (85, 85, 85)
light_grey = (100, 100, 100)
background_color = (225, 225, 225)

# 创建窗口
screen = pygame.display.set_mode((600, 650))
pygame.display.set_caption('井字棋-客户端')

# 游戏图片
crossImg = pygame.image.load('Images/crossImg.png')
crossImg_rect = crossImg.get_rect()
crossImg_rect.center = (200, 300)
circleImg = pygame.image.load('Images/circleImg.png')
circleImg_rect = crossImg.get_rect()
circleImg_rect.center = (400, 300)
previewCrossImg = pygame.image.load('Images/prev_crossImg.png')
previewCircleImg = pygame.image.load('Images/prev_circleImg.png')

# 按钮图片
restartImg = pygame.image.load('Images/restart.png')
restartHoveredImg = pygame.image.load('Images/restart_hovered.png')

# 定义棋盘
board = [['', '', ''],
         ['', '', ''],
         ['', '', '']]

# 定义计分板
score = {'X': 0, 'O': 0}
font = pygame.font.Font('freesansbold.ttf', 32)
X_score = pygame.image.load('Images/X_scoreImg.png')
O_score = pygame.image.load('Images/O_scoreImg.png')

# 菜单图片
buttom1 = pygame.image.load('Images/button1Img.png')
buttom1_rect = buttom1.get_rect()
buttom1_rect.center = (300, 312)
buttom2 = pygame.image.load('Images/button2Img.png')
buttom2_rect = buttom2.get_rect()
buttom2_rect.center = (300, 472)
buttom3 = pygame.image.load('Images/button3Img.png')
buttom3_rect = buttom3.get_rect()
buttom3_rect.center = (300, 632)
logo = pygame.image.load('Images/logo.png')

# 选择菜单图片
chooseImg = pygame.image.load('Images/choose.png')


def menu():
    running = True
    while running:
        screen.fill(background_color)
        mx, my = pygame.mouse.get_pos()
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if buttom1_rect.collidepoint((mx, my)):
                    game(0, 'X')
                elif buttom2_rect.collidepoint((mx, my)):
                    player = choose()
                    if player is not None:
                        game(1, player)
                elif buttom3_rect.collidepoint((mx, my)):
                    game(2, 'O')
        screen.blit(logo, (8, 25))
        screen.blit(buttom1, (100, 250))
        screen.blit(buttom2, (100, 410))
        screen.blit(buttom3, (100, 570))
        pygame.display.update()


def game(gameMode, player):
    global send_row, send_col, Send_Flag, Receive_Flag,row, col
    my = player
    player = 'O'
    running = True
    previewImg = previewCrossImg
    while running:
        mouse = pygame.mouse.get_pos()
        row, col = int(mouse[0] / 200), int(mouse[1] / 200)
        for event in pygame.event.get():
            if verifyWinner('O'):
                player = 'O'
                previewImg = previewCrossImg
            if verifyWinner('X'):
                player = 'X'
                previewImg = previewCrossImg
            if event.type == pygame.QUIT:
                resetGame()
                running = False
            elif isBoardFull():
                ctypes.windll.user32.MessageBoxW(0, '平局', '提示', 0)
                resetBoard()
            elif gameMode == 1 and player != my:
                computerMove(player)
                drawBoard()
                pygame.display.update()
                if verifyWinner(player):
                    player = 'O'
                    previewImg = previewCrossImg
                else:
                    player, previewImg = updatePlayer(player)
            # elif gameMode == 2 and player != my:
            #     CounterMove(player)
            #     drawBoard()
            #     pygame.display.update()
            #     if verifyWinner(player):
            #         player = 'O'
            #         previewImg = previewCrossImg
            #     else:
            #         player, previewImg = updatePlayer(player)
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if row < 3 and col < 3 and board[row][col] == '':
                    send_row = row
                    send_col = col
                    playerMove(player, row, col)
                    drawBoard()
                    Send_Flag = 1
                    time.sleep(0.5)
                    if verifyWinner(player):
                        player = 'O'
                        previewImg = previewCrossImg
                    elif gameMode != 2:
                        player, previewImg = updatePlayer(player)

                    else:
                        Receive_Flag = 1
                elif 550 < mouse[0] < 582 and 610 < mouse[1] < 642:
                    resetGame()
        screen.fill(background_color)
        drawBoard()
        drawBottomMenu(mouse)
        if row < 3 and col < 3:
            visualizeMove(row, col, previewImg)
        pygame.display.update()


def choose():
    player = None
    running = True
    while running:
        mouse = pygame.mouse.get_pos()
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if crossImg_rect.collidepoint((mouse[0], mouse[1])):
                    player = 'X'
                    running = False
                elif circleImg_rect.collidepoint((mouse[0], mouse[1])):
                    player = 'O'
                    running = False
        screen.blit(crossImg, (80, 300))
        screen.blit(circleImg, (340, 300))
        screen.blit(chooseImg, (8, 25))
        pygame.display.update()
    return player


def drawBoard():
    # 画棋子
    for row in range(3):
        for col in range(3):
            pos = (row * 200 + 12, col * 200 + 12)
            if board[row][col] == 'X':
                screen.blit(crossImg, pos)
            elif board[row][col] == 'O':
                screen.blit(circleImg, pos)
    # 画网格
    width = 10
    color = dark_grey
    pygame.draw.line(screen, color, (200, 0), (200, 600), width)
    pygame.draw.line(screen, color, (400, 0), (400, 600), width)
    pygame.draw.line(screen, color, (0, 200), (600, 200), width)
    pygame.draw.line(screen, color, (0, 400), (600, 400), width)
    # 画边框
    pygame.draw.rect(screen, color, (0, 0, 10, 600))
    pygame.draw.rect(screen, color, (0, 0, 600, 10))
    pygame.draw.rect(screen, color, (590, 0, 10, 600))


def drawBottomMenu(mouse):
    pygame.draw.rect(screen, dark_grey, (0, 600, 600, 100))
    pygame.draw.rect(screen, light_grey, (10, 610, 580, 80))
    screen.blit(restartImg, (550, 610))
    # Hover animation
    if 550 < mouse[0] < 582 and 610 < mouse[1] < 642:
        screen.blit(restartHoveredImg, (548, 608))
    screen.blit(X_score, (200, 610))
    screen.blit(O_score, (370, 610))
    scoreboard = font.render(': %d x %d :' % (score['X'], score['O']), True, background_color, light_grey)
    screen.blit(scoreboard, (244, 610))


def visualizeMove(row, col, previewImg):
    if board[row][col] == '':
        screen.blit(previewImg, (row * 200 + 12, col * 200 + 12))


def playerMove(player, row, col):
    board[row][col] = player


def computerMove(player):
    bestScore = float('inf')
    for row in range(3):
        for col in range(3):
            if board[row][col] == '':
                board[row][col] = 'O'
                score = minimax(board, 'X')
                board[row][col] = ''
                if score < bestScore:
                    bestScore = score
                    bestMove = (row, col)
    board[bestMove[0]][bestMove[1]] = player


scores = {'X': 1, 'O': -1, 'tie': 0}


def minimax(board, cur_player):
    if isWinner('X'):
        return scores['X']
    elif isWinner('O'):
        return scores['O']
    elif isBoardFull():
        return scores['tie']
    if cur_player == 'X':
        bestScore = float('-inf')
        nextPlayer = 'O'
        minORmax = max
    else:
        bestScore = float('inf')
        nextPlayer = 'X'
        minORmax = min
    for row in range(3):
        for col in range(3):
            if board[row][col] == '':
                board[row][col] = cur_player
                score = minimax(board, nextPlayer)
                board[row][col] = ''
                bestScore = minORmax(score, bestScore)
            if bestScore == scores[cur_player]:
                return bestScore
    return bestScore


def updatePlayer(player):
    if player == 'X':
        newPlayer = 'O'
        previewImg = previewCircleImg
    else:
        newPlayer = 'X'
        previewImg = previewCrossImg
    return newPlayer, previewImg



def isWinner(player):
    return ((board[0][0] == player and board[0][1] == player and board[0][2] == player) or
            (board[1][0] == player and board[1][1] == player and board[1][2] == player) or
            (board[2][0] == player and board[2][1] == player and board[2][2] == player) or
            (board[0][0] == player and board[1][0] == player and board[2][0] == player) or
            (board[0][1] == player and board[1][1] == player and board[2][1] == player) or
            (board[0][2] == player and board[1][2] == player and board[2][2] == player) or
            (board[0][0] == player and board[1][1] == player and board[2][2] == player) or
            (board[0][2] == player and board[1][1] == player and board[2][0] == player))


def verifyWinner(player):
    if isWinner(player):
        score[player] += 1
        ctypes.windll.user32.MessageBoxW(0, player + ' 获胜！', '提示', 0)
        resetBoard()
        return True
    return False


def isBoardFull():
    for i in range(3):
        for j in range(3):
            if board[i][j] == '':
                return False
    return True


def resetBoard():
    for i in range(3):
        for j in range(3):
            board[i][j] = ''


def resetGame():
    resetBoard()
    score['X'] = 0
    score['O'] = 0
global i
i = 0
def TCP_Client():
    global send_row, send_col ,Send_Flag,row, col,Receive_Flag, i
    while True:
        # i = 0
        # time.sleep(1)
        # print("Receive_Flag",Receive_Flag)
        # print()
        # print("Client....Alive",i)
        # i += 1
        # 从终端读入用户输入的字符串
        # toSend = input('>>> ')
        # if toSend == 'exit':
        #     break
        # # 发送消息，也要编码为 bytes
        # dataSocket.send(toSend.encode())

        # 等待接收服务端的消息
        if Send_Flag == 1:
            toSend = "r"+str(send_row)+"c"+str(send_col)
            print(" toSend ", toSend)
            dataSocket.send(toSend.encode())
            Send_Flag = 0
            time.sleep(0.5)

        # recved = dataSocket.recv(BUFLEN)
        # 如果返回空bytes，表示对方关闭了连接
        if Receive_Flag == 1:
            print("waiting for receiving...........")
            recved = dataSocket.recv(BUFLEN)

            if  not recved:
                print("not yet received.....")
            # 打印读取的信息
                break
            print("receive,....", recved)
            Receive_Flag = 0
            print(recved.decode())
            rec = recved.decode()
            counter_row = int(rec[1])
            counter_col = int(rec[3])
            board[counter_row][counter_col] = "X"
            drawBoard()
            pygame.display.update()
            # print("receive",Receive_Flag)
            # print("send",Send_Flag)





client_thread = threading.Thread(target=TCP_Client)
client_thread.start()

menu()
dataSoc
```

### 只有在自己回合才能下棋

#### 服务端

```python
import pygame
import ctypes
# 导入socket 库
from socket import *
import threading
import time

# 主机地址为空字符串，表示绑定本机所有网络接口ip地址
# 等待客户端来连接
IP = ''
# 端口号
PORT = 50000
# 定义一次从socket缓冲区最多读入512个字节数据
BUFLEN = 512

# 实例化一个socket对象
# 参数 AF_INET 表示该socket网络层使用IP协议
# 参数 SOCK_STREAM 表示该socket传输层使用TCP协议
listenSocket = socket(AF_INET, SOCK_STREAM)

# socket绑定地址和端口
listenSocket.bind((IP, PORT))


# 使socket处于监听状态，等待客户端的连接请求
# 参数 8 表示 最多接受多少个等待连接的客户端
listenSocket.listen(8)
print(f'服务端启动成功，在{PORT}端口等待客户端连接...')

dataSocket, addr = listenSocket.accept()
print('接受一个客户端连接:', addr)


global Send_Flag,Receive_Flag,Current_Player
# 初始化 pygame
pygame.init()

# 定义颜色
blue = (78, 140, 243)
light_blue = (100, 100, 255)
red = (242, 89, 97)
light_red = (255, 100, 100)
dark_grey = (85, 85, 85)
light_grey = (100, 100, 100)
background_color = (225, 225, 225)
Send_Flag = 0
Receive_Flag = 0##一开始不发送也不接受，主机
Current_Player = 'X'#X先下棋
# 创建窗口
screen = pygame.display.set_mode((600, 800))
pygame.display.set_caption('井字棋')

# 游戏图片
crossImg = pygame.image.load('Images/crossImg.png')
crossImg_rect = crossImg.get_rect()
crossImg_rect.center = (200, 300)
circleImg = pygame.image.load('Images/circleImg.png')
circleImg_rect = crossImg.get_rect()
circleImg_rect.center = (400, 300)
previewCrossImg = pygame.image.load('Images/prev_crossImg.png')
previewCircleImg = pygame.image.load('Images/prev_circleImg.png')

# 按钮图片
restartImg = pygame.image.load('Images/restart.png')
restartHoveredImg = pygame.image.load('Images/restart_hovered.png')

# 定义棋盘
board = [['', '', ''],
         ['', '', ''],
         ['', '', '']]

# 定义计分板
score = {'X': 0, 'O': 0}
font = pygame.font.Font('freesansbold.ttf', 32)
X_score = pygame.image.load('Images/X_scoreImg.png')
O_score = pygame.image.load('Images/O_scoreImg.png')

# 菜单图片
buttom1 = pygame.image.load('Images/button1Img.png')
buttom1_rect = buttom1.get_rect()
buttom1_rect.center = (300, 312)
buttom2 = pygame.image.load('Images/button2Img.png')
buttom2_rect = buttom2.get_rect()
buttom2_rect.center = (300, 472)

buttom3 = pygame.image.load('Images/button3Img.png')
buttom3_rect = buttom3.get_rect()
buttom3_rect.center = (300, 632)

logo = pygame.image.load('Images/logo.png')

# 选择菜单图片
chooseImg = pygame.image.load('Images/choose.png')


def menu():
    running = True
    while running:
        screen.fill(background_color)
        mx, my = pygame.mouse.get_pos()
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if buttom1_rect.collidepoint((mx, my)):
                    game(0, 'X')
                elif buttom2_rect.collidepoint((mx, my)):
                    player = choose()
                    if player is not None:
                        game(1, player)
                elif buttom3_rect.collidepoint((mx, my)):
                    game(2, 'X')
        screen.blit(logo, (8, 25))
        screen.blit(buttom1, (100, 250))
        screen.blit(buttom2, (100, 410))
        screen.blit(buttom3, (100, 570))
        pygame.display.update()


def game(gameMode, player):
    global send_row, send_col ,Send_Flag,row, col,Receive_Flag,Current_Player
    my = player
    player = 'X'
    running = True
    previewImg = previewCrossImg
    while running:
        mouse = pygame.mouse.get_pos()
        row, col = int(mouse[0] / 200), int(mouse[1] / 200)
        for event in pygame.event.get():
            if verifyWinner('X'):
                player = 'X'
                previewImg = previewCrossImg
            if verifyWinner('O'):
                player = 'O'
                previewImg = previewCrossImg
            if event.type == pygame.QUIT:
                resetGame()
                running = False
            elif isBoardFull():
                ctypes.windll.user32.MessageBoxW(0, '平局', '提示', 0)
                resetBoard()
            elif gameMode == 1 and player != my:
                computerMove(player)
                drawBoard()
                pygame.display.update()
                if verifyWinner(player):
                    player = 'X'
                    previewImg = previewCrossImg
                else:
                    player, previewImg = updatePlayer(player)
            # elif gameMode == 2 and player != my:
            #
            #     # CounterMove(counter_row, counter_col)
            #     drawBoard()
            #     pygame.display.update()
                if verifyWinner(player):
                    player = 'X'
                    previewImg = previewCrossImg
                else:
                    player, previewImg = updatePlayer(player)
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if gameMode != 2:
                    if row < 3 and col < 3 and board[row][col] == '':
                        send_row = row
                        send_col = col
                        playerMove(player, row, col)
                        drawBoard()
                        Send_Flag = 1
                        time.sleep(0.5)
                        if verifyWinner('X'):
                            player = 'X'
                            previewImg = previewCrossImg
                        else :
                            player, previewImg = updatePlayer(player)
                    #
                    #     else:
                    #         Receive_Flag = 1
                    # elif 550 < mouse[0] < 582 and 610 < mouse[1] < 642:
                    #     resetGame()
                if gameMode == 2:
                    if row < 3 and col < 3 and board[row][col] == '' and Current_Player == 'X':#自己的回合鼠标才能点击
                        send_row = row
                        send_col = col
                        playerMove('X', row, col)
                        drawBoard()
                        Current_Player = 'O'#下完换对方
                        Send_Flag = 1
                        time.sleep(0.5)
                        Receive_Flag = 1
                        # if verifyWinner(player):
                        #     player = 'O'
                        #     previewImg = previewCrossImg
                        # elif gameMode != 2:
                        #
                    else:
                            Receive_Flag = 1
                if 550 < mouse[0] < 582 and 610 < mouse[1] < 642:
                        resetGame()


        screen.fill(background_color)
        drawBoard()
        drawBottomMenu(mouse)
        if row < 3 and col < 3:
            visualizeMove(row, col, previewImg)
        pygame.display.update()


def choose():
    player = None
    running = True
    while running:
        mouse = pygame.mouse.get_pos()
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if crossImg_rect.collidepoint((mouse[0], mouse[1])):
                    player = 'X'
                    running = False
                elif circleImg_rect.collidepoint((mouse[0], mouse[1])):
                    player = 'O'
                    running = False
        screen.blit(crossImg, (80, 300))
        screen.blit(circleImg, (340, 300))
        screen.blit(chooseImg, (8, 25))
        pygame.display.update()
    return player


def drawBoard():
    # 画棋子
    for row in range(3):
        for col in range(3):
            pos = (row * 200 + 12, col * 200 + 12)
            if board[row][col] == 'X':
                screen.blit(crossImg, pos)
            elif board[row][col] == 'O':
                screen.blit(circleImg, pos)
    # 画网格
    width = 10
    color = dark_grey
    pygame.draw.line(screen, color, (200, 0), (200, 600), width)
    pygame.draw.line(screen, color, (400, 0), (400, 600), width)
    pygame.draw.line(screen, color, (0, 200), (600, 200), width)
    pygame.draw.line(screen, color, (0, 400), (600, 400), width)
    # 画边框
    pygame.draw.rect(screen, color, (0, 0, 10, 600))
    pygame.draw.rect(screen, color, (0, 0, 600, 10))
    pygame.draw.rect(screen, color, (590, 0, 10, 600))


def drawBottomMenu(mouse):
    pygame.draw.rect(screen, dark_grey, (0, 600, 600, 100))
    pygame.draw.rect(screen, light_grey, (10, 610, 580, 80))
    screen.blit(restartImg, (550, 610))
    # Hover animation
    if 550 < mouse[0] < 582 and 610 < mouse[1] < 642:
        screen.blit(restartHoveredImg, (548, 608))
    screen.blit(X_score, (200, 610))
    screen.blit(O_score, (370, 610))
    scoreboard = font.render(': %d x %d :' % (score['X'], score['O']), True, background_color, light_grey)
    screen.blit(scoreboard, (244, 610))


def visualizeMove(row, col, previewImg):
    if board[row][col] == '':
        screen.blit(previewImg, (row * 200 + 12, col * 200 + 12))


def playerMove(player, row, col):
    board[row][col] = player

def CounterMove(row, col):
    board[row][col] = "O"


def computerMove(player):
    bestScore = float('inf')
    for row in range(3):
        for col in range(3):
            if board[row][col] == '':
                board[row][col] = 'O'
                score = minimax(board, 'X')
                board[row][col] = ''
                if score < bestScore:
                    bestScore = score
                    bestMove = (row, col)
    board[bestMove[0]][bestMove[1]] = player


scores = {'X': 1, 'O': -1, 'tie': 0}


def minimax(board, cur_player):
    if isWinner('X'):
        return scores['X']
    elif isWinner('O'):
        return scores['O']
    elif isBoardFull():
        return scores['tie']
    if cur_player == 'X':
        bestScore = float('-inf')
        nextPlayer = 'O'
        minORmax = max
    else:
        bestScore = float('inf')
        nextPlayer = 'X'
        minORmax = min
    for row in range(3):
        for col in range(3):
            if board[row][col] == '':
                board[row][col] = cur_player
                score = minimax(board, nextPlayer)
                board[row][col] = ''
                bestScore = minORmax(score, bestScore)
            if bestScore == scores[cur_player]:
                return bestScore
    return bestScore


def updatePlayer(player):
    if player == 'X':
        newPlayer = 'O'
        previewImg = previewCircleImg
    else:
        newPlayer = 'X'
        previewImg = previewCrossImg
    return newPlayer, previewImg



def isWinner(player):
    return ((board[0][0] == player and board[0][1] == player and board[0][2] == player) or
            (board[1][0] == player and board[1][1] == player and board[1][2] == player) or
            (board[2][0] == player and board[2][1] == player and board[2][2] == player) or
            (board[0][0] == player and board[1][0] == player and board[2][0] == player) or
            (board[0][1] == player and board[1][1] == player and board[2][1] == player) or
            (board[0][2] == player and board[1][2] == player and board[2][2] == player) or
            (board[0][0] == player and board[1][1] == player and board[2][2] == player) or
            (board[0][2] == player and board[1][1] == player and board[2][0] == player))


def verifyWinner(player):
    if isWinner(player):
        score[player] += 1
        ctypes.windll.user32.MessageBoxW(0, player + ' 获胜！', '提示', 0)
        resetBoard()
        return True
    return False


def isBoardFull():
    for i in range(3):
        for j in range(3):
            if board[i][j] == '':
                return False
    return True


def resetBoard():
    for i in range(3):
        for j in range(3):
            board[i][j] = ''


def resetGame():
    resetBoard()
    score['X'] = 0
    score['O'] = 0
global i
i = 0
def TCP_Server():
    global send_row, send_col ,Send_Flag,row, col,Receive_Flag,i,Current_Player
    while True:
        # i = 0
        # time.sleep(1)
        # print("Server....Alive",i)
        # i +=1
        # 尝试读取对方发送的消息
        # BUFLEN 指定从接收缓冲里最多读取多少字节
        # recved = dataSocket.recv(BUFLEN)
        #
        # # 如果返回空bytes，表示对方关闭了连接
        # # 退出循环，结束消息收发
        # if not recved:
        #     break

        # 读取的字节数据是bytes类型，需要解码为字符串
        # info = recved.decode()
        # print(f'收到对方信息： {info}')
        #
        # # 发送的数据类型必须是bytes，所以要编码
        # dataSocket.send(f'服务端接收到了信息 '.encode())

        # 从终端读入用户输入的字符串
        # toSend = input('>>> ')
        # if toSend == 'exit':
        #     break
        # # 发送消息，也要编码为 bytes

        # recved = dataSocket.recv(BUFLEN)
        if Receive_Flag == 1:
            print("waiting for receiving...........")
            recved = dataSocket.recv(BUFLEN)
            if  not recved:
                break
            # 打印读取的信息
                print("receive,....",recved)
                print("not yet received.....")

            Receive_Flag = 0
            print(recved.decode())
            rec = recved.decode()
            counter_row = int(rec[1])
            counter_col = int(rec[3])
            board[counter_row][counter_col] = "O"
            drawBoard()
            Current_Player = 'X'##收到对面信息后回到主场
            pygame.display.update()

        if Send_Flag == 1:
            toSend = "r"+str(send_row)+"c"+str(send_col)
            print(" toSend ", toSend)
            dataSocket.send(toSend.encode())
            Send_Flag = 0
            time.sleep(0.5)

        # recved = dataSocket.recv(BUFLEN)
        # if  recved:
        # # 打印读取的信息
        #     print(recved.decode())
        #     rec=recved.decode()
        #     counter_row= int(rec[1])
        #     counter_col =int(rec[3])
        #     board[counter_row][counter_col] = "O"
        #     drawBoard()
        #     pygame.display.update()




    #
    # # 服务端也调用close()关闭socket
    # dataSocket.close()
    # listenSocket.close()

server_thread = threading.Thread(target = TCP_Server )
server_thread.start()
menu()
dataSocket.close()
listenSocket.close()
```

#### 客户端

```python
import pygame
import ctypes
#  === TCP 客户端程序 client.py ===
import time
from socket import *
import threading
IP = '127.0.0.1'
SERVER_PORT = 50000
BUFLEN = 1024

# 实例化一个socket对象，指明协议
dataSocket = socket(AF_INET, SOCK_STREAM)
global Send_Flag,Receive_Flag,current_player
Send_Flag = 0
Receive_Flag = 1
current_player = 'X'#服务端先下
# 连接服务端socket
dataSocket.connect((IP, SERVER_PORT))
# 初始化 pygame
pygame.init()

# 定义颜色
blue = (78, 140, 243)
light_blue = (100, 100, 255)
red = (242, 89, 97)
light_red = (255, 100, 100)
dark_grey = (85, 85, 85)
light_grey = (100, 100, 100)
background_color = (225, 225, 225)

# 创建窗口
screen = pygame.display.set_mode((600, 650))
pygame.display.set_caption('井字棋-客户端')

# 游戏图片
crossImg = pygame.image.load('Images/crossImg.png')
crossImg_rect = crossImg.get_rect()
crossImg_rect.center = (200, 300)
circleImg = pygame.image.load('Images/circleImg.png')
circleImg_rect = crossImg.get_rect()
circleImg_rect.center = (400, 300)
previewCrossImg = pygame.image.load('Images/prev_crossImg.png')
previewCircleImg = pygame.image.load('Images/prev_circleImg.png')

# 按钮图片
restartImg = pygame.image.load('Images/restart.png')
restartHoveredImg = pygame.image.load('Images/restart_hovered.png')

# 定义棋盘
board = [['', '', ''],
         ['', '', ''],
         ['', '', '']]

# 定义计分板
score = {'X': 0, 'O': 0}
font = pygame.font.Font('freesansbold.ttf', 32)
X_score = pygame.image.load('Images/X_scoreImg.png')
O_score = pygame.image.load('Images/O_scoreImg.png')

# 菜单图片
buttom1 = pygame.image.load('Images/button1Img.png')
buttom1_rect = buttom1.get_rect()
buttom1_rect.center = (300, 312)
buttom2 = pygame.image.load('Images/button2Img.png')
buttom2_rect = buttom2.get_rect()
buttom2_rect.center = (300, 472)
buttom3 = pygame.image.load('Images/button3Img.png')
buttom3_rect = buttom3.get_rect()
buttom3_rect.center = (300, 632)
logo = pygame.image.load('Images/logo.png')

# 选择菜单图片
chooseImg = pygame.image.load('Images/choose.png')


def menu():
    running = True
    while running:
        screen.fill(background_color)
        mx, my = pygame.mouse.get_pos()
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if buttom1_rect.collidepoint((mx, my)):
                    game(0, 'X')
                elif buttom2_rect.collidepoint((mx, my)):
                    player = choose()
                    if player is not None:
                        game(1, player)
                elif buttom3_rect.collidepoint((mx, my)):
                    game(2, 'O')
        screen.blit(logo, (8, 25))
        screen.blit(buttom1, (100, 250))
        screen.blit(buttom2, (100, 410))
        screen.blit(buttom3, (100, 570))
        pygame.display.update()


def game(gameMode, player):
    global send_row, send_col, Send_Flag, Receive_Flag,row, col,current_player
    my = player
    player = 'O'
    running = True
    previewImg = previewCrossImg
    while running:
        mouse = pygame.mouse.get_pos()
        row, col = int(mouse[0] / 200), int(mouse[1] / 200)
        for event in pygame.event.get():
            if verifyWinner('O'):
                player = 'O'
                previewImg = previewCrossImg
            if verifyWinner('X'):
                player = 'X'
                previewImg = previewCrossImg
            if event.type == pygame.QUIT:
                resetGame()
                running = False
            elif isBoardFull():
                ctypes.windll.user32.MessageBoxW(0, '平局', '提示', 0)
                resetBoard()
            elif gameMode == 1 and player != my:
                computerMove(player)
                drawBoard()
                pygame.display.update()
                if verifyWinner(player):
                    player = 'O'
                    previewImg = previewCrossImg
                else:
                    player, previewImg = updatePlayer(player)
            # elif gameMode == 2 and player != my:
            #     CounterMove(player)
            #     drawBoard()
            #     pygame.display.update()
            #     if verifyWinner(player):
            #         player = 'O'
            #         previewImg = previewCrossImg
            #     else:
            #         player, previewImg = updatePlayer(player)
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if gameMode != 2:
                    if row < 3 and col < 3 and board[row][col] == '':
                        send_row = row
                        send_col = col
                        playerMove(player, row, col)
                        drawBoard()
                        Send_Flag = 1
                        time.sleep(0.5)
                        if verifyWinner(player):
                            player = 'O'
                            previewImg = previewCrossImg
                        else :
                            player, previewImg = updatePlayer(player)
                    #
                    #     else:
                    #         Receive_Flag = 1
                    # elif 550 < mouse[0] < 582 and 610 < mouse[1] < 642:
                    #     resetGame()
                if gameMode == 2:
                    if row < 3 and col < 3 and board[row][col] == '' and current_player == 'O':#自己的回合鼠标才能点击
                        send_row = row
                        send_col = col
                        playerMove('O', row, col)
                        drawBoard()
                        current_player = 'X'#下完换对方
                        Send_Flag = 1
                        time.sleep(0.5)
                        Receive_Flag = 1
                        # if verifyWinner(player):
                        #     player = 'O'
                        #     previewImg = previewCrossImg
                        # elif gameMode != 2:
                        #
                    else:
                            Receive_Flag = 1
                if 550 < mouse[0] < 582 and 610 < mouse[1] < 642:
                        resetGame()
        screen.fill(background_color)
        drawBoard()
        drawBottomMenu(mouse)
        if row < 3 and col < 3:
            visualizeMove(row, col, previewImg)
        pygame.display.update()


def choose():
    player = None
    running = True
    while running:
        mouse = pygame.mouse.get_pos()
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if crossImg_rect.collidepoint((mouse[0], mouse[1])):
                    player = 'X'
                    running = False
                elif circleImg_rect.collidepoint((mouse[0], mouse[1])):
                    player = 'O'
                    running = False
        screen.blit(crossImg, (80, 300))
        screen.blit(circleImg, (340, 300))
        screen.blit(chooseImg, (8, 25))
        pygame.display.update()
    return player


def drawBoard():
    # 画棋子
    for row in range(3):
        for col in range(3):
            pos = (row * 200 + 12, col * 200 + 12)
            if board[row][col] == 'X':
                screen.blit(crossImg, pos)
            elif board[row][col] == 'O':
                screen.blit(circleImg, pos)
    # 画网格
    width = 10
    color = dark_grey
    pygame.draw.line(screen, color, (200, 0), (200, 600), width)
    pygame.draw.line(screen, color, (400, 0), (400, 600), width)
    pygame.draw.line(screen, color, (0, 200), (600, 200), width)
    pygame.draw.line(screen, color, (0, 400), (600, 400), width)
    # 画边框
    pygame.draw.rect(screen, color, (0, 0, 10, 600))
    pygame.draw.rect(screen, color, (0, 0, 600, 10))
    pygame.draw.rect(screen, color, (590, 0, 10, 600))


def drawBottomMenu(mouse):
    pygame.draw.rect(screen, dark_grey, (0, 600, 600, 100))
    pygame.draw.rect(screen, light_grey, (10, 610, 580, 80))
    screen.blit(restartImg, (550, 610))
    # Hover animation
    if 550 < mouse[0] < 582 and 610 < mouse[1] < 642:
        screen.blit(restartHoveredImg, (548, 608))
    screen.blit(X_score, (200, 610))
    screen.blit(O_score, (370, 610))
    scoreboard = font.render(': %d x %d :' % (score['X'], score['O']), True, background_color, light_grey)
    screen.blit(scoreboard, (244, 610))


def visualizeMove(row, col, previewImg):
    if board[row][col] == '':
        screen.blit(previewImg, (row * 200 + 12, col * 200 + 12))


def playerMove(player, row, col):
    board[row][col] = player


def computerMove(player):
    bestScore = float('inf')
    for row in range(3):
        for col in range(3):
            if board[row][col] == '':
                board[row][col] = 'O'
                score = minimax(board, 'X')
                board[row][col] = ''
                if score < bestScore:
                    bestScore = score
                    bestMove = (row, col)
    board[bestMove[0]][bestMove[1]] = player


scores = {'X': 1, 'O': -1, 'tie': 0}


def minimax(board, cur_player):
    if isWinner('X'):
        return scores['X']
    elif isWinner('O'):
        return scores['O']
    elif isBoardFull():
        return scores['tie']
    if cur_player == 'X':
        bestScore = float('-inf')
        nextPlayer = 'O'
        minORmax = max
    else:
        bestScore = float('inf')
        nextPlayer = 'X'
        minORmax = min
    for row in range(3):
        for col in range(3):
            if board[row][col] == '':
                board[row][col] = cur_player
                score = minimax(board, nextPlayer)
                board[row][col] = ''
                bestScore = minORmax(score, bestScore)
            if bestScore == scores[cur_player]:
                return bestScore
    return bestScore


def updatePlayer(player):
    if player == 'X':
        newPlayer = 'O'
        previewImg = previewCircleImg
    else:
        newPlayer = 'X'
        previewImg = previewCrossImg
    return newPlayer, previewImg



def isWinner(player):
    return ((board[0][0] == player and board[0][1] == player and board[0][2] == player) or
            (board[1][0] == player and board[1][1] == player and board[1][2] == player) or
            (board[2][0] == player and board[2][1] == player and board[2][2] == player) or
            (board[0][0] == player and board[1][0] == player and board[2][0] == player) or
            (board[0][1] == player and board[1][1] == player and board[2][1] == player) or
            (board[0][2] == player and board[1][2] == player and board[2][2] == player) or
            (board[0][0] == player and board[1][1] == player and board[2][2] == player) or
            (board[0][2] == player and board[1][1] == player and board[2][0] == player))


def verifyWinner(player):
    if isWinner(player):
        score[player] += 1
        ctypes.windll.user32.MessageBoxW(0, player + ' 获胜！', '提示', 0)
        resetBoard()
        return True
    return False


def isBoardFull():
    for i in range(3):
        for j in range(3):
            if board[i][j] == '':
                return False
    return True


def resetBoard():
    for i in range(3):
        for j in range(3):
            board[i][j] = ''


def resetGame():
    resetBoard()
    score['X'] = 0
    score['O'] = 0
global i
i = 0
def TCP_Client():
    global send_row, send_col ,Send_Flag,row, col,Receive_Flag, i, current_player
    while True:
        # i = 0
        # time.sleep(1)
        # print("Receive_Flag",Receive_Flag)
        # print()
        # print("Client....Alive",i)
        # i += 1
        # 从终端读入用户输入的字符串
        # toSend = input('>>> ')
        # if toSend == 'exit':
        #     break
        # # 发送消息，也要编码为 bytes
        # dataSocket.send(toSend.encode())

        # 等待接收服务端的消息
        if Send_Flag == 1:
            toSend = "r"+str(send_row)+"c"+str(send_col)
            print(" toSend ", toSend)
            dataSocket.send(toSend.encode())
            Send_Flag = 0
            time.sleep(0.5)

        # recved = dataSocket.recv(BUFLEN)
        # 如果返回空bytes，表示对方关闭了连接
        if Receive_Flag == 1:
            print("waiting for receiving...........")
            recved = dataSocket.recv(BUFLEN)

            if  not recved:
                print("not yet received.....")
            # 打印读取的信息
                break
            print("receive,....", recved)
            current_player = 'O'#接受到数据后回到主场
            Receive_Flag = 0
            print(recved.decode())
            rec = recved.decode()
            counter_row = int(rec[1])
            counter_col = int(rec[3])
            board[counter_row][counter_col] = "X"
            drawBoard()
            pygame.display.update()
            # print("receive",Receive_Flag)
            # print("send",Send_Flag)





client_thread = threading.Thread(target=TCP_Client)
client_thread.start()

menu()
dataSoc
```

### 修正重新开始无法同步

#### 服务端

```python
import pygame
import ctypes
# 导入socket 库
from socket import *
import threading
import time

# 主机地址为空字符串，表示绑定本机所有网络接口ip地址
# 等待客户端来连接
IP = ''
# 端口号
PORT = 50000
# 定义一次从socket缓冲区最多读入512个字节数据
BUFLEN = 512

# 实例化一个socket对象
# 参数 AF_INET 表示该socket网络层使用IP协议
# 参数 SOCK_STREAM 表示该socket传输层使用TCP协议
listenSocket = socket(AF_INET, SOCK_STREAM)

# socket绑定地址和端口
listenSocket.bind((IP, PORT))


# 使socket处于监听状态，等待客户端的连接请求
# 参数 8 表示 最多接受多少个等待连接的客户端
listenSocket.listen(8)
print(f'服务端启动成功，在{PORT}端口等待客户端连接...')

dataSocket, addr = listenSocket.accept()
print('接受一个客户端连接:', addr)


global Send_Flag,Receive_Flag,Current_Player,If_over
# 初始化 pygame
pygame.init()

# 定义颜色
blue = (78, 140, 243)
light_blue = (100, 100, 255)
red = (242, 89, 97)
light_red = (255, 100, 100)
dark_grey = (85, 85, 85)
light_grey = (100, 100, 100)
background_color = (225, 225, 225)
Send_Flag = 0
Receive_Flag = 0##一开始不发送也不接受，主机
Current_Player = 'X'#X先下棋
If_over = 0
# 创建窗口
screen = pygame.display.set_mode((600, 800))
pygame.display.set_caption('井字棋')

# 游戏图片
crossImg = pygame.image.load('Images/crossImg.png')
crossImg_rect = crossImg.get_rect()
crossImg_rect.center = (200, 300)
circleImg = pygame.image.load('Images/circleImg.png')
circleImg_rect = crossImg.get_rect()
circleImg_rect.center = (400, 300)
previewCrossImg = pygame.image.load('Images/prev_crossImg.png')
previewCircleImg = pygame.image.load('Images/prev_circleImg.png')

# 按钮图片
restartImg = pygame.image.load('Images/restart.png')
restartHoveredImg = pygame.image.load('Images/restart_hovered.png')

# 定义棋盘
board = [['', '', ''],
         ['', '', ''],
         ['', '', '']]

# 定义计分板
score = {'X': 0, 'O': 0}
font = pygame.font.Font('freesansbold.ttf', 32)
X_score = pygame.image.load('Images/X_scoreImg.png')
O_score = pygame.image.load('Images/O_scoreImg.png')

# 菜单图片
buttom1 = pygame.image.load('Images/button1Img.png')
buttom1_rect = buttom1.get_rect()
buttom1_rect.center = (300, 312)
buttom2 = pygame.image.load('Images/button2Img.png')
buttom2_rect = buttom2.get_rect()
buttom2_rect.center = (300, 472)

buttom3 = pygame.image.load('Images/button3Img.png')
buttom3_rect = buttom3.get_rect()
buttom3_rect.center = (300, 632)

logo = pygame.image.load('Images/logo.png')

# 选择菜单图片
chooseImg = pygame.image.load('Images/choose.png')


def menu():
    running = True
    while running:
        screen.fill(background_color)
        mx, my = pygame.mouse.get_pos()
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if buttom1_rect.collidepoint((mx, my)):
                    game(0, 'X')
                elif buttom2_rect.collidepoint((mx, my)):
                    player = choose()
                    if player is not None:
                        game(1, player)
                elif buttom3_rect.collidepoint((mx, my)):
                    game(2, 'X')
        screen.blit(logo, (8, 25))
        screen.blit(buttom1, (100, 250))
        screen.blit(buttom2, (100, 410))
        screen.blit(buttom3, (100, 570))
        pygame.display.update()


def game(gameMode, player):
    global send_row, send_col ,Send_Flag,row, col,Receive_Flag,Current_Player,If_over
    my = player
    player = 'X'
    running = True
    previewImg = previewCrossImg
    while running:
        mouse = pygame.mouse.get_pos()
        row, col = int(mouse[0] / 200), int(mouse[1] / 200)
        for event in pygame.event.get():
            if verifyWinner('X'):
                player = 'X'
                previewImg = previewCrossImg
            if verifyWinner('O'):
                player = 'O'
                previewImg = previewCrossImg
            if event.type == pygame.QUIT:
                resetGame()
                running = False
            elif isBoardFull():
                ctypes.windll.user32.MessageBoxW(0, '平局', '提示', 0)
                resetBoard()
            elif gameMode == 1 and player != my:
                computerMove(player)
                drawBoard()
                pygame.display.update()
                if verifyWinner(player):
                    player = 'X'
                    previewImg = previewCrossImg
                else:
                    player, previewImg = updatePlayer(player)
            # elif gameMode == 2 and player != my:
            #
            #     # CounterMove(counter_row, counter_col)
            #     drawBoard()
            #     pygame.display.update()
                if verifyWinner(player):
                    player = 'X'
                    previewImg = previewCrossImg
                else:
                    player, previewImg = updatePlayer(player)
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if gameMode != 2:
                    if row < 3 and col < 3 and board[row][col] == '':
                        # send_row = row
                        # send_col = col
                        playerMove(player, row, col)
                        drawBoard()
                        Send_Flag = 1
                        time.sleep(0.5)
                        if verifyWinner('X'):
                            player = 'X'
                            previewImg = previewCrossImg
                        else :
                            player, previewImg = updatePlayer(player)
                    #
                    #     else:
                    #         Receive_Flag = 1
                    # elif 550 < mouse[0] < 582 and 610 < mouse[1] < 642:
                    #     resetGame()
                if gameMode == 2:
                    if row < 3 and col < 3 and board[row][col] == '' and Current_Player == 'X':#自己的回合鼠标才能点击
                        send_row = row
                        send_col = col
                        playerMove('X', row, col)
                        drawBoard()
                        Current_Player = 'O'#下完换对方
                        Send_Flag = 1
                        time.sleep(0.5)
                        Receive_Flag = 1
                        # if verifyWinner(player):
                        #     player = 'O'
                        #     previewImg = previewCrossImg
                        # elif gameMode != 2:
                        #
                    else:
                            Receive_Flag = 1
                if 550 < mouse[0] < 582 and 610 < mouse[1] < 642:
                        resetGame()


        screen.fill(background_color)
        drawBoard()
        drawBottomMenu(mouse)
        if row < 3 and col < 3:
            visualizeMove(row, col, previewImg)
        pygame.display.update()


def choose():
    player = None
    running = True
    while running:
        mouse = pygame.mouse.get_pos()
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if crossImg_rect.collidepoint((mouse[0], mouse[1])):
                    player = 'X'
                    running = False
                elif circleImg_rect.collidepoint((mouse[0], mouse[1])):
                    player = 'O'
                    running = False
        screen.blit(crossImg, (80, 300))
        screen.blit(circleImg, (340, 300))
        screen.blit(chooseImg, (8, 25))
        pygame.display.update()
    return player


def drawBoard():
    # 画棋子
    for row in range(3):
        for col in range(3):
            pos = (row * 200 + 12, col * 200 + 12)
            if board[row][col] == 'X':
                screen.blit(crossImg, pos)
            elif board[row][col] == 'O':
                screen.blit(circleImg, pos)
    # 画网格
    width = 10
    color = dark_grey
    pygame.draw.line(screen, color, (200, 0), (200, 600), width)
    pygame.draw.line(screen, color, (400, 0), (400, 600), width)
    pygame.draw.line(screen, color, (0, 200), (600, 200), width)
    pygame.draw.line(screen, color, (0, 400), (600, 400), width)
    # 画边框
    pygame.draw.rect(screen, color, (0, 0, 10, 600))
    pygame.draw.rect(screen, color, (0, 0, 600, 10))
    pygame.draw.rect(screen, color, (590, 0, 10, 600))


def drawBottomMenu(mouse):
    pygame.draw.rect(screen, dark_grey, (0, 600, 600, 100))
    pygame.draw.rect(screen, light_grey, (10, 610, 580, 80))
    screen.blit(restartImg, (550, 610))
    # Hover animation
    if 550 < mouse[0] < 582 and 610 < mouse[1] < 642:
        screen.blit(restartHoveredImg, (548, 608))
    screen.blit(X_score, (200, 610))
    screen.blit(O_score, (370, 610))
    scoreboard = font.render(': %d x %d :' % (score['X'], score['O']), True, background_color, light_grey)
    screen.blit(scoreboard, (244, 610))


def visualizeMove(row, col, previewImg):
    if board[row][col] == '':
        screen.blit(previewImg, (row * 200 + 12, col * 200 + 12))


def playerMove(player, row, col):
    board[row][col] = player

def CounterMove(row, col):
    board[row][col] = "O"


def computerMove(player):
    bestScore = float('inf')
    for row in range(3):
        for col in range(3):
            if board[row][col] == '':
                board[row][col] = 'O'
                score = minimax(board, 'X')
                board[row][col] = ''
                if score < bestScore:
                    bestScore = score
                    bestMove = (row, col)
    board[bestMove[0]][bestMove[1]] = player


scores = {'X': 1, 'O': -1, 'tie': 0}


def minimax(board, cur_player):
    if isWinner('X'):
        return scores['X']
    elif isWinner('O'):
        return scores['O']
    elif isBoardFull():
        return scores['tie']
    if cur_player == 'X':
        bestScore = float('-inf')
        nextPlayer = 'O'
        minORmax = max
    else:
        bestScore = float('inf')
        nextPlayer = 'X'
        minORmax = min
    for row in range(3):
        for col in range(3):
            if board[row][col] == '':
                board[row][col] = cur_player
                score = minimax(board, nextPlayer)
                board[row][col] = ''
                bestScore = minORmax(score, bestScore)
            if bestScore == scores[cur_player]:
                return bestScore
    return bestScore


def updatePlayer(player):
    if player == 'X':
        newPlayer = 'O'
        previewImg = previewCircleImg
    else:
        newPlayer = 'X'
        previewImg = previewCrossImg
    return newPlayer, previewImg



def isWinner(player):
    return ((board[0][0] == player and board[0][1] == player and board[0][2] == player) or
            (board[1][0] == player and board[1][1] == player and board[1][2] == player) or
            (board[2][0] == player and board[2][1] == player and board[2][2] == player) or
            (board[0][0] == player and board[1][0] == player and board[2][0] == player) or
            (board[0][1] == player and board[1][1] == player and board[2][1] == player) or
            (board[0][2] == player and board[1][2] == player and board[2][2] == player) or
            (board[0][0] == player and board[1][1] == player and board[2][2] == player) or
            (board[0][2] == player and board[1][1] == player and board[2][0] == player))


def verifyWinner(player):
    global Send_Flag, Receive_Flag, Current_Player
    if isWinner(player):
        # dataSocket.close()
        # dataSocket, addr = listenSocket.accept()
        print(player, "win")
        # Send_Flag = 0
        # Receive_Flag = 0  ##一开始不发送也不接受，主机
        Current_Player = 'X'  # X先下棋
        score[player] += 1
        ctypes.windll.user32.MessageBoxW(0, player + ' 获胜！', '提示', 0)
        resetBoard()
        return True
    return False


def isBoardFull():
    for i in range(3):
        for j in range(3):
            if board[i][j] == '':
                return False
    return True


def resetBoard():
    for i in range(3):
        for j in range(3):
            board[i][j] = ''


def resetGame():
    resetBoard()
    score['X'] = 0
    score['O'] = 0
global i
i = 0
def TCP_Server():
    global send_row, send_col ,Send_Flag,row, col,Receive_Flag,i,Current_Player
    while True:
        # i = 0
        # time.sleep(1)
        # print("Server....Alive",i)
        # i +=1
        # 尝试读取对方发送的消息
        # BUFLEN 指定从接收缓冲里最多读取多少字节
        # recved = dataSocket.recv(BUFLEN)
        #
        # # 如果返回空bytes，表示对方关闭了连接
        # # 退出循环，结束消息收发
        # if not recved:
        #     break

        # 读取的字节数据是bytes类型，需要解码为字符串
        # info = recved.decode()
        # print(f'收到对方信息： {info}')
        #
        # # 发送的数据类型必须是bytes，所以要编码
        # dataSocket.send(f'服务端接收到了信息 '.encode())

        # 从终端读入用户输入的字符串
        # toSend = input('>>> ')
        # if toSend == 'exit':
        #     break
        # # 发送消息，也要编码为 bytes

        # recved = dataSocket.recv(BUFLEN)
        if Receive_Flag == 1:
            print("waiting for receiving...........")
            recved = dataSocket.recv(BUFLEN)
            if  not recved:
                break
            # 打印读取的信息
                print("receive,....",recved)
                print("not yet received.....")
            rec = recved.decode()
            print("receive ,", rec)
            if rec == "Over":
                Send_Flag = 0
                Receive_Flag = 0

                # break##用来退出阻塞
            else:
                Receive_Flag = 0
                print(recved.decode())
                print('rec......', rec)
                counter_row = int(rec[1])
                counter_col = int(rec[3])
                board[counter_row][counter_col] = "O"
                drawBoard()
                Current_Player = 'X'##收到对面信息后回到主场
                pygame.display.update()

        if Send_Flag == 1:
            # print()
            toSend = "r"+str(send_row)+"c"+str(send_col)
            print(" toSend ", toSend)
            dataSocket.send(toSend.encode())
            Send_Flag = 0
            time.sleep(0.5)

        # recved = dataSocket.recv(BUFLEN)
        # if  recved:
        # # 打印读取的信息
        #     print(recved.decode())
        #     rec=recved.decode()
        #     counter_row= int(rec[1])
        #     counter_col =int(rec[3])
        #     board[counter_row][counter_col] = "O"
        #     drawBoard()
        #     pygame.display.update()




    #
    # # 服务端也调用close()关闭socket
    # dataSocket.close()
    # listenSocket.close()

server_thread = threading.Thread(target = TCP_Server )
server_thread.start()
menu()
dataSocket.close()
listenSocket.close()
```

#### 客户端

```python
import pygame
import ctypes
#  === TCP 客户端程序 client.py ===
import time
from socket import *
import threading
IP = '127.0.0.1'
SERVER_PORT = 50000
BUFLEN = 1024

# 实例化一个socket对象，指明协议
dataSocket = socket(AF_INET, SOCK_STREAM)
global Send_Flag,Receive_Flag,current_player
Send_Flag = 0
Receive_Flag = 1
current_player = 'X'#服务端先下
# 连接服务端socket
dataSocket.connect((IP, SERVER_PORT))
# 初始化 pygame
pygame.init()

# 定义颜色
blue = (78, 140, 243)
light_blue = (100, 100, 255)
red = (242, 89, 97)
light_red = (255, 100, 100)
dark_grey = (85, 85, 85)
light_grey = (100, 100, 100)
background_color = (225, 225, 225)

# 创建窗口
screen = pygame.display.set_mode((600, 800))
pygame.display.set_caption('井字棋-客户端')

# 游戏图片
crossImg = pygame.image.load('Images/crossImg.png')
crossImg_rect = crossImg.get_rect()
crossImg_rect.center = (200, 300)
circleImg = pygame.image.load('Images/circleImg.png')
circleImg_rect = crossImg.get_rect()
circleImg_rect.center = (400, 300)
previewCrossImg = pygame.image.load('Images/prev_crossImg.png')
previewCircleImg = pygame.image.load('Images/prev_circleImg.png')

# 按钮图片
restartImg = pygame.image.load('Images/restart.png')
restartHoveredImg = pygame.image.load('Images/restart_hovered.png')

# 定义棋盘
board = [['', '', ''],
         ['', '', ''],
         ['', '', '']]

# 定义计分板
score = {'X': 0, 'O': 0}
font = pygame.font.Font('freesansbold.ttf', 32)
X_score = pygame.image.load('Images/X_scoreImg.png')
O_score = pygame.image.load('Images/O_scoreImg.png')

# 菜单图片
buttom1 = pygame.image.load('Images/button1Img.png')
buttom1_rect = buttom1.get_rect()
buttom1_rect.center = (300, 312)
buttom2 = pygame.image.load('Images/button2Img.png')
buttom2_rect = buttom2.get_rect()
buttom2_rect.center = (300, 472)
buttom3 = pygame.image.load('Images/button3Img.png')
buttom3_rect = buttom3.get_rect()
buttom3_rect.center = (300, 632)
logo = pygame.image.load('Images/logo.png')

# 选择菜单图片
chooseImg = pygame.image.load('Images/choose.png')


def menu():
    running = True
    while running:
        screen.fill(background_color)
        mx, my = pygame.mouse.get_pos()
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if buttom1_rect.collidepoint((mx, my)):
                    game(0, 'X')
                elif buttom2_rect.collidepoint((mx, my)):
                    player = choose()
                    if player is not None:
                        game(1, player)
                elif buttom3_rect.collidepoint((mx, my)):
                    game(2, 'O')
        screen.blit(logo, (8, 25))
        screen.blit(buttom1, (100, 250))
        screen.blit(buttom2, (100, 410))
        screen.blit(buttom3, (100, 570))
        pygame.display.update()


def game(gameMode, player):
    global send_row, send_col, Send_Flag, Receive_Flag,row, col,current_player
    my = player
    player = 'O'
    running = True
    previewImg = previewCrossImg
    while running:
        mouse = pygame.mouse.get_pos()
        row, col = int(mouse[0] / 200), int(mouse[1] / 200)
        for event in pygame.event.get():
            if verifyWinner('O'):
                player = 'O'
                previewImg = previewCrossImg
            if verifyWinner('X'):
                player = 'X'
                previewImg = previewCrossImg
            if event.type == pygame.QUIT:
                resetGame()
                running = False
            elif isBoardFull():
                ctypes.windll.user32.MessageBoxW(0, '平局', '提示', 0)
                resetBoard()
            elif gameMode == 1 and player != my:
                computerMove(player)
                drawBoard()
                pygame.display.update()
                if verifyWinner(player):
                    player = 'O'
                    previewImg = previewCrossImg
                else:
                    player, previewImg = updatePlayer(player)
            # elif gameMode == 2 and player != my:
            #     CounterMove(player)
            #     drawBoard()
            #     pygame.display.update()
            #     if verifyWinner(player):
            #         player = 'O'
            #         previewImg = previewCrossImg
            #     else:
            #         player, previewImg = updatePlayer(player)
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if gameMode != 2:
                    if row < 3 and col < 3 and board[row][col] == '':
                        send_row = row
                        send_col = col
                        playerMove(player, row, col)
                        drawBoard()
                        Send_Flag = 1
                        time.sleep(0.5)
                        if verifyWinner(player):
                            player = 'O'
                            previewImg = previewCrossImg
                        else :
                            player, previewImg = updatePlayer(player)
                    #
                    #     else:
                    #         Receive_Flag = 1
                    # elif 550 < mouse[0] < 582 and 610 < mouse[1] < 642:
                    #     resetGame()
                if gameMode == 2:
                    if row < 3 and col < 3 and board[row][col] == '' and current_player == 'O':#自己的回合鼠标才能点击
                        send_row = row
                        send_col = col
                        playerMove('O', row, col)
                        drawBoard()
                        current_player = 'X'#下完换对方
                        Send_Flag = 1
                        time.sleep(0.5)
                        Receive_Flag = 1
                        # if verifyWinner(player):
                        #     player = 'O'
                        #     previewImg = previewCrossImg
                        # elif gameMode != 2:
                        #
                    else:
                            Receive_Flag = 1
                if 550 < mouse[0] < 582 and 610 < mouse[1] < 642:
                        resetGame()
        screen.fill(background_color)
        drawBoard()
        drawBottomMenu(mouse)
        if row < 3 and col < 3:
            visualizeMove(row, col, previewImg)
        pygame.display.update()


def choose():
    player = None
    running = True
    while running:
        mouse = pygame.mouse.get_pos()
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if crossImg_rect.collidepoint((mouse[0], mouse[1])):
                    player = 'X'
                    running = False
                elif circleImg_rect.collidepoint((mouse[0], mouse[1])):
                    player = 'O'
                    running = False
        screen.blit(crossImg, (80, 300))
        screen.blit(circleImg, (340, 300))
        screen.blit(chooseImg, (8, 25))
        pygame.display.update()
    return player


def drawBoard():
    # 画棋子
    for row in range(3):
        for col in range(3):
            pos = (row * 200 + 12, col * 200 + 12)
            if board[row][col] == 'X':
                screen.blit(crossImg, pos)
            elif board[row][col] == 'O':
                screen.blit(circleImg, pos)
    # 画网格
    width = 10
    color = dark_grey
    pygame.draw.line(screen, color, (200, 0), (200, 600), width)
    pygame.draw.line(screen, color, (400, 0), (400, 600), width)
    pygame.draw.line(screen, color, (0, 200), (600, 200), width)
    pygame.draw.line(screen, color, (0, 400), (600, 400), width)
    # 画边框
    pygame.draw.rect(screen, color, (0, 0, 10, 600))
    pygame.draw.rect(screen, color, (0, 0, 600, 10))
    pygame.draw.rect(screen, color, (590, 0, 10, 600))


def drawBottomMenu(mouse):
    pygame.draw.rect(screen, dark_grey, (0, 600, 600, 100))
    pygame.draw.rect(screen, light_grey, (10, 610, 580, 80))
    screen.blit(restartImg, (550, 610))
    # Hover animation
    if 550 < mouse[0] < 582 and 610 < mouse[1] < 642:
        screen.blit(restartHoveredImg, (548, 608))
    screen.blit(X_score, (200, 610))
    screen.blit(O_score, (370, 610))
    scoreboard = font.render(': %d x %d :' % (score['X'], score['O']), True, background_color, light_grey)
    screen.blit(scoreboard, (244, 610))


def visualizeMove(row, col, previewImg):
    if board[row][col] == '':
        screen.blit(previewImg, (row * 200 + 12, col * 200 + 12))


def playerMove(player, row, col):
    board[row][col] = player


def computerMove(player):
    bestScore = float('inf')
    for row in range(3):
        for col in range(3):
            if board[row][col] == '':
                board[row][col] = 'O'
                score = minimax(board, 'X')
                board[row][col] = ''
                if score < bestScore:
                    bestScore = score
                    bestMove = (row, col)
    board[bestMove[0]][bestMove[1]] = player


scores = {'X': 1, 'O': -1, 'tie': 0}


def minimax(board, cur_player):
    if isWinner('X'):
        return scores['X']
    elif isWinner('O'):
        return scores['O']
    elif isBoardFull():
        return scores['tie']
    if cur_player == 'X':
        bestScore = float('-inf')
        nextPlayer = 'O'
        minORmax = max
    else:
        bestScore = float('inf')
        nextPlayer = 'X'
        minORmax = min
    for row in range(3):
        for col in range(3):
            if board[row][col] == '':
                board[row][col] = cur_player
                score = minimax(board, nextPlayer)
                board[row][col] = ''
                bestScore = minORmax(score, bestScore)
            if bestScore == scores[cur_player]:
                return bestScore
    return bestScore


def updatePlayer(player):
    if player == 'X':
        newPlayer = 'O'
        previewImg = previewCircleImg
    else:
        newPlayer = 'X'
        previewImg = previewCrossImg
    return newPlayer, previewImg



def isWinner(player):
    return ((board[0][0] == player and board[0][1] == player and board[0][2] == player) or
            (board[1][0] == player and board[1][1] == player and board[1][2] == player) or
            (board[2][0] == player and board[2][1] == player and board[2][2] == player) or
            (board[0][0] == player and board[1][0] == player and board[2][0] == player) or
            (board[0][1] == player and board[1][1] == player and board[2][1] == player) or
            (board[0][2] == player and board[1][2] == player and board[2][2] == player) or
            (board[0][0] == player and board[1][1] == player and board[2][2] == player) or
            (board[0][2] == player and board[1][1] == player and board[2][0] == player))


def verifyWinner(player):
    global  Send_Flag,Receive_Flag,current_player,dataSocket
    if isWinner(player):
        print(player, "win")
        if player == 'X':
            toSend = 'Over'
            dataSocket.send(toSend.encode())
            print("send_meseage:",toSend)
        Send_Flag = 0
        Receive_Flag = 1
        current_player = 'X'  # 服务端先下
        score[player] += 1
        ctypes.windll.user32.MessageBoxW(0, player + ' 获胜！', '提示', 0)
        resetBoard()
        return True
    return False


def isBoardFull():
    for i in range(3):
        for j in range(3):
            if board[i][j] == '':
                return False
    return True


def resetBoard():
    for i in range(3):
        for j in range(3):
            board[i][j] = ''


def resetGame():
    resetBoard()
    score['X'] = 0
    score['O'] = 0
global i
i = 0
def TCP_Client():
    global send_row, send_col ,Send_Flag,row, col,Receive_Flag, i, current_player
    while True:
        # i = 0
        # time.sleep(1)
        # print("Receive_Flag",Receive_Flag)
        # print()
        # print("Client....Alive",i)
        # i += 1
        # 从终端读入用户输入的字符串
        # toSend = input('>>> ')
        # if toSend == 'exit':
        #     break
        # # 发送消息，也要编码为 bytes
        # dataSocket.send(toSend.encode())

        # 等待接收服务端的消息
        if Send_Flag == 1:
            toSend = "r"+str(send_row)+"c"+str(send_col)
            print(" toSend ", toSend)
            dataSocket.send(toSend.encode())
            Send_Flag = 0
            time.sleep(0.5)

        # recved = dataSocket.recv(BUFLEN)
        # 如果返回空bytes，表示对方关闭了连接
        if Receive_Flag == 1:
            print("waiting for receiving...........")
            recved = dataSocket.recv(BUFLEN)

            if  not recved:
                print("not yet received.....")
            # 打印读取的信息
                break
            print("receive,....", recved)
            current_player = 'O'#接受到数据后回到主场
            Receive_Flag = 0
            print(recved.decode())
            rec = recved.decode()
            counter_row = int(rec[1])
            counter_col = int(rec[3])
            board[counter_row][counter_col] = "X"
            drawBoard()
            pygame.display.update()
            # print("receive",Receive_Flag)
            # print("send",Send_Flag)





client_thread = threading.Thread(target=TCP_Client)
client_thread.start()

menu()
dataSoc
```

### 修复预览画面

#### 服务端

```python
import pygame
import ctypes
# 导入socket 库
from socket import *
import threading
import time

# 主机地址为空字符串，表示绑定本机所有网络接口ip地址
# 等待客户端来连接
IP = ''
# 端口号
PORT = 50000
# 定义一次从socket缓冲区最多读入512个字节数据
BUFLEN = 512

# 实例化一个socket对象
# 参数 AF_INET 表示该socket网络层使用IP协议
# 参数 SOCK_STREAM 表示该socket传输层使用TCP协议
listenSocket = socket(AF_INET, SOCK_STREAM)

# socket绑定地址和端口
listenSocket.bind((IP, PORT))


# 使socket处于监听状态，等待客户端的连接请求
# 参数 8 表示 最多接受多少个等待连接的客户端
listenSocket.listen(8)
print(f'服务端启动成功，在{PORT}端口等待客户端连接...')

dataSocket, addr = listenSocket.accept()
print('接受一个客户端连接:', addr)


global Send_Flag,Receive_Flag,Current_Player,If_over,previewImg
# 初始化 pygame
pygame.init()

# 定义颜色
blue = (78, 140, 243)
light_blue = (100, 100, 255)
red = (242, 89, 97)
light_red = (255, 100, 100)
dark_grey = (85, 85, 85)
light_grey = (100, 100, 100)
background_color = (225, 225, 225)
Send_Flag = 0
Receive_Flag = 0##一开始不发送也不接受，主机
Current_Player = 'X'#X先下棋
If_over = 0

# 创建窗口
screen = pygame.display.set_mode((600, 800))
pygame.display.set_caption('井字棋')

# 游戏图片
crossImg = pygame.image.load('Images/crossImg.png')
crossImg_rect = crossImg.get_rect()
crossImg_rect.center = (200, 300)
circleImg = pygame.image.load('Images/circleImg.png')
circleImg_rect = crossImg.get_rect()
circleImg_rect.center = (400, 300)
previewCrossImg = pygame.image.load('Images/prev_crossImg.png')
previewCircleImg = pygame.image.load('Images/prev_circleImg.png')

previewImg = previewCrossImg
# 按钮图片
restartImg = pygame.image.load('Images/restart.png')
restartHoveredImg = pygame.image.load('Images/restart_hovered.png')

# 定义棋盘
board = [['', '', ''],
         ['', '', ''],
         ['', '', '']]

# 定义计分板
score = {'X': 0, 'O': 0}
font = pygame.font.Font('freesansbold.ttf', 32)
X_score = pygame.image.load('Images/X_scoreImg.png')
O_score = pygame.image.load('Images/O_scoreImg.png')

# 菜单图片
buttom1 = pygame.image.load('Images/button1Img.png')
buttom1_rect = buttom1.get_rect()
buttom1_rect.center = (300, 312)
buttom2 = pygame.image.load('Images/button2Img.png')
buttom2_rect = buttom2.get_rect()
buttom2_rect.center = (300, 472)

buttom3 = pygame.image.load('Images/button3Img.png')
buttom3_rect = buttom3.get_rect()
buttom3_rect.center = (300, 632)

logo = pygame.image.load('Images/logo.png')

# 选择菜单图片
chooseImg = pygame.image.load('Images/choose.png')


def menu():
    running = True
    while running:
        screen.fill(background_color)
        mx, my = pygame.mouse.get_pos()
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if buttom1_rect.collidepoint((mx, my)):
                    game(0, 'X')
                elif buttom2_rect.collidepoint((mx, my)):
                    player = choose()
                    if player is not None:
                        game(1, player)
                elif buttom3_rect.collidepoint((mx, my)):
                    game(2, 'X')
        screen.blit(logo, (8, 25))
        screen.blit(buttom1, (100, 250))
        screen.blit(buttom2, (100, 410))
        screen.blit(buttom3, (100, 570))
        pygame.display.update()


def game(gameMode, player):
    global send_row, send_col ,Send_Flag,row, col,Receive_Flag,Current_Player,If_over,previewImg
    my = player
    player = 'X'
    running = True
    while running:
        mouse = pygame.mouse.get_pos()
        row, col = int(mouse[0] / 200), int(mouse[1] / 200)
        for event in pygame.event.get():
            if verifyWinner('X'):
                player = 'X'
                previewImg = previewCrossImg
            if verifyWinner('O'):
                player = 'O'
                previewImg = previewCrossImg
            if event.type == pygame.QUIT:
                resetGame()
                running = False
            elif isBoardFull():
                ctypes.windll.user32.MessageBoxW(0, '平局', '提示', 0)
                resetBoard()
            elif gameMode == 1 and player != my:
                computerMove(player)
                drawBoard()
                pygame.display.update()
                if verifyWinner(player):
                    player = 'X'
                    previewImg = previewCrossImg
                else:
                    player, previewImg = updatePlayer(player)
            # elif gameMode == 2 and player != my:
            #
            #     # CounterMove(counter_row, counter_col)
            #     drawBoard()
            #     pygame.display.update()
                if verifyWinner(player):
                    player = 'X'
                    previewImg = previewCrossImg
                else:
                    player, previewImg = updatePlayer(player)
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if gameMode != 2:
                    if row < 3 and col < 3 and board[row][col] == '':
                        # send_row = row
                        # send_col = col
                        playerMove(player, row, col)
                        drawBoard()
                        Send_Flag = 1
                        time.sleep(0.5)
                        if verifyWinner('X'):
                            player = 'X'
                            previewImg = previewCrossImg
                        else :
                            player, previewImg = updatePlayer(player)
                    #
                    #     else:
                    #         Receive_Flag = 1
                    # elif 550 < mouse[0] < 582 and 610 < mouse[1] < 642:
                    #     resetGame()
                if gameMode == 2:
                    if row < 3 and col < 3 and board[row][col] == '' and Current_Player == 'X':#自己的回合鼠标才能点击
                        send_row = row
                        send_col = col
                        playerMove('X', row, col)
                        drawBoard()
                        Current_Player = 'O'#下完换对方
                        previewImg = previewCircleImg
                        Send_Flag = 1
                        time.sleep(0.5)
                        Receive_Flag = 1
                        # if verifyWinner(player):
                        #     player = 'O'
                        #     previewImg = previewCrossImg
                        # elif gameMode != 2:
                        #
                    else:
                            Receive_Flag = 1
                if 550 < mouse[0] < 582 and 610 < mouse[1] < 642:
                        resetGame()


        screen.fill(background_color)
        drawBoard()
        drawBottomMenu(mouse)
        if row < 3 and col < 3:
            visualizeMove(row, col, previewImg)
        pygame.display.update()


def choose():
    player = None
    running = True
    while running:
        mouse = pygame.mouse.get_pos()
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if crossImg_rect.collidepoint((mouse[0], mouse[1])):
                    player = 'X'
                    running = False
                elif circleImg_rect.collidepoint((mouse[0], mouse[1])):
                    player = 'O'
                    running = False
        screen.blit(crossImg, (80, 300))
        screen.blit(circleImg, (340, 300))
        screen.blit(chooseImg, (8, 25))
        pygame.display.update()
    return player


def drawBoard():
    # 画棋子
    for row in range(3):
        for col in range(3):
            pos = (row * 200 + 12, col * 200 + 12)
            if board[row][col] == 'X':
                screen.blit(crossImg, pos)
            elif board[row][col] == 'O':
                screen.blit(circleImg, pos)
    # 画网格
    width = 10
    color = dark_grey
    pygame.draw.line(screen, color, (200, 0), (200, 600), width)
    pygame.draw.line(screen, color, (400, 0), (400, 600), width)
    pygame.draw.line(screen, color, (0, 200), (600, 200), width)
    pygame.draw.line(screen, color, (0, 400), (600, 400), width)
    # 画边框
    pygame.draw.rect(screen, color, (0, 0, 10, 600))
    pygame.draw.rect(screen, color, (0, 0, 600, 10))
    pygame.draw.rect(screen, color, (590, 0, 10, 600))


def drawBottomMenu(mouse):
    pygame.draw.rect(screen, dark_grey, (0, 600, 600, 100))
    pygame.draw.rect(screen, light_grey, (10, 610, 580, 80))
    screen.blit(restartImg, (550, 610))
    # Hover animation
    if 550 < mouse[0] < 582 and 610 < mouse[1] < 642:
        screen.blit(restartHoveredImg, (548, 608))
    screen.blit(X_score, (200, 610))
    screen.blit(O_score, (370, 610))
    scoreboard = font.render(': %d x %d :' % (score['X'], score['O']), True, background_color, light_grey)
    screen.blit(scoreboard, (244, 610))


def visualizeMove(row, col, previewImg):
    if board[row][col] == '':
        screen.blit(previewImg, (row * 200 + 12, col * 200 + 12))


def playerMove(player, row, col):
    board[row][col] = player

def CounterMove(row, col):
    board[row][col] = "O"


def computerMove(player):
    bestScore = float('inf')
    for row in range(3):
        for col in range(3):
            if board[row][col] == '':
                board[row][col] = 'O'
                score = minimax(board, 'X')
                board[row][col] = ''
                if score < bestScore:
                    bestScore = score
                    bestMove = (row, col)
    board[bestMove[0]][bestMove[1]] = player


scores = {'X': 1, 'O': -1, 'tie': 0}


def minimax(board, cur_player):
    if isWinner('X'):
        return scores['X']
    elif isWinner('O'):
        return scores['O']
    elif isBoardFull():
        return scores['tie']
    if cur_player == 'X':
        bestScore = float('-inf')
        nextPlayer = 'O'
        minORmax = max
    else:
        bestScore = float('inf')
        nextPlayer = 'X'
        minORmax = min
    for row in range(3):
        for col in range(3):
            if board[row][col] == '':
                board[row][col] = cur_player
                score = minimax(board, nextPlayer)
                board[row][col] = ''
                bestScore = minORmax(score, bestScore)
            if bestScore == scores[cur_player]:
                return bestScore
    return bestScore


def updatePlayer(player):
    if player == 'X':
        newPlayer = 'O'
        previewImg = previewCircleImg
    else:
        newPlayer = 'X'
        previewImg = previewCrossImg
    return newPlayer, previewImg



def isWinner(player):
    return ((board[0][0] == player and board[0][1] == player and board[0][2] == player) or
            (board[1][0] == player and board[1][1] == player and board[1][2] == player) or
            (board[2][0] == player and board[2][1] == player and board[2][2] == player) or
            (board[0][0] == player and board[1][0] == player and board[2][0] == player) or
            (board[0][1] == player and board[1][1] == player and board[2][1] == player) or
            (board[0][2] == player and board[1][2] == player and board[2][2] == player) or
            (board[0][0] == player and board[1][1] == player and board[2][2] == player) or
            (board[0][2] == player and board[1][1] == player and board[2][0] == player))


def verifyWinner(player):
    global Send_Flag, Receive_Flag, Current_Player
    if isWinner(player):
        # dataSocket.close()
        # dataSocket, addr = listenSocket.accept()
        print(player, "win")
        # Send_Flag = 0
        # Receive_Flag = 0  ##一开始不发送也不接受，主机
        Current_Player = 'X'  # X先下棋
        score[player] += 1
        ctypes.windll.user32.MessageBoxW(0, player + ' 获胜！', '提示', 0)
        resetBoard()
        return True
    return False


def isBoardFull():
    for i in range(3):
        for j in range(3):
            if board[i][j] == '':
                return False
    return True


def resetBoard():
    for i in range(3):
        for j in range(3):
            board[i][j] = ''


def resetGame():
    resetBoard()
    score['X'] = 0
    score['O'] = 0
global i
i = 0
def TCP_Server():
    global send_row, send_col ,Send_Flag,row, col,Receive_Flag,i,Current_Player,previewImg
    while True:
        # i = 0
        # time.sleep(1)
        # print("Server....Alive",i)
        # i +=1
        # 尝试读取对方发送的消息
        # BUFLEN 指定从接收缓冲里最多读取多少字节
        # recved = dataSocket.recv(BUFLEN)
        #
        # # 如果返回空bytes，表示对方关闭了连接
        # # 退出循环，结束消息收发
        # if not recved:
        #     break

        # 读取的字节数据是bytes类型，需要解码为字符串
        # info = recved.decode()
        # print(f'收到对方信息： {info}')
        #
        # # 发送的数据类型必须是bytes，所以要编码
        # dataSocket.send(f'服务端接收到了信息 '.encode())

        # 从终端读入用户输入的字符串
        # toSend = input('>>> ')
        # if toSend == 'exit':
        #     break
        # # 发送消息，也要编码为 bytes

        # recved = dataSocket.recv(BUFLEN)
        if Receive_Flag == 1:
            print("waiting for receiving...........")
            recved = dataSocket.recv(BUFLEN)
            if  not recved:
                break
            # 打印读取的信息
                print("receive,....",recved)
                print("not yet received.....")
            rec = recved.decode()
            print("receive ,", rec)
            if rec == "Over":
                Send_Flag = 0
                Receive_Flag = 0

                # break##用来退出阻塞
            else:
                Receive_Flag = 0
                previewImg = previewCrossImg
                print(recved.decode())
                print('rec......', rec)
                counter_row = int(rec[1])
                counter_col = int(rec[3])
                board[counter_row][counter_col] = "O"
                drawBoard()
                Current_Player = 'X'##收到对面信息后回到主场
                pygame.display.update()

        if Send_Flag == 1:
            # print()
            toSend = "r"+str(send_row)+"c"+str(send_col)
            print(" toSend ", toSend)
            dataSocket.send(toSend.encode())
            Send_Flag = 0
            time.sleep(0.5)

        # recved = dataSocket.recv(BUFLEN)
        # if  recved:
        # # 打印读取的信息
        #     print(recved.decode())
        #     rec=recved.decode()
        #     counter_row= int(rec[1])
        #     counter_col =int(rec[3])
        #     board[counter_row][counter_col] = "O"
        #     drawBoard()
        #     pygame.display.update()




    #
    # # 服务端也调用close()关闭socket
    # dataSocket.close()
    # listenSocket.close()

server_thread = threading.Thread(target = TCP_Server )
server_thread.start()
menu()
dataSocket.close()
listenSocket.close()
```

#### 客户端

```python
import pygame
import ctypes
#  === TCP 客户端程序 client.py ===
import time
from socket import *
import threading
IP = '127.0.0.1'
SERVER_PORT = 50000
BUFLEN = 1024

# 实例化一个socket对象，指明协议
dataSocket = socket(AF_INET, SOCK_STREAM)
global Send_Flag,Receive_Flag,current_player,previewImg,gameMode
Send_Flag = 0
Receive_Flag = 1
current_player = 'X'#服务端先下
gameMode = 0
# 连接服务端socket
dataSocket.connect((IP, SERVER_PORT))
# 初始化 pygame
pygame.init()

# 定义颜色
blue = (78, 140, 243)
light_blue = (100, 100, 255)
red = (242, 89, 97)
light_red = (255, 100, 100)
dark_grey = (85, 85, 85)
light_grey = (100, 100, 100)
background_color = (225, 225, 225)

# 创建窗口
screen = pygame.display.set_mode((600, 800))
pygame.display.set_caption('井字棋-客户端')

# 游戏图片
crossImg = pygame.image.load('Images/crossImg.png')
crossImg_rect = crossImg.get_rect()
crossImg_rect.center = (200, 300)
circleImg = pygame.image.load('Images/circleImg.png')
circleImg_rect = crossImg.get_rect()
circleImg_rect.center = (400, 300)
previewCrossImg = pygame.image.load('Images/prev_crossImg.png')
previewCircleImg = pygame.image.load('Images/prev_circleImg.png')
previewImg = previewCrossImg
# 按钮图片
restartImg = pygame.image.load('Images/restart.png')
restartHoveredImg = pygame.image.load('Images/restart_hovered.png')

# 定义棋盘
board = [['', '', ''],
         ['', '', ''],
         ['', '', '']]

# 定义计分板
score = {'X': 0, 'O': 0}
font = pygame.font.Font('freesansbold.ttf', 32)
X_score = pygame.image.load('Images/X_scoreImg.png')
O_score = pygame.image.load('Images/O_scoreImg.png')

# 菜单图片
buttom1 = pygame.image.load('Images/button1Img.png')
buttom1_rect = buttom1.get_rect()
buttom1_rect.center = (300, 312)
buttom2 = pygame.image.load('Images/button2Img.png')
buttom2_rect = buttom2.get_rect()
buttom2_rect.center = (300, 472)
buttom3 = pygame.image.load('Images/button3Img.png')
buttom3_rect = buttom3.get_rect()
buttom3_rect.center = (300, 632)
logo = pygame.image.load('Images/logo.png')

# 选择菜单图片
chooseImg = pygame.image.load('Images/choose.png')


def menu():
    global gameMode
    running = True
    while running:
        screen.fill(background_color)
        mx, my = pygame.mouse.get_pos()
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if buttom1_rect.collidepoint((mx, my)):
                    gameMode= 0
                    game(0, 'X')
                elif buttom2_rect.collidepoint((mx, my)):
                    player = choose()
                    if player is not None:
                        gameMode= 1
                        game(1, player)
                elif buttom3_rect.collidepoint((mx, my)):
                    gameMode = 2
                    game(2, 'O')
        screen.blit(logo, (8, 25))
        screen.blit(buttom1, (100, 250))
        screen.blit(buttom2, (100, 410))
        screen.blit(buttom3, (100, 570))
        pygame.display.update()


def game(gameMode, player):
    global send_row, send_col, Send_Flag, Receive_Flag,row, col,current_player,previewImg
    my = player
    # player = current_player
    running = True
    if gameMode == 2:
        previewImg = previewCrossImg  # 服务端先下
    else:
        previewImg = previewCircleImg

    while running:
        mouse = pygame.mouse.get_pos()
        row, col = int(mouse[0] / 200), int(mouse[1] / 200)
        for event in pygame.event.get():
            if verifyWinner('O'):
                # player = 'O'
                # previewImg = previewCrossImg
                 pass
            if verifyWinner('X'):
                # player = 'X'
                # previewImg = previewCrossImg
                pass
            if event.type == pygame.QUIT:
                resetGame()
                running = False
            elif isBoardFull():
                ctypes.windll.user32.MessageBoxW(0, '平局', '提示', 0)
                resetBoard()
            elif gameMode == 1 and player != my:
                computerMove(player)
                drawBoard()
                pygame.display.update()
                if verifyWinner(player):
                    player = 'O'
                    previewImg = previewCrossImg
                else:
                    player, previewImg = updatePlayer(player)
            # elif gameMode == 2 and player != my:
            #     CounterMove(player)
            #     drawBoard()
            #     pygame.display.update()
            #     if verifyWinner(player):
            #         player = 'O'
            #         previewImg = previewCrossImg
            #     else:
            #         player, previewImg = updatePlayer(player)
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if gameMode != 2:
                    if row < 3 and col < 3 and board[row][col] == '':
                        send_row = row
                        send_col = col
                        playerMove(player, row, col)
                        drawBoard()
                        Send_Flag = 1
                        time.sleep(0.5)
                        if verifyWinner(player):
                            player = 'O'
                            previewImg = previewCrossImg
                        else :
                            player, previewImg = updatePlayer(player)
                    #
                    #     else:
                    #         Receive_Flag = 1
                    # elif 550 < mouse[0] < 582 and 610 < mouse[1] < 642:
                    #     resetGame()
                if gameMode == 2:
                    if row < 3 and col < 3 and board[row][col] == '' and current_player == 'O':#自己的回合鼠标才能点击
                        send_row = row
                        send_col = col
                        playerMove('O', row, col)
                        drawBoard()
                        current_player = 'X'#下完换对方
                        previewImg = previewCrossImg
                        Send_Flag = 1
                        time.sleep(0.5)
                        Receive_Flag = 1
                        # if verifyWinner(player):
                        #     player = 'O'
                        #     previewImg = previewCrossImg
                        # elif gameMode != 2:
                        #
                    else:
                            Receive_Flag = 1
                if 550 < mouse[0] < 582 and 610 < mouse[1] < 642:
                        resetGame()
        screen.fill(background_color)
        drawBoard()
        drawBottomMenu(mouse)
        if row < 3 and col < 3:
            visualizeMove(row, col, previewImg)
        pygame.display.update()


def choose():
    player = None
    running = True
    while running:
        mouse = pygame.mouse.get_pos()
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if crossImg_rect.collidepoint((mouse[0], mouse[1])):
                    player = 'X'
                    running = False
                elif circleImg_rect.collidepoint((mouse[0], mouse[1])):
                    player = 'O'
                    running = False
        screen.blit(crossImg, (80, 300))
        screen.blit(circleImg, (340, 300))
        screen.blit(chooseImg, (8, 25))
        pygame.display.update()
    return player


def drawBoard():
    # 画棋子
    for row in range(3):
        for col in range(3):
            pos = (row * 200 + 12, col * 200 + 12)
            if board[row][col] == 'X':
                screen.blit(crossImg, pos)
            elif board[row][col] == 'O':
                screen.blit(circleImg, pos)
    # 画网格
    width = 10
    color = dark_grey
    pygame.draw.line(screen, color, (200, 0), (200, 600), width)
    pygame.draw.line(screen, color, (400, 0), (400, 600), width)
    pygame.draw.line(screen, color, (0, 200), (600, 200), width)
    pygame.draw.line(screen, color, (0, 400), (600, 400), width)
    # 画边框
    pygame.draw.rect(screen, color, (0, 0, 10, 600))
    pygame.draw.rect(screen, color, (0, 0, 600, 10))
    pygame.draw.rect(screen, color, (590, 0, 10, 600))


def drawBottomMenu(mouse):
    pygame.draw.rect(screen, dark_grey, (0, 600, 600, 100))
    pygame.draw.rect(screen, light_grey, (10, 610, 580, 80))
    screen.blit(restartImg, (550, 610))
    # Hover animation
    if 550 < mouse[0] < 582 and 610 < mouse[1] < 642:
        screen.blit(restartHoveredImg, (548, 608))
    screen.blit(X_score, (200, 610))
    screen.blit(O_score, (370, 610))
    scoreboard = font.render(': %d x %d :' % (score['X'], score['O']), True, background_color, light_grey)
    screen.blit(scoreboard, (244, 610))


def visualizeMove(row, col, previewImg):
    if board[row][col] == '':
        screen.blit(previewImg, (row * 200 + 12, col * 200 + 12))


def playerMove(player, row, col):
    board[row][col] = player


def computerMove(player):
    bestScore = float('inf')
    for row in range(3):
        for col in range(3):
            if board[row][col] == '':
                board[row][col] = 'O'
                score = minimax(board, 'X')
                board[row][col] = ''
                if score < bestScore:
                    bestScore = score
                    bestMove = (row, col)
    board[bestMove[0]][bestMove[1]] = player


scores = {'X': 1, 'O': -1, 'tie': 0}


def minimax(board, cur_player):
    if isWinner('X'):
        return scores['X']
    elif isWinner('O'):
        return scores['O']
    elif isBoardFull():
        return scores['tie']
    if cur_player == 'X':
        bestScore = float('-inf')
        nextPlayer = 'O'
        minORmax = max
    else:
        bestScore = float('inf')
        nextPlayer = 'X'
        minORmax = min
    for row in range(3):
        for col in range(3):
            if board[row][col] == '':
                board[row][col] = cur_player
                score = minimax(board, nextPlayer)
                board[row][col] = ''
                bestScore = minORmax(score, bestScore)
            if bestScore == scores[cur_player]:
                return bestScore
    return bestScore


def updatePlayer(player):
    if player == 'X':
        newPlayer = 'O'
        previewImg = previewCircleImg
    else:
        newPlayer = 'X'
        previewImg = previewCrossImg
    return newPlayer, previewImg



def isWinner(player):
    return ((board[0][0] == player and board[0][1] == player and board[0][2] == player) or
            (board[1][0] == player and board[1][1] == player and board[1][2] == player) or
            (board[2][0] == player and board[2][1] == player and board[2][2] == player) or
            (board[0][0] == player and board[1][0] == player and board[2][0] == player) or
            (board[0][1] == player and board[1][1] == player and board[2][1] == player) or
            (board[0][2] == player and board[1][2] == player and board[2][2] == player) or
            (board[0][0] == player and board[1][1] == player and board[2][2] == player) or
            (board[0][2] == player and board[1][1] == player and board[2][0] == player))


def verifyWinner(player):
    global  Send_Flag,Receive_Flag,current_player,dataSocket,previewImg,gameMode
    if isWinner(player):
        print(player, "win")
        if player == 'X':
            toSend = 'Over'
            dataSocket.send(toSend.encode())
            print("send_meseage:",toSend)
        Send_Flag = 0
        Receive_Flag = 1
        if gameMode ==2:
            previewImg = previewCrossImg
        current_player = 'X'  # 服务端先下
        score[player] += 1
        ctypes.windll.user32.MessageBoxW(0, player + ' 获胜！', '提示', 0)
        resetBoard()
        return True
    return False


def isBoardFull():
    for i in range(3):
        for j in range(3):
            if board[i][j] == '':
                return False
    return True


def resetBoard():
    for i in range(3):
        for j in range(3):
            board[i][j] = ''


def resetGame():
    resetBoard()
    score['X'] = 0
    score['O'] = 0
global i
i = 0
def TCP_Client():
    global send_row, send_col ,Send_Flag,row, col,Receive_Flag, i, current_player, previewImg
    while True:
        # i = 0
        # time.sleep(1)
        # print("Receive_Flag",Receive_Flag)
        # print()
        # print("Client....Alive",i)
        # i += 1
        # 从终端读入用户输入的字符串
        # toSend = input('>>> ')
        # if toSend == 'exit':
        #     break
        # # 发送消息，也要编码为 bytes
        # dataSocket.send(toSend.encode())

        # 等待接收服务端的消息
        if Send_Flag == 1:
            toSend = "r"+str(send_row)+"c"+str(send_col)
            print(" toSend ", toSend)
            dataSocket.send(toSend.encode())
            Send_Flag = 0
            time.sleep(0.5)

        # recved = dataSocket.recv(BUFLEN)
        # 如果返回空bytes，表示对方关闭了连接
        if Receive_Flag == 1:
            print("waiting for receiving...........")
            recved = dataSocket.recv(BUFLEN)

            if  not recved:
                print("not yet received.....")
            # 打印读取的信息
                break
            print("receive,....", recved)
            current_player = 'O'#接受到数据后回到主场
            Receive_Flag = 0
            previewImg = previewCircleImg
            print(recved.decode())
            rec = recved.decode()
            counter_row = int(rec[1])
            counter_col = int(rec[3])
            board[counter_row][counter_col] = "X"
            drawBoard()
            pygame.display.update()
            # print("receive",Receive_Flag)
            # print("send",Send_Flag)





client_thread = threading.Thread(target=TCP_Client)
client_thread.start()

menu()
dataSoc
```

### O、X获胜都能继续

#### 服务端

```python
import pygame
import ctypes
# 导入socket 库
from socket import *
import threading
import time

# 主机地址为空字符串，表示绑定本机所有网络接口ip地址
# 等待客户端来连接
IP = ''
# 端口号
PORT = 50000
# 定义一次从socket缓冲区最多读入512个字节数据
BUFLEN = 512

# 实例化一个socket对象
# 参数 AF_INET 表示该socket网络层使用IP协议
# 参数 SOCK_STREAM 表示该socket传输层使用TCP协议
listenSocket = socket(AF_INET, SOCK_STREAM)

# socket绑定地址和端口
listenSocket.bind((IP, PORT))


# 使socket处于监听状态，等待客户端的连接请求
# 参数 8 表示 最多接受多少个等待连接的客户端
listenSocket.listen(8)
print(f'服务端启动成功，在{PORT}端口等待客户端连接...')

dataSocket, addr = listenSocket.accept()
print('接受一个客户端连接:', addr)


global Send_Flag,Receive_Flag,Current_Player,If_over,previewImg
# 初始化 pygame
pygame.init()

# 定义颜色
blue = (78, 140, 243)
light_blue = (100, 100, 255)
red = (242, 89, 97)
light_red = (255, 100, 100)
dark_grey = (85, 85, 85)
light_grey = (100, 100, 100)
background_color = (225, 225, 225)
Send_Flag = 0
Receive_Flag = 0##一开始不发送也不接受，主机
Current_Player = 'X'#X先下棋
If_over = 0

# 创建窗口
screen = pygame.display.set_mode((600, 800))
pygame.display.set_caption('井字棋')

# 游戏图片
crossImg = pygame.image.load('Images/crossImg.png')
crossImg_rect = crossImg.get_rect()
crossImg_rect.center = (200, 300)
circleImg = pygame.image.load('Images/circleImg.png')
circleImg_rect = crossImg.get_rect()
circleImg_rect.center = (400, 300)
previewCrossImg = pygame.image.load('Images/prev_crossImg.png')
previewCircleImg = pygame.image.load('Images/prev_circleImg.png')

previewImg = previewCrossImg
# 按钮图片
restartImg = pygame.image.load('Images/restart.png')
restartHoveredImg = pygame.image.load('Images/restart_hovered.png')

# 定义棋盘
board = [['', '', ''],
         ['', '', ''],
         ['', '', '']]

# 定义计分板
score = {'X': 0, 'O': 0}
font = pygame.font.Font('freesansbold.ttf', 32)
X_score = pygame.image.load('Images/X_scoreImg.png')
O_score = pygame.image.load('Images/O_scoreImg.png')

# 菜单图片
buttom1 = pygame.image.load('Images/button1Img.png')
buttom1_rect = buttom1.get_rect()
buttom1_rect.center = (300, 312)
buttom2 = pygame.image.load('Images/button2Img.png')
buttom2_rect = buttom2.get_rect()
buttom2_rect.center = (300, 472)

buttom3 = pygame.image.load('Images/button3Img.png')
buttom3_rect = buttom3.get_rect()
buttom3_rect.center = (300, 632)

logo = pygame.image.load('Images/logo.png')

# 选择菜单图片
chooseImg = pygame.image.load('Images/choose.png')


def menu():
    running = True
    while running:
        screen.fill(background_color)
        mx, my = pygame.mouse.get_pos()
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if buttom1_rect.collidepoint((mx, my)):
                    game(0, 'X')
                elif buttom2_rect.collidepoint((mx, my)):
                    player = choose()
                    if player is not None:
                        game(1, player)
                elif buttom3_rect.collidepoint((mx, my)):
                    game(2, 'X')
        screen.blit(logo, (8, 25))
        screen.blit(buttom1, (100, 250))
        screen.blit(buttom2, (100, 410))
        screen.blit(buttom3, (100, 570))
        pygame.display.update()


def game(gameMode, player):
    global send_row, send_col ,Send_Flag,row, col,Receive_Flag,Current_Player,If_over,previewImg
    my = player
    player = 'X'
    running = True
    while running:
        mouse = pygame.mouse.get_pos()
        row, col = int(mouse[0] / 200), int(mouse[1] / 200)
        for event in pygame.event.get():
            if verifyWinner('X'):
                player = 'X'
                previewImg = previewCrossImg
            if verifyWinner('O'):
                player = 'O'
                previewImg = previewCrossImg
            if event.type == pygame.QUIT:
                resetGame()
                running = False
            elif isBoardFull():
                ctypes.windll.user32.MessageBoxW(0, '平局', '提示', 0)
                resetBoard()
            elif gameMode == 1 and player != my:
                computerMove(player)
                drawBoard()
                pygame.display.update()
                if verifyWinner(player):
                    player = 'X'
                    previewImg = previewCrossImg
                else:
                    player, previewImg = updatePlayer(player)
            # elif gameMode == 2 and player != my:
            #
            #     # CounterMove(counter_row, counter_col)
            #     drawBoard()
            #     pygame.display.update()
                if verifyWinner(player):
                    player = 'X'
                    previewImg = previewCrossImg
                else:
                    player, previewImg = updatePlayer(player)
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if gameMode != 2:
                    if row < 3 and col < 3 and board[row][col] == '':
                        # send_row = row
                        # send_col = col
                        playerMove(player, row, col)
                        drawBoard()
                        Send_Flag = 1
                        time.sleep(0.5)
                        if verifyWinner('X'):
                            player = 'X'
                            previewImg = previewCrossImg
                        else :
                            player, previewImg = updatePlayer(player)
                    #
                    #     else:
                    #         Receive_Flag = 1
                    # elif 550 < mouse[0] < 582 and 610 < mouse[1] < 642:
                    #     resetGame()
                if gameMode == 2:
                    if row < 3 and col < 3 and board[row][col] == '' and Current_Player == 'X':#自己的回合鼠标才能点击
                        send_row = row
                        send_col = col
                        playerMove('X', row, col)
                        drawBoard()
                        Current_Player = 'O'#下完换对方
                        previewImg = previewCircleImg
                        Send_Flag = 1
                        time.sleep(0.5)
                        Receive_Flag = 1
                        # if verifyWinner(player):
                        #     player = 'O'
                        #     previewImg = previewCrossImg
                        # elif gameMode != 2:
                        #
                    else:
                            Receive_Flag = 1
                if 550 < mouse[0] < 582 and 610 < mouse[1] < 642:
                        resetGame()


        screen.fill(background_color)
        drawBoard()
        drawBottomMenu(mouse)
        if row < 3 and col < 3:
            visualizeMove(row, col, previewImg)
        pygame.display.update()


def choose():
    player = None
    running = True
    while running:
        mouse = pygame.mouse.get_pos()
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if crossImg_rect.collidepoint((mouse[0], mouse[1])):
                    player = 'X'
                    running = False
                elif circleImg_rect.collidepoint((mouse[0], mouse[1])):
                    player = 'O'
                    running = False
        screen.blit(crossImg, (80, 300))
        screen.blit(circleImg, (340, 300))
        screen.blit(chooseImg, (8, 25))
        pygame.display.update()
    return player


def drawBoard():
    # 画棋子
    for row in range(3):
        for col in range(3):
            pos = (row * 200 + 12, col * 200 + 12)
            if board[row][col] == 'X':
                screen.blit(crossImg, pos)
            elif board[row][col] == 'O':
                screen.blit(circleImg, pos)
    # 画网格
    width = 10
    color = dark_grey
    pygame.draw.line(screen, color, (200, 0), (200, 600), width)
    pygame.draw.line(screen, color, (400, 0), (400, 600), width)
    pygame.draw.line(screen, color, (0, 200), (600, 200), width)
    pygame.draw.line(screen, color, (0, 400), (600, 400), width)
    # 画边框
    pygame.draw.rect(screen, color, (0, 0, 10, 600))
    pygame.draw.rect(screen, color, (0, 0, 600, 10))
    pygame.draw.rect(screen, color, (590, 0, 10, 600))


def drawBottomMenu(mouse):
    pygame.draw.rect(screen, dark_grey, (0, 600, 600, 100))
    pygame.draw.rect(screen, light_grey, (10, 610, 580, 80))
    screen.blit(restartImg, (550, 610))
    # Hover animation
    if 550 < mouse[0] < 582 and 610 < mouse[1] < 642:
        screen.blit(restartHoveredImg, (548, 608))
    screen.blit(X_score, (200, 610))
    screen.blit(O_score, (370, 610))
    scoreboard = font.render(': %d x %d :' % (score['X'], score['O']), True, background_color, light_grey)
    screen.blit(scoreboard, (244, 610))


def visualizeMove(row, col, previewImg):
    if board[row][col] == '':
        screen.blit(previewImg, (row * 200 + 12, col * 200 + 12))


def playerMove(player, row, col):
    board[row][col] = player

def CounterMove(row, col):
    board[row][col] = "O"


def computerMove(player):
    bestScore = float('inf')
    for row in range(3):
        for col in range(3):
            if board[row][col] == '':
                board[row][col] = 'O'
                score = minimax(board, 'X')
                board[row][col] = ''
                if score < bestScore:
                    bestScore = score
                    bestMove = (row, col)
    board[bestMove[0]][bestMove[1]] = player


scores = {'X': 1, 'O': -1, 'tie': 0}


def minimax(board, cur_player):
    if isWinner('X'):
        return scores['X']
    elif isWinner('O'):
        return scores['O']
    elif isBoardFull():
        return scores['tie']
    if cur_player == 'X':
        bestScore = float('-inf')
        nextPlayer = 'O'
        minORmax = max
    else:
        bestScore = float('inf')
        nextPlayer = 'X'
        minORmax = min
    for row in range(3):
        for col in range(3):
            if board[row][col] == '':
                board[row][col] = cur_player
                score = minimax(board, nextPlayer)
                board[row][col] = ''
                bestScore = minORmax(score, bestScore)
            if bestScore == scores[cur_player]:
                return bestScore
    return bestScore


def updatePlayer(player):
    if player == 'X':
        newPlayer = 'O'
        previewImg = previewCircleImg
    else:
        newPlayer = 'X'
        previewImg = previewCrossImg
    return newPlayer, previewImg



def isWinner(player):
    return ((board[0][0] == player and board[0][1] == player and board[0][2] == player) or
            (board[1][0] == player and board[1][1] == player and board[1][2] == player) or
            (board[2][0] == player and board[2][1] == player and board[2][2] == player) or
            (board[0][0] == player and board[1][0] == player and board[2][0] == player) or
            (board[0][1] == player and board[1][1] == player and board[2][1] == player) or
            (board[0][2] == player and board[1][2] == player and board[2][2] == player) or
            (board[0][0] == player and board[1][1] == player and board[2][2] == player) or
            (board[0][2] == player and board[1][1] == player and board[2][0] == player))


def verifyWinner(player):
    global Send_Flag, Receive_Flag, Current_Player,dataSocket
    if isWinner(player):
        # dataSocket.close()
        # dataSocket, addr = listenSocket.accept()
        print(player, "win")
        if player == 'O':
            toSend = 'Over'
            dataSocket.send(toSend.encode())
            print("send_meseage:",toSend)
        # Send_Flag = 0
        # Receive_Flag = 0  ##一开始不发送也不接受，主机
        Current_Player = 'X'  # X先下棋
        score[player] += 1
        ctypes.windll.user32.MessageBoxW(0, player + ' 获胜！', '提示', 0)
        resetBoard()
        return True
    return False


def isBoardFull():
    for i in range(3):
        for j in range(3):
            if board[i][j] == '':
                return False
    return True


def resetBoard():
    for i in range(3):
        for j in range(3):
            board[i][j] = ''


def resetGame():
    resetBoard()
    score['X'] = 0
    score['O'] = 0
global i
i = 0
def TCP_Server():
    global send_row, send_col ,Send_Flag,row, col,Receive_Flag,i,Current_Player,previewImg
    while True:
        # i = 0
        # time.sleep(1)
        # print("Server....Alive",i)
        # i +=1
        # 尝试读取对方发送的消息
        # BUFLEN 指定从接收缓冲里最多读取多少字节
        # recved = dataSocket.recv(BUFLEN)
        #
        # # 如果返回空bytes，表示对方关闭了连接
        # # 退出循环，结束消息收发
        # if not recved:
        #     break

        # 读取的字节数据是bytes类型，需要解码为字符串
        # info = recved.decode()
        # print(f'收到对方信息： {info}')
        #
        # # 发送的数据类型必须是bytes，所以要编码
        # dataSocket.send(f'服务端接收到了信息 '.encode())

        # 从终端读入用户输入的字符串
        # toSend = input('>>> ')
        # if toSend == 'exit':
        #     break
        # # 发送消息，也要编码为 bytes

        # recved = dataSocket.recv(BUFLEN)
        if Receive_Flag == 1:
            print("waiting for receiving...........")
            recved = dataSocket.recv(BUFLEN)
            if  not recved:
                break
            # 打印读取的信息
                print("receive,....",recved)
                print("not yet received.....")
            rec = recved.decode()
            print("receive ,", rec)
            if rec == "Over":
                Send_Flag = 0
                Receive_Flag = 0
            else:
                Receive_Flag = 0
                previewImg = previewCrossImg
                print(recved.decode())
                print('rec......', rec)
                counter_row = int(rec[1])
                counter_col = int(rec[3])
                board[counter_row][counter_col] = "O"
                drawBoard()
                Current_Player = 'X'##收到对面信息后回到主场
                pygame.display.update()

        if Send_Flag == 1:
            # print()
            toSend = "r"+str(send_row)+"c"+str(send_col)
            print(" toSend ", toSend)
            dataSocket.send(toSend.encode())
            Send_Flag = 0
            time.sleep(0.5)

        # recved = dataSocket.recv(BUFLEN)
        # if  recved:
        # # 打印读取的信息
        #     print(recved.decode())
        #     rec=recved.decode()
        #     counter_row= int(rec[1])
        #     counter_col =int(rec[3])
        #     board[counter_row][counter_col] = "O"
        #     drawBoard()
        #     pygame.display.update()




    #
    # # 服务端也调用close()关闭socket
    # dataSocket.close()
    # listenSocket.close()

server_thread = threading.Thread(target = TCP_Server )
server_thread.start()
menu()
dataSocket.close()
listenSocket.close()
```

#### 客户端



```python
import pygame
import ctypes
#  === TCP 客户端程序 client.py ===
import time
from socket import *
import threading
IP = '127.0.0.1'
SERVER_PORT = 50000
BUFLEN = 1024

# 实例化一个socket对象，指明协议
dataSocket = socket(AF_INET, SOCK_STREAM)
global Send_Flag,Receive_Flag,current_player,previewImg,gameMode
Send_Flag = 0
Receive_Flag = 1
current_player = 'X'#服务端先下
gameMode = 0
# 连接服务端socket
dataSocket.connect((IP, SERVER_PORT))
# 初始化 pygame
pygame.init()

# 定义颜色
blue = (78, 140, 243)
light_blue = (100, 100, 255)
red = (242, 89, 97)
light_red = (255, 100, 100)
dark_grey = (85, 85, 85)
light_grey = (100, 100, 100)
background_color = (225, 225, 225)

# 创建窗口
screen = pygame.display.set_mode((600, 800))
pygame.display.set_caption('井字棋-客户端')

# 游戏图片
crossImg = pygame.image.load('Images/crossImg.png')
crossImg_rect = crossImg.get_rect()
crossImg_rect.center = (200, 300)
circleImg = pygame.image.load('Images/circleImg.png')
circleImg_rect = crossImg.get_rect()
circleImg_rect.center = (400, 300)
previewCrossImg = pygame.image.load('Images/prev_crossImg.png')
previewCircleImg = pygame.image.load('Images/prev_circleImg.png')
previewImg = previewCrossImg
# 按钮图片
restartImg = pygame.image.load('Images/restart.png')
restartHoveredImg = pygame.image.load('Images/restart_hovered.png')

# 定义棋盘
board = [['', '', ''],
         ['', '', ''],
         ['', '', '']]

# 定义计分板
score = {'X': 0, 'O': 0}
font = pygame.font.Font('freesansbold.ttf', 32)
X_score = pygame.image.load('Images/X_scoreImg.png')
O_score = pygame.image.load('Images/O_scoreImg.png')

# 菜单图片
buttom1 = pygame.image.load('Images/button1Img.png')
buttom1_rect = buttom1.get_rect()
buttom1_rect.center = (300, 312)
buttom2 = pygame.image.load('Images/button2Img.png')
buttom2_rect = buttom2.get_rect()
buttom2_rect.center = (300, 472)
buttom3 = pygame.image.load('Images/button3Img.png')
buttom3_rect = buttom3.get_rect()
buttom3_rect.center = (300, 632)
logo = pygame.image.load('Images/logo.png')

# 选择菜单图片
chooseImg = pygame.image.load('Images/choose.png')


def menu():
    global gameMode
    running = True
    while running:
        screen.fill(background_color)
        mx, my = pygame.mouse.get_pos()
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if buttom1_rect.collidepoint((mx, my)):
                    gameMode= 0
                    game(0, 'X')
                elif buttom2_rect.collidepoint((mx, my)):
                    player = choose()
                    if player is not None:
                        gameMode= 1
                        game(1, player)
                elif buttom3_rect.collidepoint((mx, my)):
                    gameMode = 2
                    game(2, 'O')
        screen.blit(logo, (8, 25))
        screen.blit(buttom1, (100, 250))
        screen.blit(buttom2, (100, 410))
        screen.blit(buttom3, (100, 570))
        pygame.display.update()


def game(gameMode, player):
    global send_row, send_col, Send_Flag, Receive_Flag,row, col,current_player,previewImg
    my = player
    # player = current_player
    running = True
    if gameMode == 2:
        previewImg = previewCrossImg  # 服务端先下
    else:
        previewImg = previewCircleImg

    while running:
        mouse = pygame.mouse.get_pos()
        row, col = int(mouse[0] / 200), int(mouse[1] / 200)
        for event in pygame.event.get():
            if verifyWinner('O'):
                # player = 'O'
                # previewImg = previewCrossImg
                 pass
            if verifyWinner('X'):
                # player = 'X'
                # previewImg = previewCrossImg
                pass
            if event.type == pygame.QUIT:
                resetGame()
                running = False
            elif isBoardFull():
                ctypes.windll.user32.MessageBoxW(0, '平局', '提示', 0)
                resetBoard()
            elif gameMode == 1 and player != my:
                computerMove(player)
                drawBoard()
                pygame.display.update()
                if verifyWinner(player):
                    player = 'O'
                    previewImg = previewCrossImg
                else:
                    player, previewImg = updatePlayer(player)
            # elif gameMode == 2 and player != my:
            #     CounterMove(player)
            #     drawBoard()
            #     pygame.display.update()
            #     if verifyWinner(player):
            #         player = 'O'
            #         previewImg = previewCrossImg
            #     else:
            #         player, previewImg = updatePlayer(player)
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if gameMode != 2:
                    if row < 3 and col < 3 and board[row][col] == '':
                        send_row = row
                        send_col = col
                        playerMove(player, row, col)
                        drawBoard()
                        # Send_Flag = 1
                        # time.sleep(0.5)
                        if verifyWinner('O'):
                            player = 'X'
                            previewImg = previewCrossImg
                        else :
                            player, previewImg = updatePlayer(player)
                    #
                    #     else:
                    #         Receive_Flag = 1
                    # elif 550 < mouse[0] < 582 and 610 < mouse[1] < 642:
                    #     resetGame()
                if gameMode == 2:
                    if row < 3 and col < 3 and board[row][col] == '' and current_player == 'O':#自己的回合鼠标才能点击
                        send_row = row
                        send_col = col
                        playerMove('O', row, col)
                        drawBoard()
                        current_player = 'X'#下完换对方
                        previewImg = previewCrossImg
                        Send_Flag = 1
                        print("I am going to send O message")
                        time.sleep(1)
                        Receive_Flag = 1
                        print("I am wating for message")
                        # if verifyWinner(player):
                        #     player = 'O'
                        #     previewImg = previewCrossImg
                        # elif gameMode != 2:
                        #
                    else:
                            Receive_Flag = 1
                if 550 < mouse[0] < 582 and 610 < mouse[1] < 642:
                        resetGame()
        screen.fill(background_color)
        drawBoard()
        drawBottomMenu(mouse)
        if row < 3 and col < 3:
            visualizeMove(row, col, previewImg)
        pygame.display.update()


def choose():
    player = None
    running = True
    while running:
        mouse = pygame.mouse.get_pos()
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if crossImg_rect.collidepoint((mouse[0], mouse[1])):
                    player = 'X'
                    running = False
                elif circleImg_rect.collidepoint((mouse[0], mouse[1])):
                    player = 'O'
                    running = False
        screen.blit(crossImg, (80, 300))
        screen.blit(circleImg, (340, 300))
        screen.blit(chooseImg, (8, 25))
        pygame.display.update()
    return player


def drawBoard():
    # 画棋子
    for row in range(3):
        for col in range(3):
            pos = (row * 200 + 12, col * 200 + 12)
            if board[row][col] == 'X':
                screen.blit(crossImg, pos)
            elif board[row][col] == 'O':
                screen.blit(circleImg, pos)
    # 画网格
    width = 10
    color = dark_grey
    pygame.draw.line(screen, color, (200, 0), (200, 600), width)
    pygame.draw.line(screen, color, (400, 0), (400, 600), width)
    pygame.draw.line(screen, color, (0, 200), (600, 200), width)
    pygame.draw.line(screen, color, (0, 400), (600, 400), width)
    # 画边框
    pygame.draw.rect(screen, color, (0, 0, 10, 600))
    pygame.draw.rect(screen, color, (0, 0, 600, 10))
    pygame.draw.rect(screen, color, (590, 0, 10, 600))


def drawBottomMenu(mouse):
    pygame.draw.rect(screen, dark_grey, (0, 600, 600, 100))
    pygame.draw.rect(screen, light_grey, (10, 610, 580, 80))
    screen.blit(restartImg, (550, 610))
    # Hover animation
    if 550 < mouse[0] < 582 and 610 < mouse[1] < 642:
        screen.blit(restartHoveredImg, (548, 608))
    screen.blit(X_score, (200, 610))
    screen.blit(O_score, (370, 610))
    scoreboard = font.render(': %d x %d :' % (score['X'], score['O']), True, background_color, light_grey)
    screen.blit(scoreboard, (244, 610))


def visualizeMove(row, col, previewImg):
    if board[row][col] == '':
        screen.blit(previewImg, (row * 200 + 12, col * 200 + 12))


def playerMove(player, row, col):
    board[row][col] = player


def computerMove(player):
    bestScore = float('inf')
    for row in range(3):
        for col in range(3):
            if board[row][col] == '':
                board[row][col] = 'O'
                score = minimax(board, 'X')
                board[row][col] = ''
                if score < bestScore:
                    bestScore = score
                    bestMove = (row, col)
    board[bestMove[0]][bestMove[1]] = player


scores = {'X': 1, 'O': -1, 'tie': 0}


def minimax(board, cur_player):
    if isWinner('X'):
        return scores['X']
    elif isWinner('O'):
        return scores['O']
    elif isBoardFull():
        return scores['tie']
    if cur_player == 'X':
        bestScore = float('-inf')
        nextPlayer = 'O'
        minORmax = max
    else:
        bestScore = float('inf')
        nextPlayer = 'X'
        minORmax = min
    for row in range(3):
        for col in range(3):
            if board[row][col] == '':
                board[row][col] = cur_player
                score = minimax(board, nextPlayer)
                board[row][col] = ''
                bestScore = minORmax(score, bestScore)
            if bestScore == scores[cur_player]:
                return bestScore
    return bestScore


def updatePlayer(player):
    if player == 'X':
        newPlayer = 'O'
        previewImg = previewCircleImg
    else:
        newPlayer = 'X'
        previewImg = previewCrossImg
    return newPlayer, previewImg



def isWinner(player):
    return ((board[0][0] == player and board[0][1] == player and board[0][2] == player) or
            (board[1][0] == player and board[1][1] == player and board[1][2] == player) or
            (board[2][0] == player and board[2][1] == player and board[2][2] == player) or
            (board[0][0] == player and board[1][0] == player and board[2][0] == player) or
            (board[0][1] == player and board[1][1] == player and board[2][1] == player) or
            (board[0][2] == player and board[1][2] == player and board[2][2] == player) or
            (board[0][0] == player and board[1][1] == player and board[2][2] == player) or
            (board[0][2] == player and board[1][1] == player and board[2][0] == player))


def verifyWinner(player):
    global  Send_Flag,Receive_Flag,current_player,dataSocket,previewImg,gameMode
    if isWinner(player):
        print(player, "win")
        if player == 'X':
            toSend = 'Over'
            dataSocket.send(toSend.encode())
            print("send_meseage:",toSend)
        Send_Flag = 0
        Receive_Flag = 1
        if gameMode ==2:
            previewImg = previewCrossImg
            current_player = 'X'  # 服务端先下
        score[player] += 1
        ctypes.windll.user32.MessageBoxW(0, player + ' 获胜！', '提示', 0)
        resetBoard()
        return True
    return False


def isBoardFull():
    for i in range(3):
        for j in range(3):
            if board[i][j] == '':
                return False
    return True


def resetBoard():
    for i in range(3):
        for j in range(3):
            board[i][j] = ''


def resetGame():
    resetBoard()
    score['X'] = 0
    score['O'] = 0
global i
i = 0
def TCP_Client():
    global send_row, send_col ,Send_Flag,row, col,Receive_Flag, i, current_player, previewImg
    while True:
        # i = 0
        # time.sleep(1)
        # print("Receive_Flag",Receive_Flag)
        # print()
        # print("Client....Alive",i)
        # i += 1
        # 从终端读入用户输入的字符串
        # toSend = input('>>> ')
        # if toSend == 'exit':
        #     break
        # # 发送消息，也要编码为 bytes
        # dataSocket.send(toSend.encode())

        # 等待接收服务端的消息
        if Send_Flag == 1:
            print("Sending..........")
            toSend = "r"+str(send_row)+"c"+str(send_col)
            print(" toSend ", toSend)
            dataSocket.send(toSend.encode())
            Send_Flag = 0
            time.sleep(0.5)

        # 如果返回空bytes，表示对方关闭了连接


        if Receive_Flag == 1:
        #     print("waiting for receiving...........")
            recved = dataSocket.recv(BUFLEN)
            rec = recved.decode()
            print("receive ,", rec)
            if rec == "Over":
                Send_Flag = 0
                Receive_Flag = 1#收到结束提醒后重新开始，仍然是接收状态

                # break##用来退出阻塞
            else:
                Receive_Flag = 0
                previewImg = previewCircleImg
                print(recved.decode())
                print('rec......', rec)
                counter_row = int(rec[1])
                counter_col = int(rec[3])
                board[counter_row][counter_col] = "X"
                drawBoard()
                current_player = 'O'  ##收到对面信息后回到主场
                pygame.display.update()





client_thread = threading.Thread(target=TCP_Client)
client_thread.start()

menu()
dataSoc
```

### 自己落子能刷新

#### 服务端



```python
import pygame
import ctypes
# 导入socket 库
from socket import *
import threading
import time

# 主机地址为空字符串，表示绑定本机所有网络接口ip地址
# 等待客户端来连接
IP = ''
# 端口号
PORT = 50000
# 定义一次从socket缓冲区最多读入512个字节数据
BUFLEN = 512

# 实例化一个socket对象
# 参数 AF_INET 表示该socket网络层使用IP协议
# 参数 SOCK_STREAM 表示该socket传输层使用TCP协议
listenSocket = socket(AF_INET, SOCK_STREAM)

# socket绑定地址和端口
listenSocket.bind((IP, PORT))


# 使socket处于监听状态，等待客户端的连接请求
# 参数 8 表示 最多接受多少个等待连接的客户端
listenSocket.listen(8)
print(f'服务端启动成功，在{PORT}端口等待客户端连接...')

dataSocket, addr = listenSocket.accept()
print('接受一个客户端连接:', addr)


global Send_Flag,Receive_Flag,Current_Player,If_over,previewImg,gameMode
# 初始化 pygame
pygame.init()

# 定义颜色
blue = (78, 140, 243)
light_blue = (100, 100, 255)
red = (242, 89, 97)
light_red = (255, 100, 100)
dark_grey = (85, 85, 85)
light_grey = (100, 100, 100)
background_color = (225, 225, 225)
Send_Flag = 0
Receive_Flag = 0##一开始不发送也不接受，主机
Current_Player = 'X'#X先下棋
If_over = 0
gameMode = 0
# 创建窗口
screen = pygame.display.set_mode((600, 800))
pygame.display.set_caption('井字棋')

# 游戏图片
crossImg = pygame.image.load('Images/crossImg.png')
crossImg_rect = crossImg.get_rect()
crossImg_rect.center = (200, 300)
circleImg = pygame.image.load('Images/circleImg.png')
circleImg_rect = crossImg.get_rect()
circleImg_rect.center = (400, 300)
previewCrossImg = pygame.image.load('Images/prev_crossImg.png')
previewCircleImg = pygame.image.load('Images/prev_circleImg.png')

previewImg = previewCrossImg
# 按钮图片
restartImg = pygame.image.load('Images/restart.png')
restartHoveredImg = pygame.image.load('Images/restart_hovered.png')

# 定义棋盘
board = [['', '', ''],
         ['', '', ''],
         ['', '', '']]

# 定义计分板
score = {'X': 0, 'O': 0}
font = pygame.font.Font('freesansbold.ttf', 32)
X_score = pygame.image.load('Images/X_scoreImg.png')
O_score = pygame.image.load('Images/O_scoreImg.png')

# 菜单图片
buttom1 = pygame.image.load('Images/button1Img.png')
buttom1_rect = buttom1.get_rect()
buttom1_rect.center = (300, 312)
buttom2 = pygame.image.load('Images/button2Img.png')
buttom2_rect = buttom2.get_rect()
buttom2_rect.center = (300, 472)

buttom3 = pygame.image.load('Images/button3Img.png')
buttom3_rect = buttom3.get_rect()
buttom3_rect.center = (300, 632)

logo = pygame.image.load('Images/logo.png')

# 选择菜单图片
chooseImg = pygame.image.load('Images/choose.png')


def menu():
    global gameMode
    running = True
    while running:
        screen.fill(background_color)
        mx, my = pygame.mouse.get_pos()
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if buttom1_rect.collidepoint((mx, my)):
                    game(0, 'X')
                    gameMode = 0
                elif buttom2_rect.collidepoint((mx, my)):
                    player = choose()
                    if player is not None:
                        game(1, player)
                        gameMode =1
                elif buttom3_rect.collidepoint((mx, my)):
                    gameMode = 2
                    game(2, 'X')
        screen.blit(logo, (8, 25))
        screen.blit(buttom1, (100, 250))
        screen.blit(buttom2, (100, 410))
        screen.blit(buttom3, (100, 570))
        pygame.display.update()


def game(gameMode, player):
    global send_row, send_col ,Send_Flag,row, col,Receive_Flag,Current_Player,If_over,previewImg
    my = player
    player = 'X'
    running = True
    while running:
        mouse = pygame.mouse.get_pos()
        row, col = int(mouse[0] / 200), int(mouse[1] / 200)
        for event in pygame.event.get():
            if verifyWinner('X'):
                print("确认X胜利")
                player = 'X'
                previewImg = previewCrossImg
            if verifyWinner('O'):
                print("确认O胜利")
                player = 'X'
                previewImg = previewCrossImg
            if event.type == pygame.QUIT:
                resetGame()
                running = False
            elif isBoardFull():
                ctypes.windll.user32.MessageBoxW(0, '平局', '提示', 0)
                resetBoard()
            elif gameMode == 1 and player != my:
                computerMove(player)
                drawBoard()
                pygame.display.update()
                # if verifyWinner(player):
                #     player = 'X'
                #     previewImg = previewCrossImg
                # else:
                #     player, previewImg = updatePlayer(player)
                if verifyWinner(player):
                    player = 'X'
                    previewImg = previewCrossImg
                else:
                    player, previewImg = updatePlayer(player)
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if gameMode != 2:
                    if row < 3 and col < 3 and board[row][col] == '':
                        # send_row = row
                        # send_col = col
                        playerMove(player, row, col)
                        drawBoard()
                        Send_Flag = 1
                        time.sleep(0.5)
                        if verifyWinner('X'):
                            player = 'X'
                            previewImg = previewCrossImg
                        else :
                            player, previewImg = updatePlayer(player)
                if gameMode == 2:
                    if row < 3 and col < 3 and board[row][col] == '':
                        print("Current_Player", Current_Player)
                    if row < 3 and col < 3 and board[row][col] == '' and Current_Player == 'X':#自己的回合鼠标才能点击
                        send_row = row
                        send_col = col
                        playerMove('X', row, col)
                        drawBoard()
                        Current_Player = 'O'#下完换对方
                        previewImg = previewCircleImg
                        Send_Flag = 1
                        print("I am going to Send message X")
                        time.sleep(0.5)
                        Receive_Flag = 1
                        print("I am waiting for O message")
                    # else:
                    #         Receive_Flag = 1
                if 550 < mouse[0] < 582 and 610 < mouse[1] < 642:
                        time.sleep(0.5)
                        resetGame()


        screen.fill(background_color)
        drawBoard()
        drawBottomMenu(mouse)
        if row < 3 and col < 3:
            visualizeMove(row, col, previewImg)
        pygame.display.update()


def choose():
    player = None
    running = True
    while running:
        mouse = pygame.mouse.get_pos()
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if crossImg_rect.collidepoint((mouse[0], mouse[1])):
                    player = 'X'
                    running = False
                elif circleImg_rect.collidepoint((mouse[0], mouse[1])):
                    player = 'O'
                    running = False
        screen.blit(crossImg, (80, 300))
        screen.blit(circleImg, (340, 300))
        screen.blit(chooseImg, (8, 25))
        pygame.display.update()
    return player


def drawBoard():
    # 画棋子
    for row in range(3):
        for col in range(3):
            pos = (row * 200 + 12, col * 200 + 12)
            if board[row][col] == 'X':
                screen.blit(crossImg, pos)
            elif board[row][col] == 'O':
                screen.blit(circleImg, pos)
    # 画网格
    width = 10
    color = dark_grey
    pygame.draw.line(screen, color, (200, 0), (200, 600), width)
    pygame.draw.line(screen, color, (400, 0), (400, 600), width)
    pygame.draw.line(screen, color, (0, 200), (600, 200), width)
    pygame.draw.line(screen, color, (0, 400), (600, 400), width)
    # 画边框
    pygame.draw.rect(screen, color, (0, 0, 10, 600))
    pygame.draw.rect(screen, color, (0, 0, 600, 10))
    pygame.draw.rect(screen, color, (590, 0, 10, 600))


def drawBottomMenu(mouse):
    pygame.draw.rect(screen, dark_grey, (0, 600, 600, 100))
    pygame.draw.rect(screen, light_grey, (10, 610, 580, 80))
    screen.blit(restartImg, (550, 610))
    # Hover animation
    if 550 < mouse[0] < 582 and 610 < mouse[1] < 642:
        screen.blit(restartHoveredImg, (548, 608))
    screen.blit(X_score, (200, 610))
    screen.blit(O_score, (370, 610))
    scoreboard = font.render(': %d x %d :' % (score['X'], score['O']), True, background_color, light_grey)
    screen.blit(scoreboard, (244, 610))


def visualizeMove(row, col, previewImg):
    if board[row][col] == '':
        screen.blit(previewImg, (row * 200 + 12, col * 200 + 12))


def playerMove(player, row, col):
    board[row][col] = player

def CounterMove(row, col):
    board[row][col] = "O"


def computerMove(player):
    bestScore = float('inf')
    for row in range(3):
        for col in range(3):
            if board[row][col] == '':
                board[row][col] = 'O'
                score = minimax(board, 'X')
                board[row][col] = ''
                if score < bestScore:
                    bestScore = score
                    bestMove = (row, col)
    board[bestMove[0]][bestMove[1]] = player


scores = {'X': 1, 'O': -1, 'tie': 0}


def minimax(board, cur_player):
    if isWinner('X'):
        return scores['X']
    elif isWinner('O'):
        return scores['O']
    elif isBoardFull():
        return scores['tie']
    if cur_player == 'X':
        bestScore = float('-inf')
        nextPlayer = 'O'
        minORmax = max
    else:
        bestScore = float('inf')
        nextPlayer = 'X'
        minORmax = min
    for row in range(3):
        for col in range(3):
            if board[row][col] == '':
                board[row][col] = cur_player
                score = minimax(board, nextPlayer)
                board[row][col] = ''
                bestScore = minORmax(score, bestScore)
            if bestScore == scores[cur_player]:
                return bestScore
    return bestScore


def updatePlayer(player):
    if player == 'X':
        newPlayer = 'O'
        previewImg = previewCircleImg
    else:
        newPlayer = 'X'
        previewImg = previewCrossImg
    return newPlayer, previewImg



def isWinner(player):
    return ((board[0][0] == player and board[0][1] == player and board[0][2] == player) or
            (board[1][0] == player and board[1][1] == player and board[1][2] == player) or
            (board[2][0] == player and board[2][1] == player and board[2][2] == player) or
            (board[0][0] == player and board[1][0] == player and board[2][0] == player) or
            (board[0][1] == player and board[1][1] == player and board[2][1] == player) or
            (board[0][2] == player and board[1][2] == player and board[2][2] == player) or
            (board[0][0] == player and board[1][1] == player and board[2][2] == player) or
            (board[0][2] == player and board[1][1] == player and board[2][0] == player))


def verifyWinner(player):
    global Send_Flag, Receive_Flag, Current_Player,dataSocket,gameMode,previewImg
    if isWinner(player):
        # dataSocket.close()
        # dataSocket, addr = listenSocket.accept()
        print(player, "win")
        if gameMode == 2:
            print("I have turn current_player to X")
            Current_Player = 'X'  # X先下棋
            previewImg = previewCrossImg
            if player == 'O':
                toSend = 'Over'
                dataSocket.send(toSend.encode())
                print("send_meseage:",toSend)
                Send_Flag = 0
                Receive_Flag = 0  ##一开始不发送也不接受，主机

        score[player] += 1
        ctypes.windll.user32.MessageBoxW(0, player + ' 获胜！', '提示', 0)
        resetBoard()
        return True
    return False


def isBoardFull():
    for i in range(3):
        for j in range(3):
            if board[i][j] == '':
                return False
    return True


def resetBoard():
    for i in range(3):
        for j in range(3):
            board[i][j] = ''

def Common_Reset():##对方刷新引起的刷新
    global Send_Flag,Receive_Flag,gameMode,Current_Player,previewImg,dataSocket
    resetBoard()
    score['X'] = 0
    score['O'] = 0
    if gameMode == 2:
        Send_Flag = 0
        Receive_Flag = 0
        Current_Player = 'X'
        print("I have turn the picture to Cross")
        previewImg = previewCrossImg
def resetGame():
    global Send_Flag,Receive_Flag,gameMode,Current_Player,previewImg,dataSocket
    resetBoard()
    score['X'] = 0
    score['O'] = 0
    if gameMode == 2:
        Send_Flag = 0
        Receive_Flag = 0
        Current_Player = 'X'
        print("I have turn the picture to Cross")
        previewImg = previewCrossImg
        if Current_Player == 'X':##客户端在等消息
            toSend ="Reset"
            dataSocket.send(toSend.encode())

global i
i = 0
def TCP_Server():
    global send_row, send_col ,Send_Flag,row, col,Receive_Flag,i,Current_Player,previewImg
    while True:
        if Receive_Flag == 1:
            print("waiting for receiving...........")
            recved = dataSocket.recv(BUFLEN)
            if  not recved:
                break
            # 打印读取的信息
                print("receive,....",recved)
                print("not yet received.....")
            rec = recved.decode()
            print("receive ,", rec)
            if rec == "Over" :
                Send_Flag = 0
                Receive_Flag = 0
            elif rec == "Reset":
                Common_Reset()
            else:
                Receive_Flag = 0
                previewImg = previewCrossImg
                print(recved.decode())
                print('rec......', rec)
                counter_row = int(rec[1])
                counter_col = int(rec[3])
                board[counter_row][counter_col] = "O"
                drawBoard()
                Current_Player = 'X'##收到对面信息后回到主场
                pygame.display.update()

        if Send_Flag == 1:
            # print()
            toSend = "r"+str(send_row)+"c"+str(send_col)
            print(" toSend ", toSend)
            dataSocket.send(toSend.encode())
            Send_Flag = 0
            time.sleep(0.5)



server_thread = threading.Thread(target = TCP_Server )
server_thread.start()
menu()
dataSocket.close()
listenSocket.close()
```

#### 客户端

```python
import pygame
import ctypes
#  === TCP 客户端程序 client.py ===
import time
from socket import *
import threading
IP = '127.0.0.1'
SERVER_PORT = 50000
BUFLEN = 1024

# 实例化一个socket对象，指明协议
dataSocket = socket(AF_INET, SOCK_STREAM)
global Send_Flag,Receive_Flag,current_player,previewImg,gameMode
Send_Flag = 0
Receive_Flag = 1
current_player = 'X'#服务端先下
gameMode = 0
# 连接服务端socket
dataSocket.connect((IP, SERVER_PORT))
# 初始化 pygame
pygame.init()

# 定义颜色
blue = (78, 140, 243)
light_blue = (100, 100, 255)
red = (242, 89, 97)
light_red = (255, 100, 100)
dark_grey = (85, 85, 85)
light_grey = (100, 100, 100)
background_color = (225, 225, 225)

# 创建窗口
screen = pygame.display.set_mode((600, 800))
pygame.display.set_caption('井字棋-客户端')

# 游戏图片
crossImg = pygame.image.load('Images/crossImg.png')
crossImg_rect = crossImg.get_rect()
crossImg_rect.center = (200, 300)
circleImg = pygame.image.load('Images/circleImg.png')
circleImg_rect = crossImg.get_rect()
circleImg_rect.center = (400, 300)
previewCrossImg = pygame.image.load('Images/prev_crossImg.png')
previewCircleImg = pygame.image.load('Images/prev_circleImg.png')
previewImg = previewCrossImg
# 按钮图片
restartImg = pygame.image.load('Images/restart.png')
restartHoveredImg = pygame.image.load('Images/restart_hovered.png')

# 定义棋盘
board = [['', '', ''],
         ['', '', ''],
         ['', '', '']]

# 定义计分板
score = {'X': 0, 'O': 0}
font = pygame.font.Font('freesansbold.ttf', 32)
X_score = pygame.image.load('Images/X_scoreImg.png')
O_score = pygame.image.load('Images/O_scoreImg.png')

# 菜单图片
buttom1 = pygame.image.load('Images/button1Img.png')
buttom1_rect = buttom1.get_rect()
buttom1_rect.center = (300, 312)
buttom2 = pygame.image.load('Images/button2Img.png')
buttom2_rect = buttom2.get_rect()
buttom2_rect.center = (300, 472)
buttom3 = pygame.image.load('Images/button3Img.png')
buttom3_rect = buttom3.get_rect()
buttom3_rect.center = (300, 632)
logo = pygame.image.load('Images/logo.png')

# 选择菜单图片
chooseImg = pygame.image.load('Images/choose.png')


def menu():
    global gameMode
    running = True
    while running:
        screen.fill(background_color)
        mx, my = pygame.mouse.get_pos()
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if buttom1_rect.collidepoint((mx, my)):
                    gameMode= 0
                    game(0, 'X')
                elif buttom2_rect.collidepoint((mx, my)):
                    player = choose()
                    if player is not None:
                        gameMode= 1
                        game(1, player)
                elif buttom3_rect.collidepoint((mx, my)):
                    gameMode = 2
                    game(2, 'O')
        screen.blit(logo, (8, 25))
        screen.blit(buttom1, (100, 250))
        screen.blit(buttom2, (100, 410))
        screen.blit(buttom3, (100, 570))
        pygame.display.update()


def game(gameMode, player):
    global send_row, send_col, Send_Flag, Receive_Flag,row, col,current_player,previewImg
    my = player
    # player = current_player
    running = True
    if gameMode == 2:
        previewImg = previewCrossImg  # 服务端先下
    else:
        previewImg = previewCircleImg

    while running:
        mouse = pygame.mouse.get_pos()
        row, col = int(mouse[0] / 200), int(mouse[1] / 200)
        for event in pygame.event.get():
            if verifyWinner('O'):
                # player = 'O'
                # previewImg = previewCrossImg
                 pass
            if verifyWinner('X'):
                # player = 'X'
                # previewImg = previewCrossImg
                pass
            if event.type == pygame.QUIT:
                resetGame()
                running = False
            elif isBoardFull():
                ctypes.windll.user32.MessageBoxW(0, '平局', '提示', 0)
                resetBoard()
            elif gameMode == 1 and player != my:
                computerMove(player)
                drawBoard()
                pygame.display.update()
                if verifyWinner(player):
                    player = 'O'
                    previewImg = previewCrossImg
                else:
                    player, previewImg = updatePlayer(player)
            # elif gameMode == 2 and player != my:
            #     CounterMove(player)
            #     drawBoard()
            #     pygame.display.update()
            #     if verifyWinner(player):
            #         player = 'O'
            #         previewImg = previewCrossImg
            #     else:
            #         player, previewImg = updatePlayer(player)
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if gameMode != 2:
                    if row < 3 and col < 3 and board[row][col] == '':
                        send_row = row
                        send_col = col
                        playerMove(player, row, col)
                        drawBoard()
                        # Send_Flag = 1
                        # time.sleep(0.5)
                        if verifyWinner('O'):
                            player = 'X'
                            previewImg = previewCrossImg
                        else :
                            player, previewImg = updatePlayer(player)
                    #
                    #     else:
                    #         Receive_Flag = 1
                    # elif 550 < mouse[0] < 582 and 610 < mouse[1] < 642:
                    #     resetGame()
                if gameMode == 2:
                    if row < 3 and col < 3 and board[row][col] == '':
                        print("Current_Player", current_player)
                    if row < 3 and col < 3 and board[row][col] == '' and current_player == 'O':#自己的回合鼠标才能点击
                        send_row = row
                        send_col = col
                        playerMove('O', row, col)
                        drawBoard()
                        current_player = 'X'#下完换对方
                        previewImg = previewCrossImg
                        Send_Flag = 1
                        print("I am going to send O message")
                        time.sleep(0.5)
                        Receive_Flag = 1
                        print("I am wating for message")
                        # if verifyWinner(player):
                        #     player = 'O'
                        #     previewImg = previewCrossImg
                        # elif gameMode != 2:
                        #
                    # else:
                    #         Receive_Flag = 1
                if 550 < mouse[0] < 582 and 610 < mouse[1] < 642:
                        time.sleep(0.5)
                        resetGame()
        screen.fill(background_color)
        drawBoard()
        drawBottomMenu(mouse)
        if row < 3 and col < 3:
            visualizeMove(row, col, previewImg)
        pygame.display.update()


def choose():
    player = None
    running = True
    while running:
        mouse = pygame.mouse.get_pos()
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if crossImg_rect.collidepoint((mouse[0], mouse[1])):
                    player = 'X'
                    running = False
                elif circleImg_rect.collidepoint((mouse[0], mouse[1])):
                    player = 'O'
                    running = False
        screen.blit(crossImg, (80, 300))
        screen.blit(circleImg, (340, 300))
        screen.blit(chooseImg, (8, 25))
        pygame.display.update()
    return player


def drawBoard():
    # 画棋子
    for row in range(3):
        for col in range(3):
            pos = (row * 200 + 12, col * 200 + 12)
            if board[row][col] == 'X':
                screen.blit(crossImg, pos)
            elif board[row][col] == 'O':
                screen.blit(circleImg, pos)
    # 画网格
    width = 10
    color = dark_grey
    pygame.draw.line(screen, color, (200, 0), (200, 600), width)
    pygame.draw.line(screen, color, (400, 0), (400, 600), width)
    pygame.draw.line(screen, color, (0, 200), (600, 200), width)
    pygame.draw.line(screen, color, (0, 400), (600, 400), width)
    # 画边框
    pygame.draw.rect(screen, color, (0, 0, 10, 600))
    pygame.draw.rect(screen, color, (0, 0, 600, 10))
    pygame.draw.rect(screen, color, (590, 0, 10, 600))


def drawBottomMenu(mouse):
    pygame.draw.rect(screen, dark_grey, (0, 600, 600, 100))
    pygame.draw.rect(screen, light_grey, (10, 610, 580, 80))
    screen.blit(restartImg, (550, 610))
    # Hover animation
    if 550 < mouse[0] < 582 and 610 < mouse[1] < 642:
        screen.blit(restartHoveredImg, (548, 608))
    screen.blit(X_score, (200, 610))
    screen.blit(O_score, (370, 610))
    scoreboard = font.render(': %d x %d :' % (score['X'], score['O']), True, background_color, light_grey)
    screen.blit(scoreboard, (244, 610))


def visualizeMove(row, col, previewImg):
    if board[row][col] == '':
        screen.blit(previewImg, (row * 200 + 12, col * 200 + 12))


def playerMove(player, row, col):
    board[row][col] = player


def computerMove(player):
    bestScore = float('inf')
    for row in range(3):
        for col in range(3):
            if board[row][col] == '':
                board[row][col] = 'O'
                score = minimax(board, 'X')
                board[row][col] = ''
                if score < bestScore:
                    bestScore = score
                    bestMove = (row, col)
    board[bestMove[0]][bestMove[1]] = player


scores = {'X': 1, 'O': -1, 'tie': 0}


def minimax(board, cur_player):
    if isWinner('X'):
        return scores['X']
    elif isWinner('O'):
        return scores['O']
    elif isBoardFull():
        return scores['tie']
    if cur_player == 'X':
        bestScore = float('-inf')
        nextPlayer = 'O'
        minORmax = max
    else:
        bestScore = float('inf')
        nextPlayer = 'X'
        minORmax = min
    for row in range(3):
        for col in range(3):
            if board[row][col] == '':
                board[row][col] = cur_player
                score = minimax(board, nextPlayer)
                board[row][col] = ''
                bestScore = minORmax(score, bestScore)
            if bestScore == scores[cur_player]:
                return bestScore
    return bestScore


def updatePlayer(player):
    if player == 'X':
        newPlayer = 'O'
        previewImg = previewCircleImg
    else:
        newPlayer = 'X'
        previewImg = previewCrossImg
    return newPlayer, previewImg



def isWinner(player):
    return ((board[0][0] == player and board[0][1] == player and board[0][2] == player) or
            (board[1][0] == player and board[1][1] == player and board[1][2] == player) or
            (board[2][0] == player and board[2][1] == player and board[2][2] == player) or
            (board[0][0] == player and board[1][0] == player and board[2][0] == player) or
            (board[0][1] == player and board[1][1] == player and board[2][1] == player) or
            (board[0][2] == player and board[1][2] == player and board[2][2] == player) or
            (board[0][0] == player and board[1][1] == player and board[2][2] == player) or
            (board[0][2] == player and board[1][1] == player and board[2][0] == player))


def verifyWinner(player):
    global  Send_Flag,Receive_Flag,current_player,dataSocket,previewImg,gameMode
    if isWinner(player):
        print(player, "win")
        if gameMode ==2:
            previewImg = previewCrossImg
            current_player = 'X'  # 服务端先下
            if player == 'X':
                toSend = 'Over'
                dataSocket.send(toSend.encode())
                print("send_meseage:", toSend)
                Send_Flag = 0
                Receive_Flag = 1
        score[player] += 1
        ctypes.windll.user32.MessageBoxW(0, player + ' 获胜！', '提示', 0)
        resetBoard()
        return True
    return False


def isBoardFull():
    for i in range(3):
        for j in range(3):
            if board[i][j] == '':
                return False
    return True


def resetBoard():
    for i in range(3):
        for j in range(3):
            board[i][j] = ''

def Common_Reset():##对方刷新引起的刷新，被动刷新
    global Send_Flag,Receive_Flag,gameMode,current_player,previewImg,dataSocket
    resetBoard()
    score['X'] = 0
    score['O'] = 0
    if gameMode == 2:
        Send_Flag = 0
        Receive_Flag = 1
        current_player = 'X'
        print("I have turn the picture to Cross")
        previewImg = previewCrossImg
def resetGame():##主动刷新
    global Send_Flag,Receive_Flag,current_player,previewImg,dataSocket
    if gameMode == 2:
        if current_player == 'O':##主机在等客户端消息
            toSend= "Reset"
            print("toSend",toSend)
            dataSocket.send(toSend.encode())
        Send_Flag = 0
        Receive_Flag = 1
        current_player = 'X'
        previewImg = previewCrossImg
    resetBoard()
    score['X'] = 0
    score['O'] = 0
global i
i = 0
def TCP_Client():
    global send_row, send_col ,Send_Flag,row, col,Receive_Flag, i, current_player, previewImg
    while True:

        # 等待接收服务端的消息
        if Send_Flag == 1:
            print("Sending..........")
            toSend = "r"+str(send_row)+"c"+str(send_col)
            print(" toSend ", toSend)
            dataSocket.send(toSend.encode())
            Send_Flag = 0
            time.sleep(0.5)

        # 如果返回空bytes，表示对方关闭了连接

        if Receive_Flag == 1:
        #     print("waiting for receiving...........")
            recved = dataSocket.recv(BUFLEN)
            rec = recved.decode()
            print("receive ,", rec)
            if rec == "Over" :
                Send_Flag = 0
                Receive_Flag = 1#收到结束提醒后重新开始，仍然是接收状态

                # break##用来退出阻塞
            elif rec == "Reset":
                Common_Reset()
            else:
                Receive_Flag = 0
                previewImg = previewCircleImg
                print(recved.decode())
                print('rec......', rec)
                counter_row = int(rec[1])
                counter_col = int(rec[3])
                board[counter_row][counter_col] = "X"
                drawBoard()
                current_player = 'O'  ##收到对面信息后回到主场
                pygame.display.update()





client_thread = threading.Thread(target=TCP_Client)
client_thread.start()

menu()
dataSoc
```

### 自己落子刷新2

#### 服务端

```python
import pygame
import ctypes
# 导入socket 库
from socket import *
import threading
import time

# 主机地址为空字符串，表示绑定本机所有网络接口ip地址
# 等待客户端来连接
IP = ''
# 端口号
PORT = 50000
# 定义一次从socket缓冲区最多读入512个字节数据
BUFLEN = 512

# 实例化一个socket对象
# 参数 AF_INET 表示该socket网络层使用IP协议
# 参数 SOCK_STREAM 表示该socket传输层使用TCP协议
listenSocket = socket(AF_INET, SOCK_STREAM)

# socket绑定地址和端口
listenSocket.bind((IP, PORT))


# 使socket处于监听状态，等待客户端的连接请求
# 参数 8 表示 最多接受多少个等待连接的客户端
listenSocket.listen(8)
print(f'服务端启动成功，在{PORT}端口等待客户端连接...')

dataSocket, addr = listenSocket.accept()
print('接受一个客户端连接:', addr)


global Send_Flag,Receive_Flag,Current_Player,If_over,previewImg,gameMode
# 初始化 pygame
pygame.init()

# 定义颜色
blue = (78, 140, 243)
light_blue = (100, 100, 255)
red = (242, 89, 97)
light_red = (255, 100, 100)
dark_grey = (85, 85, 85)
light_grey = (100, 100, 100)
background_color = (225, 225, 225)
Send_Flag = 0
Receive_Flag = 0##一开始不发送也不接受，主机
Current_Player = 'X'#X先下棋
If_over = 0
gameMode = 0
# 创建窗口
screen = pygame.display.set_mode((600, 800))
pygame.display.set_caption('井字棋')

# 游戏图片
crossImg = pygame.image.load('Images/crossImg.png')
crossImg_rect = crossImg.get_rect()
crossImg_rect.center = (200, 300)
circleImg = pygame.image.load('Images/circleImg.png')
circleImg_rect = crossImg.get_rect()
circleImg_rect.center = (400, 300)
previewCrossImg = pygame.image.load('Images/prev_crossImg.png')
previewCircleImg = pygame.image.load('Images/prev_circleImg.png')

previewImg = previewCrossImg
# 按钮图片
restartImg = pygame.image.load('Images/restart.png')
restartHoveredImg = pygame.image.load('Images/restart_hovered.png')

# 定义棋盘
board = [['', '', ''],
         ['', '', ''],
         ['', '', '']]

# 定义计分板
score = {'X': 0, 'O': 0}
font = pygame.font.Font('freesansbold.ttf', 32)
X_score = pygame.image.load('Images/X_scoreImg.png')
O_score = pygame.image.load('Images/O_scoreImg.png')

# 菜单图片
buttom1 = pygame.image.load('Images/button1Img.png')
buttom1_rect = buttom1.get_rect()
buttom1_rect.center = (300, 312)
buttom2 = pygame.image.load('Images/button2Img.png')
buttom2_rect = buttom2.get_rect()
buttom2_rect.center = (300, 472)

buttom3 = pygame.image.load('Images/button3Img.png')
buttom3_rect = buttom3.get_rect()
buttom3_rect.center = (300, 632)

logo = pygame.image.load('Images/logo.png')

# 选择菜单图片
chooseImg = pygame.image.load('Images/choose.png')


def menu():
    global gameMode
    running = True
    while running:
        screen.fill(background_color)
        mx, my = pygame.mouse.get_pos()
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if buttom1_rect.collidepoint((mx, my)):
                    game(0, 'X')
                    gameMode = 0
                elif buttom2_rect.collidepoint((mx, my)):
                    player = choose()
                    if player is not None:
                        game(1, player)
                        gameMode =1
                elif buttom3_rect.collidepoint((mx, my)):
                    gameMode = 2
                    game(2, 'X')
        screen.blit(logo, (8, 25))
        screen.blit(buttom1, (100, 250))
        screen.blit(buttom2, (100, 410))
        screen.blit(buttom3, (100, 570))
        pygame.display.update()


def game(gameMode, player):
    global send_row, send_col ,Send_Flag,row, col,Receive_Flag,Current_Player,If_over,previewImg
    my = player
    player = 'X'
    running = True
    while running:
        mouse = pygame.mouse.get_pos()
        row, col = int(mouse[0] / 200), int(mouse[1] / 200)
        for event in pygame.event.get():
            if verifyWinner('X'):
                print("确认X胜利")
                player = 'X'
                previewImg = previewCrossImg
            if verifyWinner('O'):
                print("确认O胜利")
                player = 'X'
                previewImg = previewCrossImg
            if event.type == pygame.QUIT:
                resetGame()
                running = False
            elif isBoardFull():
                ctypes.windll.user32.MessageBoxW(0, '平局', '提示', 0)
                resetBoard()
            elif gameMode == 1 and player != my:
                computerMove(player)
                drawBoard()
                pygame.display.update()
                # if verifyWinner(player):
                #     player = 'X'
                #     previewImg = previewCrossImg
                # else:
                #     player, previewImg = updatePlayer(player)
                if verifyWinner(player):
                    player = 'X'
                    previewImg = previewCrossImg
                else:
                    player, previewImg = updatePlayer(player)
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if gameMode != 2:
                    if row < 3 and col < 3 and board[row][col] == '':
                        # send_row = row
                        # send_col = col
                        playerMove(player, row, col)
                        drawBoard()
                        Send_Flag = 1
                        time.sleep(0.5)
                        if verifyWinner('X'):
                            player = 'X'
                            previewImg = previewCrossImg
                        else :
                            player, previewImg = updatePlayer(player)
                if gameMode == 2:
                    if row < 3 and col < 3 and board[row][col] == '':
                        print("Current_Player", Current_Player)
                    if row < 3 and col < 3 and board[row][col] == '' and Current_Player == 'X':#自己的回合鼠标才能点击
                        send_row = row
                        send_col = col
                        playerMove('X', row, col)
                        drawBoard()
                        Current_Player = 'O'#下完换对方
                        previewImg = previewCircleImg
                        Send_Flag = 1
                        print("I am going to Send message X")
                        time.sleep(0.5)
                        Receive_Flag = 1
                        print("I am waiting for O message")
                    # else:
                    #         Receive_Flag = 1
                if 550 < mouse[0] < 582 and 610 < mouse[1] < 642:
                        resetGame()
                        # time.sleep(0.5)


        screen.fill(background_color)
        drawBoard()
        drawBottomMenu(mouse)
        if row < 3 and col < 3:
            visualizeMove(row, col, previewImg)
        pygame.display.update()


def choose():
    player = None
    running = True
    while running:
        mouse = pygame.mouse.get_pos()
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if crossImg_rect.collidepoint((mouse[0], mouse[1])):
                    player = 'X'
                    running = False
                elif circleImg_rect.collidepoint((mouse[0], mouse[1])):
                    player = 'O'
                    running = False
        screen.blit(crossImg, (80, 300))
        screen.blit(circleImg, (340, 300))
        screen.blit(chooseImg, (8, 25))
        pygame.display.update()
    return player


def drawBoard():
    # 画棋子
    for row in range(3):
        for col in range(3):
            pos = (row * 200 + 12, col * 200 + 12)
            if board[row][col] == 'X':
                screen.blit(crossImg, pos)
            elif board[row][col] == 'O':
                screen.blit(circleImg, pos)
    # 画网格
    width = 10
    color = dark_grey
    pygame.draw.line(screen, color, (200, 0), (200, 600), width)
    pygame.draw.line(screen, color, (400, 0), (400, 600), width)
    pygame.draw.line(screen, color, (0, 200), (600, 200), width)
    pygame.draw.line(screen, color, (0, 400), (600, 400), width)
    # 画边框
    pygame.draw.rect(screen, color, (0, 0, 10, 600))
    pygame.draw.rect(screen, color, (0, 0, 600, 10))
    pygame.draw.rect(screen, color, (590, 0, 10, 600))


def drawBottomMenu(mouse):
    pygame.draw.rect(screen, dark_grey, (0, 600, 600, 100))
    pygame.draw.rect(screen, light_grey, (10, 610, 580, 80))
    screen.blit(restartImg, (550, 610))
    # Hover animation
    if 550 < mouse[0] < 582 and 610 < mouse[1] < 642:
        screen.blit(restartHoveredImg, (548, 608))
    screen.blit(X_score, (200, 610))
    screen.blit(O_score, (370, 610))
    scoreboard = font.render(': %d x %d :' % (score['X'], score['O']), True, background_color, light_grey)
    screen.blit(scoreboard, (244, 610))


def visualizeMove(row, col, previewImg):
    if board[row][col] == '':
        screen.blit(previewImg, (row * 200 + 12, col * 200 + 12))


def playerMove(player, row, col):
    board[row][col] = player

def CounterMove(row, col):
    board[row][col] = "O"


def computerMove(player):
    bestScore = float('inf')
    for row in range(3):
        for col in range(3):
            if board[row][col] == '':
                board[row][col] = 'O'
                score = minimax(board, 'X')
                board[row][col] = ''
                if score < bestScore:
                    bestScore = score
                    bestMove = (row, col)
    board[bestMove[0]][bestMove[1]] = player


scores = {'X': 1, 'O': -1, 'tie': 0}


def minimax(board, cur_player):
    if isWinner('X'):
        return scores['X']
    elif isWinner('O'):
        return scores['O']
    elif isBoardFull():
        return scores['tie']
    if cur_player == 'X':
        bestScore = float('-inf')
        nextPlayer = 'O'
        minORmax = max
    else:
        bestScore = float('inf')
        nextPlayer = 'X'
        minORmax = min
    for row in range(3):
        for col in range(3):
            if board[row][col] == '':
                board[row][col] = cur_player
                score = minimax(board, nextPlayer)
                board[row][col] = ''
                bestScore = minORmax(score, bestScore)
            if bestScore == scores[cur_player]:
                return bestScore
    return bestScore


def updatePlayer(player):
    if player == 'X':
        newPlayer = 'O'
        previewImg = previewCircleImg
    else:
        newPlayer = 'X'
        previewImg = previewCrossImg
    return newPlayer, previewImg



def isWinner(player):
    return ((board[0][0] == player and board[0][1] == player and board[0][2] == player) or
            (board[1][0] == player and board[1][1] == player and board[1][2] == player) or
            (board[2][0] == player and board[2][1] == player and board[2][2] == player) or
            (board[0][0] == player and board[1][0] == player and board[2][0] == player) or
            (board[0][1] == player and board[1][1] == player and board[2][1] == player) or
            (board[0][2] == player and board[1][2] == player and board[2][2] == player) or
            (board[0][0] == player and board[1][1] == player and board[2][2] == player) or
            (board[0][2] == player and board[1][1] == player and board[2][0] == player))


def verifyWinner(player):
    global Send_Flag, Receive_Flag, Current_Player,dataSocket,gameMode,previewImg
    if isWinner(player):
        # dataSocket.close()
        # dataSocket, addr = listenSocket.accept()
        print(player, "win")
        if gameMode == 2:
            print("I have turn current_player to X")
            Current_Player = 'X'  # X先下棋
            previewImg = previewCrossImg
            if player == 'O':
                toSend = 'Over'
                dataSocket.send(toSend.encode())
                print("send_meseage:",toSend)
                Send_Flag = 0
                Receive_Flag = 0  ##一开始不发送也不接受，主机

        score[player] += 1
        ctypes.windll.user32.MessageBoxW(0, player + ' 获胜！', '提示', 0)
        resetBoard()
        return True
    return False


def isBoardFull():
    for i in range(3):
        for j in range(3):
            if board[i][j] == '':
                return False
    return True


def resetBoard():
    for i in range(3):
        for j in range(3):
            board[i][j] = ''

def Common_Reset():##对方刷新引起的刷新
    global Send_Flag,Receive_Flag,gameMode,Current_Player,previewImg,dataSocket
    resetBoard()
    score['X'] = 0
    score['O'] = 0
    if gameMode == 2:
        Send_Flag = 0
        Receive_Flag = 0
        Current_Player = 'X'
        print("I have turn the picture to Cross")
        previewImg = previewCrossImg
def resetGame():
    global Send_Flag,Receive_Flag,gameMode,Current_Player,previewImg,dataSocket
    resetBoard()
    score['X'] = 0
    score['O'] = 0
    if gameMode == 2:
        Send_Flag = 0
        Receive_Flag = 0
        Current_Player = 'X'
        print("I have turn the picture to Cross")
        previewImg = previewCrossImg
        if Current_Player == 'X':##客户端在等消息
            toSend ="Reset"
            print("toSend.................",toSend)
            dataSocket.send(toSend.encode())
            time.sleep(0.3)

global i
i = 0
def TCP_Server():
    global send_row, send_col ,Send_Flag,row, col,Receive_Flag,i,Current_Player,previewImg
    while True:
        if Receive_Flag == 1:
            print("waiting for receiving...........")
            recved = dataSocket.recv(BUFLEN)
            if  not recved:
                break
            # 打印读取的信息
                print("receive,....",recved)
                print("not yet received.....")
            rec = recved.decode()
            print("receive ,", rec)
            if rec == "Over" :
                Send_Flag = 0
                Receive_Flag = 0
            elif rec == "Reset":
                Common_Reset()
            else:
                Receive_Flag = 0
                previewImg = previewCrossImg
                print(recved.decode())
                print('rec......', rec)
                counter_row = int(rec[1])
                counter_col = int(rec[3])
                board[counter_row][counter_col] = "O"
                drawBoard()
                Current_Player = 'X'##收到对面信息后回到主场
                pygame.display.update()

        if Send_Flag == 1:
            # print()
            toSend = "r"+str(send_row)+"c"+str(send_col)
            print(" toSend ", toSend)
            dataSocket.send(toSend.encode())
            Send_Flag = 0
            # time.sleep(0.5)



server_thread = threading.Thread(target = TCP_Server )
server_thread.start()
menu()
dataSocket.close()
listenSocket.close()
```

#### 客户端

```python
import pygame
import ctypes
#  === TCP 客户端程序 client.py ===
import time
from socket import *
import threading
IP = '127.0.0.1'
SERVER_PORT = 50000
BUFLEN = 1024

# 实例化一个socket对象，指明协议
dataSocket = socket(AF_INET, SOCK_STREAM)
global Send_Flag,Receive_Flag,current_player,previewImg,gameMode
Send_Flag = 0
Receive_Flag = 1
current_player = 'X'#服务端先下
gameMode = 0
# 连接服务端socket
dataSocket.connect((IP, SERVER_PORT))
# 初始化 pygame
pygame.init()

# 定义颜色
blue = (78, 140, 243)
light_blue = (100, 100, 255)
red = (242, 89, 97)
light_red = (255, 100, 100)
dark_grey = (85, 85, 85)
light_grey = (100, 100, 100)
background_color = (225, 225, 225)

# 创建窗口
screen = pygame.display.set_mode((600, 800))
pygame.display.set_caption('井字棋-客户端')

# 游戏图片
crossImg = pygame.image.load('Images/crossImg.png')
crossImg_rect = crossImg.get_rect()
crossImg_rect.center = (200, 300)
circleImg = pygame.image.load('Images/circleImg.png')
circleImg_rect = crossImg.get_rect()
circleImg_rect.center = (400, 300)
previewCrossImg = pygame.image.load('Images/prev_crossImg.png')
previewCircleImg = pygame.image.load('Images/prev_circleImg.png')
previewImg = previewCrossImg
# 按钮图片
restartImg = pygame.image.load('Images/restart.png')
restartHoveredImg = pygame.image.load('Images/restart_hovered.png')

# 定义棋盘
board = [['', '', ''],
         ['', '', ''],
         ['', '', '']]

# 定义计分板
score = {'X': 0, 'O': 0}
font = pygame.font.Font('freesansbold.ttf', 32)
X_score = pygame.image.load('Images/X_scoreImg.png')
O_score = pygame.image.load('Images/O_scoreImg.png')

# 菜单图片
buttom1 = pygame.image.load('Images/button1Img.png')
buttom1_rect = buttom1.get_rect()
buttom1_rect.center = (300, 312)
buttom2 = pygame.image.load('Images/button2Img.png')
buttom2_rect = buttom2.get_rect()
buttom2_rect.center = (300, 472)
buttom3 = pygame.image.load('Images/button3Img.png')
buttom3_rect = buttom3.get_rect()
buttom3_rect.center = (300, 632)
logo = pygame.image.load('Images/logo.png')

# 选择菜单图片
chooseImg = pygame.image.load('Images/choose.png')


def menu():
    global gameMode
    running = True
    while running:
        screen.fill(background_color)
        mx, my = pygame.mouse.get_pos()
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if buttom1_rect.collidepoint((mx, my)):
                    gameMode= 0
                    game(0, 'X')
                elif buttom2_rect.collidepoint((mx, my)):
                    player = choose()
                    if player is not None:
                        gameMode= 1
                        game(1, player)
                elif buttom3_rect.collidepoint((mx, my)):
                    gameMode = 2
                    game(2, 'O')
        screen.blit(logo, (8, 25))
        screen.blit(buttom1, (100, 250))
        screen.blit(buttom2, (100, 410))
        screen.blit(buttom3, (100, 570))
        pygame.display.update()


def game(gameMode, player):
    global send_row, send_col, Send_Flag, Receive_Flag,row, col,current_player,previewImg
    my = player
    # player = current_player
    running = True
    if gameMode == 2:
        previewImg = previewCrossImg  # 服务端先下
    else:
        previewImg = previewCircleImg

    while running:
        mouse = pygame.mouse.get_pos()
        row, col = int(mouse[0] / 200), int(mouse[1] / 200)
        for event in pygame.event.get():
            if verifyWinner('O'):
                # player = 'O'
                # previewImg = previewCrossImg
                 pass
            if verifyWinner('X'):
                # player = 'X'
                # previewImg = previewCrossImg
                pass
            if event.type == pygame.QUIT:
                resetGame()
                running = False
            elif isBoardFull():
                ctypes.windll.user32.MessageBoxW(0, '平局', '提示', 0)
                resetBoard()
            elif gameMode == 1 and player != my:
                computerMove(player)
                drawBoard()
                pygame.display.update()
                if verifyWinner(player):
                    player = 'O'
                    previewImg = previewCrossImg
                else:
                    player, previewImg = updatePlayer(player)
            # elif gameMode == 2 and player != my:
            #     CounterMove(player)
            #     drawBoard()
            #     pygame.display.update()
            #     if verifyWinner(player):
            #         player = 'O'
            #         previewImg = previewCrossImg
            #     else:
            #         player, previewImg = updatePlayer(player)
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if gameMode != 2:
                    if row < 3 and col < 3 and board[row][col] == '':
                        send_row = row
                        send_col = col
                        playerMove(player, row, col)
                        drawBoard()
                        # Send_Flag = 1
                        # time.sleep(0.5)
                        if verifyWinner('O'):
                            player = 'X'
                            previewImg = previewCrossImg
                        else :
                            player, previewImg = updatePlayer(player)
                    #
                    #     else:
                    #         Receive_Flag = 1
                    # elif 550 < mouse[0] < 582 and 610 < mouse[1] < 642:
                    #     resetGame()
                if gameMode == 2:
                    if row < 3 and col < 3 and board[row][col] == '':
                        print("Current_Player", current_player)
                    if row < 3 and col < 3 and board[row][col] == '' and current_player == 'O':#自己的回合鼠标才能点击
                        send_row = row
                        send_col = col
                        playerMove('O', row, col)
                        drawBoard()
                        current_player = 'X'#下完换对方
                        previewImg = previewCrossImg
                        Send_Flag = 1
                        print("I am going to send O message")
                        time.sleep(0.5)
                        Receive_Flag = 1
                        print("I am wating for message")
                        # if verifyWinner(player):
                        #     player = 'O'
                        #     previewImg = previewCrossImg
                        # elif gameMode != 2:
                        #
                    # else:
                    #         Receive_Flag = 1
                if 550 < mouse[0] < 582 and 610 < mouse[1] < 642:
                        resetGame()
                        time.sleep(0.5)
        screen.fill(background_color)
        drawBoard()
        drawBottomMenu(mouse)
        if row < 3 and col < 3:
            visualizeMove(row, col, previewImg)
        pygame.display.update()


def choose():
    player = None
    running = True
    while running:
        mouse = pygame.mouse.get_pos()
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if crossImg_rect.collidepoint((mouse[0], mouse[1])):
                    player = 'X'
                    running = False
                elif circleImg_rect.collidepoint((mouse[0], mouse[1])):
                    player = 'O'
                    running = False
        screen.blit(crossImg, (80, 300))
        screen.blit(circleImg, (340, 300))
        screen.blit(chooseImg, (8, 25))
        pygame.display.update()
    return player


def drawBoard():
    # 画棋子
    for row in range(3):
        for col in range(3):
            pos = (row * 200 + 12, col * 200 + 12)
            if board[row][col] == 'X':
                screen.blit(crossImg, pos)
            elif board[row][col] == 'O':
                screen.blit(circleImg, pos)
    # 画网格
    width = 10
    color = dark_grey
    pygame.draw.line(screen, color, (200, 0), (200, 600), width)
    pygame.draw.line(screen, color, (400, 0), (400, 600), width)
    pygame.draw.line(screen, color, (0, 200), (600, 200), width)
    pygame.draw.line(screen, color, (0, 400), (600, 400), width)
    # 画边框
    pygame.draw.rect(screen, color, (0, 0, 10, 600))
    pygame.draw.rect(screen, color, (0, 0, 600, 10))
    pygame.draw.rect(screen, color, (590, 0, 10, 600))


def drawBottomMenu(mouse):
    pygame.draw.rect(screen, dark_grey, (0, 600, 600, 100))
    pygame.draw.rect(screen, light_grey, (10, 610, 580, 80))
    screen.blit(restartImg, (550, 610))
    # Hover animation
    if 550 < mouse[0] < 582 and 610 < mouse[1] < 642:
        screen.blit(restartHoveredImg, (548, 608))
    screen.blit(X_score, (200, 610))
    screen.blit(O_score, (370, 610))
    scoreboard = font.render(': %d x %d :' % (score['X'], score['O']), True, background_color, light_grey)
    screen.blit(scoreboard, (244, 610))


def visualizeMove(row, col, previewImg):
    if board[row][col] == '':
        screen.blit(previewImg, (row * 200 + 12, col * 200 + 12))


def playerMove(player, row, col):
    board[row][col] = player


def computerMove(player):
    bestScore = float('inf')
    for row in range(3):
        for col in range(3):
            if board[row][col] == '':
                board[row][col] = 'O'
                score = minimax(board, 'X')
                board[row][col] = ''
                if score < bestScore:
                    bestScore = score
                    bestMove = (row, col)
    board[bestMove[0]][bestMove[1]] = player


scores = {'X': 1, 'O': -1, 'tie': 0}


def minimax(board, cur_player):
    if isWinner('X'):
        return scores['X']
    elif isWinner('O'):
        return scores['O']
    elif isBoardFull():
        return scores['tie']
    if cur_player == 'X':
        bestScore = float('-inf')
        nextPlayer = 'O'
        minORmax = max
    else:
        bestScore = float('inf')
        nextPlayer = 'X'
        minORmax = min
    for row in range(3):
        for col in range(3):
            if board[row][col] == '':
                board[row][col] = cur_player
                score = minimax(board, nextPlayer)
                board[row][col] = ''
                bestScore = minORmax(score, bestScore)
            if bestScore == scores[cur_player]:
                return bestScore
    return bestScore


def updatePlayer(player):
    if player == 'X':
        newPlayer = 'O'
        previewImg = previewCircleImg
    else:
        newPlayer = 'X'
        previewImg = previewCrossImg
    return newPlayer, previewImg



def isWinner(player):
    return ((board[0][0] == player and board[0][1] == player and board[0][2] == player) or
            (board[1][0] == player and board[1][1] == player and board[1][2] == player) or
            (board[2][0] == player and board[2][1] == player and board[2][2] == player) or
            (board[0][0] == player and board[1][0] == player and board[2][0] == player) or
            (board[0][1] == player and board[1][1] == player and board[2][1] == player) or
            (board[0][2] == player and board[1][2] == player and board[2][2] == player) or
            (board[0][0] == player and board[1][1] == player and board[2][2] == player) or
            (board[0][2] == player and board[1][1] == player and board[2][0] == player))


def verifyWinner(player):
    global  Send_Flag,Receive_Flag,current_player,dataSocket,previewImg,gameMode
    if isWinner(player):
        print(player, "win")
        if gameMode ==2:
            previewImg = previewCrossImg
            current_player = 'X'  # 服务端先下
            if player == 'X':
                toSend = 'Over'
                dataSocket.send(toSend.encode())
                print("send_meseage:", toSend)
                Send_Flag = 0
                Receive_Flag = 1
        score[player] += 1
        ctypes.windll.user32.MessageBoxW(0, player + ' 获胜！', '提示', 0)
        resetBoard()
        return True
    return False


def isBoardFull():
    for i in range(3):
        for j in range(3):
            if board[i][j] == '':
                return False
    return True


def resetBoard():
    for i in range(3):
        for j in range(3):
            board[i][j] = ''

def Common_Reset():##对方刷新引起的刷新，被动刷新
    global Send_Flag,Receive_Flag,gameMode,current_player,previewImg,dataSocket
    resetBoard()
    score['X'] = 0
    score['O'] = 0
    if gameMode == 2:
        Send_Flag = 0
        Receive_Flag = 1
        current_player = 'X'
        print("I have turn the picture to Cross")
        previewImg = previewCrossImg
def resetGame():##主动刷新
    global Send_Flag,Receive_Flag,current_player,previewImg,dataSocket
    if gameMode == 2:
        if current_player == 'O':##主机在等客户端消息
            toSend= "Reset"
            print("toSend............",toSend)
            dataSocket.send(toSend.encode())
            time.sleep(0.3)
        Send_Flag = 0
        Receive_Flag = 1
        current_player = 'X'
        previewImg = previewCrossImg

    resetBoard()
    score['X'] = 0
    score['O'] = 0
global i
i = 0
def TCP_Client():
    global send_row, send_col ,Send_Flag,row, col,Receive_Flag, i, current_player, previewImg
    while True:

        # 等待接收服务端的消息
        if Send_Flag == 1:
            print("Sending..........")
            toSend = "r"+str(send_row)+"c"+str(send_col)
            print(" toSend ", toSend)
            dataSocket.send(toSend.encode())
            Send_Flag = 0
            # time.sleep(0.5)

        # 如果返回空bytes，表示对方关闭了连接

        if Receive_Flag == 1:
            print("waiting for receiving...........")
            recved = dataSocket.recv(BUFLEN)
            rec = recved.decode()
            print("receive ,", rec)
            if rec == "Over" :
                Send_Flag = 0
                Receive_Flag = 1#收到结束提醒后重新开始，仍然是接收状态

                # break##用来退出阻塞
            elif rec == "Reset":
                Common_Reset()
            else:
                Receive_Flag = 0
                previewImg = previewCircleImg
                print(recved.decode())
                print('rec......', rec)
                counter_row = int(rec[1])
                counter_col = int(rec[3])
                board[counter_row][counter_col] = "X"
                drawBoard()
                current_player = 'O'  ##收到对面信息后回到主场
                pygame.display.update()





client_thread = threading.Thread(target=TCP_Client)
client_thread.start()

menu()
dataSoc
```

### 自己的协议

#### 服务端

```python
import pygame
import ctypes
# 导入socket 库
from socket import *
import threading
import time

# 主机地址为空字符串，表示绑定本机所有网络接口ip地址
# 等待客户端来连接
IP = ''
# 端口号
PORT = 50000
# 定义一次从socket缓冲区最多读入512个字节数据
BUFLEN = 512

# 实例化一个socket对象
# 参数 AF_INET 表示该socket网络层使用IP协议
# 参数 SOCK_STREAM 表示该socket传输层使用TCP协议
listenSocket = socket(AF_INET, SOCK_STREAM)

# socket绑定地址和端口
listenSocket.bind((IP, PORT))


# 使socket处于监听状态，等待客户端的连接请求
# 参数 8 表示 最多接受多少个等待连接的客户端
listenSocket.listen(8)
print(f'服务端启动成功，在{PORT}端口等待客户端连接...')

dataSocket, addr = listenSocket.accept()
print('接受一个客户端连接:', addr)


global Send_Flag,Receive_Flag,Current_Player,If_over,previewImg,gameMode
# 初始化 pygame
pygame.init()

# 定义颜色
blue = (78, 140, 243)
light_blue = (100, 100, 255)
red = (242, 89, 97)
light_red = (255, 100, 100)
dark_grey = (85, 85, 85)
light_grey = (100, 100, 100)
background_color = (225, 225, 225)
Send_Flag = 0
Receive_Flag = 0##一开始不发送也不接受，主机
Current_Player = 'X'#X先下棋
If_over = 0
gameMode = 0
# 创建窗口
screen = pygame.display.set_mode((600, 800))
pygame.display.set_caption('井字棋')

# 游戏图片
crossImg = pygame.image.load('Images/crossImg.png')
crossImg_rect = crossImg.get_rect()
crossImg_rect.center = (200, 300)
circleImg = pygame.image.load('Images/circleImg.png')
circleImg_rect = crossImg.get_rect()
circleImg_rect.center = (400, 300)
previewCrossImg = pygame.image.load('Images/prev_crossImg.png')
previewCircleImg = pygame.image.load('Images/prev_circleImg.png')

previewImg = previewCrossImg
# 按钮图片
restartImg = pygame.image.load('Images/restart.png')
restartHoveredImg = pygame.image.load('Images/restart_hovered.png')

# 定义棋盘
board = [['', '', ''],
         ['', '', ''],
         ['', '', '']]

# 定义计分板
score = {'X': 0, 'O': 0}
font = pygame.font.Font('freesansbold.ttf', 32)
X_score = pygame.image.load('Images/X_scoreImg.png')
O_score = pygame.image.load('Images/O_scoreImg.png')

# 菜单图片
buttom1 = pygame.image.load('Images/button1Img.png')
buttom1_rect = buttom1.get_rect()
buttom1_rect.center = (300, 312)
buttom2 = pygame.image.load('Images/button2Img.png')
buttom2_rect = buttom2.get_rect()
buttom2_rect.center = (300, 472)

buttom3 = pygame.image.load('Images/button3Img.png')
buttom3_rect = buttom3.get_rect()
buttom3_rect.center = (300, 632)

logo = pygame.image.load('Images/logo.png')

# 选择菜单图片
chooseImg = pygame.image.load('Images/choose.png')


def menu():
    global gameMode
    running = True
    while running:
        screen.fill(background_color)
        mx, my = pygame.mouse.get_pos()
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if buttom1_rect.collidepoint((mx, my)):
                    game(0, 'X')
                    gameMode = 0
                elif buttom2_rect.collidepoint((mx, my)):
                    player = choose()
                    if player is not None:
                        game(1, player)
                        gameMode =1
                elif buttom3_rect.collidepoint((mx, my)):
                    gameMode = 2
                    game(2, 'X')
        screen.blit(logo, (8, 25))
        screen.blit(buttom1, (100, 250))
        screen.blit(buttom2, (100, 410))
        screen.blit(buttom3, (100, 570))
        pygame.display.update()


def game(gameMode, player):
    global send_row, send_col ,Send_Flag,row, col,Receive_Flag,Current_Player,If_over,previewImg
    my = player
    player = 'X'
    running = True
    while running:
        mouse = pygame.mouse.get_pos()
        row, col = int(mouse[0] / 200), int(mouse[1] / 200)
        for event in pygame.event.get():
            if verifyWinner('X'):
                print("确认X胜利")
                player = 'X'
                previewImg = previewCrossImg
            if verifyWinner('O'):
                print("确认O胜利")
                player = 'X'
                previewImg = previewCrossImg
            if event.type == pygame.QUIT:
                resetGame()
                running = False
            elif isBoardFull():
                ctypes.windll.user32.MessageBoxW(0, '平局', '提示', 0)
                resetBoard()
            elif gameMode == 1 and player != my:
                computerMove(player)
                drawBoard()
                pygame.display.update()
                # if verifyWinner(player):
                #     player = 'X'
                #     previewImg = previewCrossImg
                # else:
                #     player, previewImg = updatePlayer(player)
                if verifyWinner(player):
                    player = 'X'
                    previewImg = previewCrossImg
                else:
                    player, previewImg = updatePlayer(player)
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if gameMode != 2:
                    if row < 3 and col < 3 and board[row][col] == '':
                        # send_row = row
                        # send_col = col
                        playerMove(player, row, col)
                        drawBoard()
                        Send_Flag = 1
                        time.sleep(0.5)
                        if verifyWinner('X'):
                            player = 'X'
                            previewImg = previewCrossImg
                        else :
                            player, previewImg = updatePlayer(player)
                if gameMode == 2:
                    if row < 3 and col < 3 and board[row][col] == '':
                        print("Current_Player", Current_Player)
                    if row < 3 and col < 3 and board[row][col] == '' and Current_Player == 'X':#自己的回合鼠标才能点击
                        send_row = row
                        send_col = col
                        playerMove('X', row, col)
                        drawBoard()
                        Current_Player = 'O'#下完换对方
                        previewImg = previewCircleImg
                        Send_Flag = 1
                        print("I am going to Send message X")
                        time.sleep(0.5)
                        Receive_Flag = 1
                        print("I am waiting for O message")
                    # else:
                    #         Receive_Flag = 1
                if 550 < mouse[0] < 582 and 610 < mouse[1] < 642:
                        resetGame()
                        # time.sleep(0.5)


        screen.fill(background_color)
        drawBoard()
        drawBottomMenu(mouse)
        if row < 3 and col < 3:
            visualizeMove(row, col, previewImg)
        pygame.display.update()


def choose():
    player = None
    running = True
    while running:
        mouse = pygame.mouse.get_pos()
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if crossImg_rect.collidepoint((mouse[0], mouse[1])):
                    player = 'X'
                    running = False
                elif circleImg_rect.collidepoint((mouse[0], mouse[1])):
                    player = 'O'
                    running = False
        screen.blit(crossImg, (80, 300))
        screen.blit(circleImg, (340, 300))
        screen.blit(chooseImg, (8, 25))
        pygame.display.update()
    return player


def drawBoard():
    # 画棋子
    for row in range(3):
        for col in range(3):
            pos = (row * 200 + 12, col * 200 + 12)
            if board[row][col] == 'X':
                screen.blit(crossImg, pos)
            elif board[row][col] == 'O':
                screen.blit(circleImg, pos)
    # 画网格
    width = 10
    color = dark_grey
    pygame.draw.line(screen, color, (200, 0), (200, 600), width)
    pygame.draw.line(screen, color, (400, 0), (400, 600), width)
    pygame.draw.line(screen, color, (0, 200), (600, 200), width)
    pygame.draw.line(screen, color, (0, 400), (600, 400), width)
    # 画边框
    pygame.draw.rect(screen, color, (0, 0, 10, 600))
    pygame.draw.rect(screen, color, (0, 0, 600, 10))
    pygame.draw.rect(screen, color, (590, 0, 10, 600))


def drawBottomMenu(mouse):
    pygame.draw.rect(screen, dark_grey, (0, 600, 600, 100))
    pygame.draw.rect(screen, light_grey, (10, 610, 580, 80))
    screen.blit(restartImg, (550, 610))
    # Hover animation
    if 550 < mouse[0] < 582 and 610 < mouse[1] < 642:
        screen.blit(restartHoveredImg, (548, 608))
    screen.blit(X_score, (200, 610))
    screen.blit(O_score, (370, 610))
    scoreboard = font.render(': %d x %d :' % (score['X'], score['O']), True, background_color, light_grey)
    screen.blit(scoreboard, (244, 610))


def visualizeMove(row, col, previewImg):
    if board[row][col] == '':
        screen.blit(previewImg, (row * 200 + 12, col * 200 + 12))


def playerMove(player, row, col):
    board[row][col] = player

def CounterMove(row, col):
    board[row][col] = "O"


def computerMove(player):
    bestScore = float('inf')
    for row in range(3):
        for col in range(3):
            if board[row][col] == '':
                board[row][col] = 'O'
                score = minimax(board, 'X')
                board[row][col] = ''
                if score < bestScore:
                    bestScore = score
                    bestMove = (row, col)
    board[bestMove[0]][bestMove[1]] = player


scores = {'X': 1, 'O': -1, 'tie': 0}


def minimax(board, cur_player):
    if isWinner('X'):
        return scores['X']
    elif isWinner('O'):
        return scores['O']
    elif isBoardFull():
        return scores['tie']
    if cur_player == 'X':
        bestScore = float('-inf')
        nextPlayer = 'O'
        minORmax = max
    else:
        bestScore = float('inf')
        nextPlayer = 'X'
        minORmax = min
    for row in range(3):
        for col in range(3):
            if board[row][col] == '':
                board[row][col] = cur_player
                score = minimax(board, nextPlayer)
                board[row][col] = ''
                bestScore = minORmax(score, bestScore)
            if bestScore == scores[cur_player]:
                return bestScore
    return bestScore


def updatePlayer(player):
    if player == 'X':
        newPlayer = 'O'
        previewImg = previewCircleImg
    else:
        newPlayer = 'X'
        previewImg = previewCrossImg
    return newPlayer, previewImg



def isWinner(player):
    return ((board[0][0] == player and board[0][1] == player and board[0][2] == player) or
            (board[1][0] == player and board[1][1] == player and board[1][2] == player) or
            (board[2][0] == player and board[2][1] == player and board[2][2] == player) or
            (board[0][0] == player and board[1][0] == player and board[2][0] == player) or
            (board[0][1] == player and board[1][1] == player and board[2][1] == player) or
            (board[0][2] == player and board[1][2] == player and board[2][2] == player) or
            (board[0][0] == player and board[1][1] == player and board[2][2] == player) or
            (board[0][2] == player and board[1][1] == player and board[2][0] == player))


def verifyWinner(player):
    global Send_Flag, Receive_Flag, Current_Player,dataSocket,gameMode,previewImg
    if isWinner(player):
        # dataSocket.close()
        # dataSocket, addr = listenSocket.accept()
        print(player, "win")
        if gameMode == 2:
            print("I have turn current_player to X")
            Current_Player = 'X'  # X先下棋
            previewImg = previewCrossImg
            if player == 'O':
                toSend = 'Over'
                dataSocket.send(toSend.encode())
                print("send_meseage:",toSend)
                Send_Flag = 0
                Receive_Flag = 0  ##一开始不发送也不接受，主机

        score[player] += 1
        ctypes.windll.user32.MessageBoxW(0, player + ' 获胜！', '提示', 0)
        resetBoard()
        return True
    return False


def isBoardFull():
    for i in range(3):
        for j in range(3):
            if board[i][j] == '':
                return False
    return True


def resetBoard():
    for i in range(3):
        for j in range(3):
            board[i][j] = ''

def Common_Reset():##对方刷新引起的刷新
    global Send_Flag,Receive_Flag,gameMode,Current_Player,previewImg,dataSocket
    resetBoard()
    score['X'] = 0
    score['O'] = 0
    if gameMode == 2:
        Send_Flag = 0
        Receive_Flag = 0
        Current_Player = 'X'
        print("I have turn the picture to Cross")
        previewImg = previewCrossImg
def resetGame():
    global Send_Flag,Receive_Flag,gameMode,Current_Player,previewImg,dataSocket
    resetBoard()
    score['X'] = 0
    score['O'] = 0
    if gameMode == 2:
        Send_Flag = 0
        Receive_Flag = 0
        Current_Player = 'X'
        print("I have turn the picture to Cross")
        previewImg = previewCrossImg
        if Current_Player == 'X':##客户端在等消息
            toSend ="Reset"
            print("toSend.................",toSend)
            dataSocket.send(toSend.encode())
            time.sleep(0.3)

global i
i = 0
def TCP_Server():
    global send_row, send_col ,Send_Flag,row, col,Receive_Flag,i,Current_Player,previewImg
    while True:
        if Receive_Flag == 1:
            print("waiting for receiving...........")
            recved = dataSocket.recv(BUFLEN)
            if  not recved:
                break
            # 打印读取的信息
                print("receive,....",recved)
                print("not yet received.....")
            rec = recved.decode()
            print("receive ,", rec)
            if rec == "Over" :
                Send_Flag = 0
                Receive_Flag = 0
            elif rec == "Reset":
                Common_Reset()
            elif rec == "nodata":
                # print("i am in my free time.............")
                 pass
            else:
                try:
                    previewImg = previewCrossImg
                    print(recved.decode())
                    print('rec......', rec)
                    counter_row = int(rec[1])
                    counter_col = int(rec[3])
                    board[counter_row][counter_col] = "O"
                    drawBoard()
                    Current_Player = 'X'##收到对面信息后回到主场
                    pygame.display.update()
                    Receive_Flag = 0
                except:
                    Receive_Flag = 1
                    print("another")
        # Send_Flag = 1
        if Send_Flag == 1:
            # print()
            toSend = "r"+str(send_row)+"c"+str(send_col)
            print(" toSend ", toSend)
            dataSocket.send(toSend.encode())
            Send_Flag = 0
            # time.sleep(0.5)
            # dataSocket.close()
        if Send_Flag == 0 and Receive_Flag == 0 :##无操作情况发送空闲数据
            # print("Sending..........")
            toSend = "nodata"
            # print(" toSend ", toSend)
            dataSocket.send(toSend.encode())
            time.sleep(0.3)


server_thread = threading.Thread(target = TCP_Server )
server_thread.start()
menu()
dataSocket.close()
listenSocket.close()
```

#### 客户端

```python
import pygame
import ctypes
#  === TCP 客户端程序 client.py ===
import time
from socket import *
import threading
IP = '127.0.0.1'
SERVER_PORT = 50000
BUFLEN = 1024

# 实例化一个socket对象，指明协议
dataSocket = socket(AF_INET, SOCK_STREAM)
global Send_Flag,Receive_Flag,current_player,previewImg,gameMode
Send_Flag = 0
Receive_Flag = 1
current_player = 'X'#服务端先下
gameMode = 0
# 连接服务端socket
dataSocket.connect((IP, SERVER_PORT))
# 初始化 pygame
pygame.init()

# 定义颜色
blue = (78, 140, 243)
light_blue = (100, 100, 255)
red = (242, 89, 97)
light_red = (255, 100, 100)
dark_grey = (85, 85, 85)
light_grey = (100, 100, 100)
background_color = (225, 225, 225)

# 创建窗口
screen = pygame.display.set_mode((600, 800))
pygame.display.set_caption('井字棋-客户端')

# 游戏图片
crossImg = pygame.image.load('Images/crossImg.png')
crossImg_rect = crossImg.get_rect()
crossImg_rect.center = (200, 300)
circleImg = pygame.image.load('Images/circleImg.png')
circleImg_rect = crossImg.get_rect()
circleImg_rect.center = (400, 300)
previewCrossImg = pygame.image.load('Images/prev_crossImg.png')
previewCircleImg = pygame.image.load('Images/prev_circleImg.png')
previewImg = previewCrossImg
# 按钮图片
restartImg = pygame.image.load('Images/restart.png')
restartHoveredImg = pygame.image.load('Images/restart_hovered.png')

# 定义棋盘
board = [['', '', ''],
         ['', '', ''],
         ['', '', '']]

# 定义计分板
score = {'X': 0, 'O': 0}
font = pygame.font.Font('freesansbold.ttf', 32)
X_score = pygame.image.load('Images/X_scoreImg.png')
O_score = pygame.image.load('Images/O_scoreImg.png')

# 菜单图片
buttom1 = pygame.image.load('Images/button1Img.png')
buttom1_rect = buttom1.get_rect()
buttom1_rect.center = (300, 312)
buttom2 = pygame.image.load('Images/button2Img.png')
buttom2_rect = buttom2.get_rect()
buttom2_rect.center = (300, 472)
buttom3 = pygame.image.load('Images/button3Img.png')
buttom3_rect = buttom3.get_rect()
buttom3_rect.center = (300, 632)
logo = pygame.image.load('Images/logo.png')

# 选择菜单图片
chooseImg = pygame.image.load('Images/choose.png')


def menu():
    global gameMode
    running = True
    while running:
        screen.fill(background_color)
        mx, my = pygame.mouse.get_pos()
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if buttom1_rect.collidepoint((mx, my)):
                    gameMode= 0
                    game(0, 'X')
                elif buttom2_rect.collidepoint((mx, my)):
                    player = choose()
                    if player is not None:
                        gameMode= 1
                        game(1, player)
                elif buttom3_rect.collidepoint((mx, my)):
                    gameMode = 2
                    game(2, 'O')
        screen.blit(logo, (8, 25))
        screen.blit(buttom1, (100, 250))
        screen.blit(buttom2, (100, 410))
        screen.blit(buttom3, (100, 570))
        pygame.display.update()


def game(gameMode, player):
    global send_row, send_col, Send_Flag, Receive_Flag,row, col,current_player,previewImg
    my = player
    # player = current_player
    running = True
    if gameMode == 2:
        previewImg = previewCrossImg  # 服务端先下
    else:
        previewImg = previewCircleImg

    while running:
        mouse = pygame.mouse.get_pos()
        row, col = int(mouse[0] / 200), int(mouse[1] / 200)
        for event in pygame.event.get():
            if verifyWinner('O'):
                # player = 'O'
                # previewImg = previewCrossImg
                 pass
            if verifyWinner('X'):
                # player = 'X'
                # previewImg = previewCrossImg
                pass
            if event.type == pygame.QUIT:
                resetGame()
                running = False
            elif isBoardFull():
                ctypes.windll.user32.MessageBoxW(0, '平局', '提示', 0)
                resetBoard()
            elif gameMode == 1 and player != my:
                computerMove(player)
                drawBoard()
                pygame.display.update()
                if verifyWinner(player):
                    player = 'O'
                    previewImg = previewCrossImg
                else:
                    player, previewImg = updatePlayer(player)
            # elif gameMode == 2 and player != my:
            #     CounterMove(player)
            #     drawBoard()
            #     pygame.display.update()
            #     if verifyWinner(player):
            #         player = 'O'
            #         previewImg = previewCrossImg
            #     else:
            #         player, previewImg = updatePlayer(player)
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if gameMode != 2:
                    if row < 3 and col < 3 and board[row][col] == '':
                        send_row = row
                        send_col = col
                        playerMove(player, row, col)
                        drawBoard()
                        # Send_Flag = 1
                        # time.sleep(0.5)
                        if verifyWinner('O'):
                            player = 'X'
                            previewImg = previewCrossImg
                        else :
                            player, previewImg = updatePlayer(player)
                    #
                    #     else:
                    #         Receive_Flag = 1
                    # elif 550 < mouse[0] < 582 and 610 < mouse[1] < 642:
                    #     resetGame()
                if gameMode == 2:
                    if row < 3 and col < 3 and board[row][col] == '':
                        print("Current_Player", current_player)
                    if row < 3 and col < 3 and board[row][col] == '' and current_player == 'O':#自己的回合鼠标才能点击
                        send_row = row
                        send_col = col
                        playerMove('O', row, col)
                        drawBoard()
                        current_player = 'X'#下完换对方
                        previewImg = previewCrossImg
                        Send_Flag = 1
                        print("I am going to send O message")
                        time.sleep(0.5)
                        Receive_Flag = 1
                        print("I am wating for message")
                        # if verifyWinner(player):
                        #     player = 'O'
                        #     previewImg = previewCrossImg
                        # elif gameMode != 2:
                        #
                    # else:
                    #         Receive_Flag = 1
                if 550 < mouse[0] < 582 and 610 < mouse[1] < 642:
                        resetGame()
                        time.sleep(0.5)
        screen.fill(background_color)
        drawBoard()
        drawBottomMenu(mouse)
        if row < 3 and col < 3:
            visualizeMove(row, col, previewImg)
        pygame.display.update()


def choose():
    player = None
    running = True
    while running:
        mouse = pygame.mouse.get_pos()
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if crossImg_rect.collidepoint((mouse[0], mouse[1])):
                    player = 'X'
                    running = False
                elif circleImg_rect.collidepoint((mouse[0], mouse[1])):
                    player = 'O'
                    running = False
        screen.blit(crossImg, (80, 300))
        screen.blit(circleImg, (340, 300))
        screen.blit(chooseImg, (8, 25))
        pygame.display.update()
    return player


def drawBoard():
    # 画棋子
    for row in range(3):
        for col in range(3):
            pos = (row * 200 + 12, col * 200 + 12)
            if board[row][col] == 'X':
                screen.blit(crossImg, pos)
            elif board[row][col] == 'O':
                screen.blit(circleImg, pos)
    # 画网格
    width = 10
    color = dark_grey
    pygame.draw.line(screen, color, (200, 0), (200, 600), width)
    pygame.draw.line(screen, color, (400, 0), (400, 600), width)
    pygame.draw.line(screen, color, (0, 200), (600, 200), width)
    pygame.draw.line(screen, color, (0, 400), (600, 400), width)
    # 画边框
    pygame.draw.rect(screen, color, (0, 0, 10, 600))
    pygame.draw.rect(screen, color, (0, 0, 600, 10))
    pygame.draw.rect(screen, color, (590, 0, 10, 600))


def drawBottomMenu(mouse):
    pygame.draw.rect(screen, dark_grey, (0, 600, 600, 100))
    pygame.draw.rect(screen, light_grey, (10, 610, 580, 80))
    screen.blit(restartImg, (550, 610))
    # Hover animation
    if 550 < mouse[0] < 582 and 610 < mouse[1] < 642:
        screen.blit(restartHoveredImg, (548, 608))
    screen.blit(X_score, (200, 610))
    screen.blit(O_score, (370, 610))
    scoreboard = font.render(': %d x %d :' % (score['X'], score['O']), True, background_color, light_grey)
    screen.blit(scoreboard, (244, 610))


def visualizeMove(row, col, previewImg):
    if board[row][col] == '':
        screen.blit(previewImg, (row * 200 + 12, col * 200 + 12))


def playerMove(player, row, col):
    board[row][col] = player


def computerMove(player):
    bestScore = float('inf')
    for row in range(3):
        for col in range(3):
            if board[row][col] == '':
                board[row][col] = 'O'
                score = minimax(board, 'X')
                board[row][col] = ''
                if score < bestScore:
                    bestScore = score
                    bestMove = (row, col)
    board[bestMove[0]][bestMove[1]] = player


scores = {'X': 1, 'O': -1, 'tie': 0}


def minimax(board, cur_player):
    if isWinner('X'):
        return scores['X']
    elif isWinner('O'):
        return scores['O']
    elif isBoardFull():
        return scores['tie']
    if cur_player == 'X':
        bestScore = float('-inf')
        nextPlayer = 'O'
        minORmax = max
    else:
        bestScore = float('inf')
        nextPlayer = 'X'
        minORmax = min
    for row in range(3):
        for col in range(3):
            if board[row][col] == '':
                board[row][col] = cur_player
                score = minimax(board, nextPlayer)
                board[row][col] = ''
                bestScore = minORmax(score, bestScore)
            if bestScore == scores[cur_player]:
                return bestScore
    return bestScore


def updatePlayer(player):
    if player == 'X':
        newPlayer = 'O'
        previewImg = previewCircleImg
    else:
        newPlayer = 'X'
        previewImg = previewCrossImg
    return newPlayer, previewImg



def isWinner(player):
    return ((board[0][0] == player and board[0][1] == player and board[0][2] == player) or
            (board[1][0] == player and board[1][1] == player and board[1][2] == player) or
            (board[2][0] == player and board[2][1] == player and board[2][2] == player) or
            (board[0][0] == player and board[1][0] == player and board[2][0] == player) or
            (board[0][1] == player and board[1][1] == player and board[2][1] == player) or
            (board[0][2] == player and board[1][2] == player and board[2][2] == player) or
            (board[0][0] == player and board[1][1] == player and board[2][2] == player) or
            (board[0][2] == player and board[1][1] == player and board[2][0] == player))


def verifyWinner(player):
    global  Send_Flag,Receive_Flag,current_player,dataSocket,previewImg,gameMode
    if isWinner(player):
        print(player, "win")
        if gameMode ==2:
            previewImg = previewCrossImg
            current_player = 'X'  # 服务端先下
            if player == 'X':
                toSend = 'Over'
                dataSocket.send(toSend.encode())
                print("send_meseage:", toSend)
                Send_Flag = 0
                Receive_Flag = 1
        score[player] += 1
        ctypes.windll.user32.MessageBoxW(0, player + ' 获胜！', '提示', 0)
        resetBoard()
        return True
    return False


def isBoardFull():
    for i in range(3):
        for j in range(3):
            if board[i][j] == '':
                return False
    return True


def resetBoard():
    for i in range(3):
        for j in range(3):
            board[i][j] = ''

def Common_Reset():##对方刷新引起的刷新，被动刷新
    global Send_Flag,Receive_Flag,gameMode,current_player,previewImg,dataSocket
    resetBoard()
    score['X'] = 0
    score['O'] = 0
    if gameMode == 2:
        Send_Flag = 0
        Receive_Flag = 1
        current_player = 'X'
        print("I have turn the picture to Cross")
        previewImg = previewCrossImg
def resetGame():##主动刷新
    global Send_Flag,Receive_Flag,current_player,previewImg,dataSocket
    if gameMode == 2:
        if current_player == 'O':##主机在等客户端消息
            toSend= "Reset"
            print("toSend............",toSend)
            dataSocket.send(toSend.encode())
            time.sleep(0.3)
        Send_Flag = 0
        Receive_Flag = 1
        current_player = 'X'
        previewImg = previewCrossImg

    resetBoard()
    score['X'] = 0
    score['O'] = 0
global i
i = 0
def TCP_Client():
    global send_row, send_col ,Send_Flag,row, col,Receive_Flag, i, current_player, previewImg
    while True:
        # try:
        #     dataSocket.connect((IP, SERVER_PORT))
        # except:
        #     pass
        # 等待接收服务端的消息


        if Send_Flag == 1:
            print("Sending..........")
            toSend = "r"+str(send_row)+"c"+str(send_col)
            print(" toSend ", toSend)
            dataSocket.send(toSend.encode())
            Send_Flag = 0
            # time.sleep(0.5)

        # 如果返回空bytes，表示对方关闭了连接
        # Receive_Flag = 0
        if Receive_Flag == 1:
            print("waiting for receiving...........")
            recved = dataSocket.recv(BUFLEN)
            rec = recved.decode()
            print("receive ,", rec)
            if rec == "Over" :
                Send_Flag = 0
                Receive_Flag = 1#收到结束提醒后重新开始，仍然是接收状态

                # break##用来退出阻塞
            elif rec == "Reset":
                Common_Reset()
            elif rec == "nodata":
                # print("i am in my free time ...............client...........")
                pass
            else:
                try:
                    previewImg = previewCircleImg
                    print(recved.decode())
                    print('rec......', rec)
                    counter_row = int(rec[1])
                    counter_col = int(rec[3])
                    board[counter_row][counter_col] = "X"
                    drawBoard()
                    current_player = 'O'  ##收到对面信息后回到主场
                    pygame.display.update()
                    Receive_Flag = 0
                except:
                    Receive_Flag = 1
                    print("another ")
        # dataSocket.close()
        if Send_Flag == 0 and Receive_Flag == 0 :##无操作情况发送空闲数据
            # print("Sending..........")
            toSend = "nodata"
            # print(" toSend ", toSend)
            dataSocket.send(toSend.encode())
            time.sleep(0.3)




client_thread = threading.Thread(target=TCP_Client)
client_thread.start()

menu()
dataSoc
```

### 正则表达式传参

#### 服务端

```python
import pygame
import ctypes
# 导入socket 库
from socket import *
import threading
import time
import re

global pi_sure_flag,pi_row,pi_col,pi_flash,message,sure_flag,flash_flag,SOR

pi_sure_flag=re.compile(r'sure_f(\d)')
pi_row=re.compile(r'row(\d)')
pi_col=re.compile(r'col(\d)')
pi_flash=re.compile(r'flash(\d)')##刷新参数
message= "sure_f0 row0 col0 flash0 SenOrRec0"
sure_flag = 0
flash_flag = 0
send_row = 0
send_col = 0
SOR = 0 #0是发送
# 主机地址为空字符串，表示绑定本机所有网络接口ip地址
# 等待客户端来连接
IP = ''
# 端口号
PORT = 50000
# 定义一次从socket缓冲区最多读入512个字节数据
BUFLEN = 512

# 实例化一个socket对象
# 参数 AF_INET 表示该socket网络层使用IP协议
# 参数 SOCK_STREAM 表示该socket传输层使用TCP协议
listenSocket = socket(AF_INET, SOCK_STREAM)

# socket绑定地址和端口
listenSocket.bind((IP, PORT))


# 使socket处于监听状态，等待客户端的连接请求
# 参数 8 表示 最多接受多少个等待连接的客户端
listenSocket.listen(8)
print(f'服务端启动成功，在{PORT}端口等待客户端连接...')

dataSocket, addr = listenSocket.accept()
print('接受一个客户端连接:', addr)


global Send_Flag,Receive_Flag,Current_Player,If_over,previewImg,gameMode,Ini_FLag,Reset_Flag
# 初始化 pygame
pygame.init()

# 定义颜色
blue = (78, 140, 243)
light_blue = (100, 100, 255)
red = (242, 89, 97)
light_red = (255, 100, 100)
dark_grey = (85, 85, 85)
light_grey = (100, 100, 100)
background_color = (225, 225, 225)
Send_Flag = 0
Receive_Flag = 0##一开始不发送也不接受，主机
Current_Player = 'X'#X先下棋
If_over = 0
gameMode = 0
Ini_FLag = 1
# 创建窗口
screen = pygame.display.set_mode((600, 800))
pygame.display.set_caption('井字棋')

# 游戏图片
crossImg = pygame.image.load('Images/crossImg.png')
crossImg_rect = crossImg.get_rect()
crossImg_rect.center = (200, 300)
circleImg = pygame.image.load('Images/circleImg.png')
circleImg_rect = crossImg.get_rect()
circleImg_rect.center = (400, 300)
previewCrossImg = pygame.image.load('Images/prev_crossImg.png')
previewCircleImg = pygame.image.load('Images/prev_circleImg.png')

previewImg = previewCrossImg
# 按钮图片
restartImg = pygame.image.load('Images/restart.png')
restartHoveredImg = pygame.image.load('Images/restart_hovered.png')

# 定义棋盘
board = [['', '', ''],
         ['', '', ''],
         ['', '', '']]

# 定义计分板
score = {'X': 0, 'O': 0}
font = pygame.font.Font('freesansbold.ttf', 32)
X_score = pygame.image.load('Images/X_scoreImg.png')
O_score = pygame.image.load('Images/O_scoreImg.png')

# 菜单图片
buttom1 = pygame.image.load('Images/button1Img.png')
buttom1_rect = buttom1.get_rect()
buttom1_rect.center = (300, 312)
buttom2 = pygame.image.load('Images/button2Img.png')
buttom2_rect = buttom2.get_rect()
buttom2_rect.center = (300, 472)

buttom3 = pygame.image.load('Images/button3Img.png')
buttom3_rect = buttom3.get_rect()
buttom3_rect.center = (300, 632)

logo = pygame.image.load('Images/logo.png')

# 选择菜单图片
chooseImg = pygame.image.load('Images/choose.png')


def menu():
    global gameMode
    running = True
    while running:
        screen.fill(background_color)
        mx, my = pygame.mouse.get_pos()
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if buttom1_rect.collidepoint((mx, my)):
                    game(0, 'X')
                    gameMode = 0
                elif buttom2_rect.collidepoint((mx, my)):
                    player = choose()
                    if player is not None:
                        game(1, player)
                        gameMode =1
                elif buttom3_rect.collidepoint((mx, my)):
                    gameMode = 2
                    game(2, 'X')
        screen.blit(logo, (8, 25))
        screen.blit(buttom1, (100, 250))
        screen.blit(buttom2, (100, 410))
        screen.blit(buttom3, (100, 570))
        pygame.display.update()


def game(gameMode, player):
    global send_row, send_col ,Send_Flag,row, col,Receive_Flag,Current_Player,If_over,previewImg,message,sure_flag,flash_flag
    my = player
    player = 'X'
    running = True
    while running:
        mouse = pygame.mouse.get_pos()
        row, col = int(mouse[0] / 200), int(mouse[1] / 200)
        for event in pygame.event.get():
            if verifyWinner('X'):
                print("确认X胜利")
                player = 'X'
                previewImg = previewCrossImg
            if verifyWinner('O'):
                print("确认O胜利")
                player = 'X'
                previewImg = previewCrossImg
            if event.type == pygame.QUIT:
                resetGame()
                running = False
            elif isBoardFull():
                ctypes.windll.user32.MessageBoxW(0, '平局', '提示', 0)
                resetBoard()
            elif gameMode == 1 and player != my:
                computerMove(player)
                drawBoard()
                pygame.display.update()
                # if verifyWinner(player):
                #     player = 'X'
                #     previewImg = previewCrossImg
                # else:
                #     player, previewImg = updatePlayer(player)
                if verifyWinner(player):
                    player = 'X'
                    previewImg = previewCrossImg
                else:
                    player, previewImg = updatePlayer(player)
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if gameMode != 2:
                    if row < 3 and col < 3 and board[row][col] == '':
                        # send_row = row
                        # send_col = col
                        playerMove(player, row, col)
                        drawBoard()
                        Send_Flag = 1
                        time.sleep(0.5)
                        if verifyWinner('X'):
                            player = 'X'
                            previewImg = previewCrossImg
                        else :
                            player, previewImg = updatePlayer(player)
                if gameMode == 2:
                    if row < 3 and col < 3 and board[row][col] == '':
                        print("Current_Player", Current_Player)
                    if row < 3 and col < 3 and board[row][col] == '' and Current_Player == 'X':#自己的回合鼠标才能点击
                        sure_flag = 1
                        send_row = row
                        send_col = col
                        message = "sure_f"+str(sure_flag) + "row" + str(send_row)+" col"+str(send_col) + "flash"+ str(flash_flag)
                        time.sleep(0.3)
                        playerMove('X', row, col)
                        drawBoard()
                        Current_Player = 'O'#下完换对方
                        previewImg = previewCircleImg
                        print("I am going to Send message X")
                        time.sleep(0.5)
                        print("I am waiting for O message")
                    # else:
                    #         Receive_Flag = 1
                if 550 < mouse[0] < 582 and 610 < mouse[1] < 642:
                        flash_flag = 1
                        message = "sure_f"+str(sure_flag) + "row" + str(row)+" col"+str(col) + "flash"+ str(flash_flag)
                        resetGame()
                        # time.sleep(0.5)


        screen.fill(background_color)
        drawBoard()
        drawBottomMenu(mouse)
        if row < 3 and col < 3:
            visualizeMove(row, col, previewImg)
        pygame.display.update()


def choose():
    player = None
    running = True
    while running:
        mouse = pygame.mouse.get_pos()
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if crossImg_rect.collidepoint((mouse[0], mouse[1])):
                    player = 'X'
                    running = False
                elif circleImg_rect.collidepoint((mouse[0], mouse[1])):
                    player = 'O'
                    running = False
        screen.blit(crossImg, (80, 300))
        screen.blit(circleImg, (340, 300))
        screen.blit(chooseImg, (8, 25))
        pygame.display.update()
    return player


def drawBoard():
    # 画棋子
    for row in range(3):
        for col in range(3):
            pos = (row * 200 + 12, col * 200 + 12)
            if board[row][col] == 'X':
                screen.blit(crossImg, pos)
            elif board[row][col] == 'O':
                screen.blit(circleImg, pos)
    # 画网格
    width = 10
    color = dark_grey
    pygame.draw.line(screen, color, (200, 0), (200, 600), width)
    pygame.draw.line(screen, color, (400, 0), (400, 600), width)
    pygame.draw.line(screen, color, (0, 200), (600, 200), width)
    pygame.draw.line(screen, color, (0, 400), (600, 400), width)
    # 画边框
    pygame.draw.rect(screen, color, (0, 0, 10, 600))
    pygame.draw.rect(screen, color, (0, 0, 600, 10))
    pygame.draw.rect(screen, color, (590, 0, 10, 600))


def drawBottomMenu(mouse):
    pygame.draw.rect(screen, dark_grey, (0, 600, 600, 100))
    pygame.draw.rect(screen, light_grey, (10, 610, 580, 80))
    screen.blit(restartImg, (550, 610))
    # Hover animation
    if 550 < mouse[0] < 582 and 610 < mouse[1] < 642:
        screen.blit(restartHoveredImg, (548, 608))
    screen.blit(X_score, (200, 610))
    screen.blit(O_score, (370, 610))
    scoreboard = font.render(': %d x %d :' % (score['X'], score['O']), True, background_color, light_grey)
    screen.blit(scoreboard, (244, 610))


def visualizeMove(row, col, previewImg):
    if board[row][col] == '':
        screen.blit(previewImg, (row * 200 + 12, col * 200 + 12))


def playerMove(player, row, col):
    board[row][col] = player

def CounterMove(row, col):
    board[row][col] = "O"


def computerMove(player):
    bestScore = float('inf')
    for row in range(3):
        for col in range(3):
            if board[row][col] == '':
                board[row][col] = 'O'
                score = minimax(board, 'X')
                board[row][col] = ''
                if score < bestScore:
                    bestScore = score
                    bestMove = (row, col)
    board[bestMove[0]][bestMove[1]] = player


scores = {'X': 1, 'O': -1, 'tie': 0}


def minimax(board, cur_player):
    if isWinner('X'):
        return scores['X']
    elif isWinner('O'):
        return scores['O']
    elif isBoardFull():
        return scores['tie']
    if cur_player == 'X':
        bestScore = float('-inf')
        nextPlayer = 'O'
        minORmax = max
    else:
        bestScore = float('inf')
        nextPlayer = 'X'
        minORmax = min
    for row in range(3):
        for col in range(3):
            if board[row][col] == '':
                board[row][col] = cur_player
                score = minimax(board, nextPlayer)
                board[row][col] = ''
                bestScore = minORmax(score, bestScore)
            if bestScore == scores[cur_player]:
                return bestScore
    return bestScore


def updatePlayer(player):
    if player == 'X':
        newPlayer = 'O'
        previewImg = previewCircleImg
    else:
        newPlayer = 'X'
        previewImg = previewCrossImg
    return newPlayer, previewImg



def isWinner(player):
    return ((board[0][0] == player and board[0][1] == player and board[0][2] == player) or
            (board[1][0] == player and board[1][1] == player and board[1][2] == player) or
            (board[2][0] == player and board[2][1] == player and board[2][2] == player) or
            (board[0][0] == player and board[1][0] == player and board[2][0] == player) or
            (board[0][1] == player and board[1][1] == player and board[2][1] == player) or
            (board[0][2] == player and board[1][2] == player and board[2][2] == player) or
            (board[0][0] == player and board[1][1] == player and board[2][2] == player) or
            (board[0][2] == player and board[1][1] == player and board[2][0] == player))


def verifyWinner(player):
    global Send_Flag, Receive_Flag, Current_Player,dataSocket,gameMode,previewImg
    if isWinner(player):
        # dataSocket.close()
        # dataSocket, addr = listenSocket.accept()
        print(player, "win")
        if gameMode == 2:
            print("I have turn current_player to X")
            Current_Player = 'X'  # X先下棋
            previewImg = previewCrossImg
            if player == 'O':
                toSend = 'Over'
                dataSocket.send(toSend.encode())
                print("send_meseage:",toSend)
                Send_Flag = 0
                Receive_Flag = 0  ##一开始不发送也不接受，主机

        score[player] += 1
        ctypes.windll.user32.MessageBoxW(0, player + ' 获胜！', '提示', 0)
        resetBoard()
        return True
    return False


def isBoardFull():
    for i in range(3):
        for j in range(3):
            if board[i][j] == '':
                return False
    return True


def resetBoard():
    for i in range(3):
        for j in range(3):
            board[i][j] = ''

def Common_Reset():##对方刷新引起的刷新
    global Send_Flag,Receive_Flag,gameMode,Current_Player,previewImg,dataSocket
    resetBoard()
    score['X'] = 0
    score['O'] = 0
    previewImg = previewCrossImg
    Current_Player = 'X'


def resetGame():
    global Send_Flag,Receive_Flag,gameMode,Current_Player,previewImg,dataSocket
    resetBoard()
    score['X'] = 0
    score['O'] = 0
    if gameMode == 2:
        Current_Player = 'X'
        print("I have turn the picture to Cross")
        previewImg = previewCrossImg


global i
i = 0

def handle(rec):
    global send_row, send_col, Send_Flag, row, col, Receive_Flag, i, Current_Player, previewImg, message
    global pi_sure_flag, pi_row, pi_col, pr_flash
    if rec:
        print("rec    in re",rec)
        re_sure_flag = int(pi_sure_flag.search(rec).group(1))
        re_row = int(pi_row.search(rec).group(1))
        re_col = int(pi_col.search(rec).group(1))
        re_flash = int(pi_flash.search(rec).group(1))
        if re_sure_flag == 1:
            counter_row = re_row
            counter_col = re_col
            board[counter_row][counter_col] = "O"
            drawBoard()
            Current_Player = 'X'  ##收到对面信息后回到主场
            pygame.display.update()
        if re_flash:
            Common_Reset()


def TCP_Server():
    global send_row, send_col, Send_Flag, row, col, Receive_Flag, i, current_player, previewImg, message,sure_flag,flash_flag,SOR
    global pi_send_flag, pi_received_flag, pi_row, pi_col, pr_flash
    pi_sr = re.compile(r'SenOrRec(\d)')
    while True:
        if SOR == 0:
            time.sleep(0.3)
            print("Send_message", message)
            dataSocket.send(message.encode())
            # time.sleep(0.3)
            sure_flag = 0
            flash_flag = 0
            message = "sure_f" + str(sure_flag) + "row" + str(send_row) + " col" + str(send_col) + "flash" + str(flash_flag)
            print("waiting for receiving...........")
            SOR = 1
        if SOR == 1:
            recved = dataSocket.recv(BUFLEN)
            rec = recved.decode()
            if not recved:
                break
            if rec:
                # re_SOR = pi_sr.search(rec)
                # SOR = re_SOR.group(1)
                handle(rec)
                print("received", rec)
                dataSocket.send(message.encode())
                SOR = 0


server_thread = threading.Thread(target = TCP_Server )
server_thread.start()
menu()
dataSocket.close()
listenSocket.close()
```

#### 客户端

```python
import pygame
import ctypes
#  === TCP 客户端程序 client.py ===
import time
from socket import *
import threading
import re

global pi_sure_flag,pi_row,pi_col,pi_flash,message,SOR,sure_flag,flash_flag

pi_sure_flag=re.compile(r'sure_f(\d)')
pi_row=re.compile(r'row(\d)')
pi_col=re.compile(r'col(\d)')
pi_flash=re.compile(r'flash(\d)')##刷新参数
message= "sure_f0 row0 col0 flash0 SenOrRec1"
SOR = 1
sure_flag = 0
flash_flag = 0
IP = '127.0.0.1'
SERVER_PORT = 50000
BUFLEN = 1024

# 实例化一个socket对象，指明协议
dataSocket = socket(AF_INET, SOCK_STREAM)
global Send_Flag,Receive_Flag,current_player,previewImg,gameMode
Send_Flag = 0
Receive_Flag = 1
current_player = 'X'#服务端先下
gameMode = 0
send_row = 0
send_col = 0
# 连接服务端socket
dataSocket.connect((IP, SERVER_PORT))
# 初始化 pygame
pygame.init()

# 定义颜色
blue = (78, 140, 243)
light_blue = (100, 100, 255)
red = (242, 89, 97)
light_red = (255, 100, 100)
dark_grey = (85, 85, 85)
light_grey = (100, 100, 100)
background_color = (225, 225, 225)

# 创建窗口
screen = pygame.display.set_mode((600, 800))
pygame.display.set_caption('井字棋-客户端')

# 游戏图片
crossImg = pygame.image.load('Images/crossImg.png')
crossImg_rect = crossImg.get_rect()
crossImg_rect.center = (200, 300)
circleImg = pygame.image.load('Images/circleImg.png')
circleImg_rect = crossImg.get_rect()
circleImg_rect.center = (400, 300)
previewCrossImg = pygame.image.load('Images/prev_crossImg.png')
previewCircleImg = pygame.image.load('Images/prev_circleImg.png')
previewImg = previewCrossImg
# 按钮图片
restartImg = pygame.image.load('Images/restart.png')
restartHoveredImg = pygame.image.load('Images/restart_hovered.png')

# 定义棋盘
board = [['', '', ''],
         ['', '', ''],
         ['', '', '']]

# 定义计分板
score = {'X': 0, 'O': 0}
font = pygame.font.Font('freesansbold.ttf', 32)
X_score = pygame.image.load('Images/X_scoreImg.png')
O_score = pygame.image.load('Images/O_scoreImg.png')

# 菜单图片
buttom1 = pygame.image.load('Images/button1Img.png')
buttom1_rect = buttom1.get_rect()
buttom1_rect.center = (300, 312)
buttom2 = pygame.image.load('Images/button2Img.png')
buttom2_rect = buttom2.get_rect()
buttom2_rect.center = (300, 472)
buttom3 = pygame.image.load('Images/button3Img.png')
buttom3_rect = buttom3.get_rect()
buttom3_rect.center = (300, 632)
logo = pygame.image.load('Images/logo.png')

# 选择菜单图片
chooseImg = pygame.image.load('Images/choose.png')


def menu():
    global gameMode
    running = True
    while running:
        screen.fill(background_color)
        mx, my = pygame.mouse.get_pos()
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if buttom1_rect.collidepoint((mx, my)):
                    gameMode= 0
                    game(0, 'X')
                elif buttom2_rect.collidepoint((mx, my)):
                    player = choose()
                    if player is not None:
                        gameMode= 1
                        game(1, player)
                elif buttom3_rect.collidepoint((mx, my)):
                    gameMode = 2
                    game(2, 'O')
        screen.blit(logo, (8, 25))
        screen.blit(buttom1, (100, 250))
        screen.blit(buttom2, (100, 410))
        screen.blit(buttom3, (100, 570))
        pygame.display.update()


def game(gameMode, player):
    global send_row, send_col, Send_Flag, Receive_Flag,row, col,current_player,previewImg,message,sure_flag,flash_flag
    my = player
    # player = current_player
    running = True
    if gameMode == 2:
        previewImg = previewCrossImg  # 服务端先下
    else:
        previewImg = previewCircleImg

    while running:
        mouse = pygame.mouse.get_pos()
        row, col = int(mouse[0] / 200), int(mouse[1] / 200)
        for event in pygame.event.get():
            if verifyWinner('O'):
                # player = 'O'
                # previewImg = previewCrossImg
                 pass
            if verifyWinner('X'):
                # player = 'X'
                # previewImg = previewCrossImg
                pass
            if event.type == pygame.QUIT:
                resetGame()
                running = False
            elif isBoardFull():
                ctypes.windll.user32.MessageBoxW(0, '平局', '提示', 0)
                resetBoard()
            elif gameMode == 1 and player != my:
                computerMove(player)
                drawBoard()
                pygame.display.update()
                if verifyWinner(player):
                    player = 'O'
                    previewImg = previewCrossImg
                else:
                    player, previewImg = updatePlayer(player)
            # elif gameMode == 2 and player != my:
            #     CounterMove(player)
            #     drawBoard()
            #     pygame.display.update()
            #     if verifyWinner(player):
            #         player = 'O'
            #         previewImg = previewCrossImg
            #     else:
            #         player, previewImg = updatePlayer(player)
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if gameMode != 2:
                    if row < 3 and col < 3 and board[row][col] == '':
                        send_row = row
                        send_col = col
                        playerMove(player, row, col)
                        drawBoard()
                        # Send_Flag = 1
                        # time.sleep(0.5)
                        if verifyWinner('O'):
                            player = 'X'
                            previewImg = previewCrossImg
                        else :
                            player, previewImg = updatePlayer(player)
                    #
                    #     else:
                    #         Receive_Flag = 1
                    # elif 550 < mouse[0] < 582 and 610 < mouse[1] < 642:
                    #     resetGame()
                if gameMode == 2:
                    if row < 3 and col < 3 and board[row][col] == '':
                        print("Current_Player", current_player)
                    if row < 3 and col < 3 and board[row][col] == '' and current_player == 'O':#自己的回合鼠标才能点击
                        send_row = row
                        send_col = col
                        sure_flag =1
                        message = "sure_f"+str(sure_flag) + "row" + str(send_row)+" col"+str(send_col) + "flash"+ str(flash_flag)+"SenOrRec1"
                        playerMove('O', row, col)
                        drawBoard()
                        current_player = 'X'#下完换对方
                        previewImg = previewCrossImg
                        Send_Flag = 1
                        Receive_Flag = 1
                        print("I am going to send O message")
                        # time.sleep(0.5)
                        print("I am wating for message")
                        # if verifyWinner(player):
                        #     player = 'O'
                        #     previewImg = previewCrossImg
                        # elif gameMode != 2:
                        #
                    # else:
                    #         Receive_Flag = 1
                if 550 < mouse[0] < 582 and 610 < mouse[1] < 642:
                    flash_flag =1
                    resetGame()

        screen.fill(background_color)
        drawBoard()
        drawBottomMenu(mouse)
        if row < 3 and col < 3:
            visualizeMove(row, col, previewImg)
        pygame.display.update()


def choose():
    player = None
    running = True
    while running:
        mouse = pygame.mouse.get_pos()
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if crossImg_rect.collidepoint((mouse[0], mouse[1])):
                    player = 'X'
                    running = False
                elif circleImg_rect.collidepoint((mouse[0], mouse[1])):
                    player = 'O'
                    running = False
        screen.blit(crossImg, (80, 300))
        screen.blit(circleImg, (340, 300))
        screen.blit(chooseImg, (8, 25))
        pygame.display.update()
    return player


def drawBoard():
    # 画棋子
    for row in range(3):
        for col in range(3):
            pos = (row * 200 + 12, col * 200 + 12)
            if board[row][col] == 'X':
                screen.blit(crossImg, pos)
            elif board[row][col] == 'O':
                screen.blit(circleImg, pos)
    # 画网格
    width = 10
    color = dark_grey
    pygame.draw.line(screen, color, (200, 0), (200, 600), width)
    pygame.draw.line(screen, color, (400, 0), (400, 600), width)
    pygame.draw.line(screen, color, (0, 200), (600, 200), width)
    pygame.draw.line(screen, color, (0, 400), (600, 400), width)
    # 画边框
    pygame.draw.rect(screen, color, (0, 0, 10, 600))
    pygame.draw.rect(screen, color, (0, 0, 600, 10))
    pygame.draw.rect(screen, color, (590, 0, 10, 600))


def drawBottomMenu(mouse):
    pygame.draw.rect(screen, dark_grey, (0, 600, 600, 100))
    pygame.draw.rect(screen, light_grey, (10, 610, 580, 80))
    screen.blit(restartImg, (550, 610))
    # Hover animation
    if 550 < mouse[0] < 582 and 610 < mouse[1] < 642:
        screen.blit(restartHoveredImg, (548, 608))
    screen.blit(X_score, (200, 610))
    screen.blit(O_score, (370, 610))
    scoreboard = font.render(': %d x %d :' % (score['X'], score['O']), True, background_color, light_grey)
    screen.blit(scoreboard, (244, 610))


def visualizeMove(row, col, previewImg):
    if board[row][col] == '':
        screen.blit(previewImg, (row * 200 + 12, col * 200 + 12))


def playerMove(player, row, col):
    board[row][col] = player


def computerMove(player):
    bestScore = float('inf')
    for row in range(3):
        for col in range(3):
            if board[row][col] == '':
                board[row][col] = 'O'
                score = minimax(board, 'X')
                board[row][col] = ''
                if score < bestScore:
                    bestScore = score
                    bestMove = (row, col)
    board[bestMove[0]][bestMove[1]] = player


scores = {'X': 1, 'O': -1, 'tie': 0}


def minimax(board, cur_player):
    if isWinner('X'):
        return scores['X']
    elif isWinner('O'):
        return scores['O']
    elif isBoardFull():
        return scores['tie']
    if cur_player == 'X':
        bestScore = float('-inf')
        nextPlayer = 'O'
        minORmax = max
    else:
        bestScore = float('inf')
        nextPlayer = 'X'
        minORmax = min
    for row in range(3):
        for col in range(3):
            if board[row][col] == '':
                board[row][col] = cur_player
                score = minimax(board, nextPlayer)
                board[row][col] = ''
                bestScore = minORmax(score, bestScore)
            if bestScore == scores[cur_player]:
                return bestScore
    return bestScore


def updatePlayer(player):
    if player == 'X':
        newPlayer = 'O'
        previewImg = previewCircleImg
    else:
        newPlayer = 'X'
        previewImg = previewCrossImg
    return newPlayer, previewImg



def isWinner(player):
    return ((board[0][0] == player and board[0][1] == player and board[0][2] == player) or
            (board[1][0] == player and board[1][1] == player and board[1][2] == player) or
            (board[2][0] == player and board[2][1] == player and board[2][2] == player) or
            (board[0][0] == player and board[1][0] == player and board[2][0] == player) or
            (board[0][1] == player and board[1][1] == player and board[2][1] == player) or
            (board[0][2] == player and board[1][2] == player and board[2][2] == player) or
            (board[0][0] == player and board[1][1] == player and board[2][2] == player) or
            (board[0][2] == player and board[1][1] == player and board[2][0] == player))


def verifyWinner(player):
    global  Send_Flag,Receive_Flag,current_player,dataSocket,previewImg,gameMode
    if isWinner(player):
        print(player, "win")
        if gameMode ==2:
            previewImg = previewCrossImg
            current_player = 'X'  # 服务端先下
            if player == 'X':
                toSend = 'Over'
                dataSocket.send(toSend.encode())
                print("send_meseage:", toSend)
                Send_Flag = 0
                Receive_Flag = 1
        score[player] += 1
        ctypes.windll.user32.MessageBoxW(0, player + ' 获胜！', '提示', 0)
        resetBoard()
        return True
    return False


def isBoardFull():
    for i in range(3):
        for j in range(3):
            if board[i][j] == '':
                return False
    return True


def resetBoard():
    for i in range(3):
        for j in range(3):
            board[i][j] = ''

def Common_Reset():##对方刷新引起的刷新，被动刷新
    global Send_Flag,Receive_Flag,gameMode,current_player,previewImg,dataSocket
    resetBoard()
    score['X'] = 0
    score['O'] = 0
    if gameMode == 2:
        current_player = 'X'
        print("I have turn the picture to Cross")
        previewImg = previewCrossImg
def resetGame():##主动刷新
    global Send_Flag, Receive_Flag, gameMode, current_player, previewImg, dataSocket
    resetBoard()
    score['X'] = 0
    score['O'] = 0
    if gameMode == 2:
        current_player = 'X'
        print("I have turn the picture to Cross")
        previewImg = previewCrossImg

    resetBoard()
    score['X'] = 0
    score['O'] = 0
global i
i = 0
def handle(rec):
    global send_row, send_col ,Send_Flag,row, col,Receive_Flag, i, current_player, previewImg,message
    global pi_sure_flag, pi_row, pi_col, pr_flash
    if rec:
        re_sure_flag = int(pi_sure_flag.search(rec).group(1))
        re_row = int(pi_row.search(rec).group(1))
        re_col = int(pi_col.search(rec).group(1))
        re_flash = int(pi_flash.search(rec).group(1))
        if re_sure_flag == 1:
            counter_row = re_row
            counter_col = re_col
            board[counter_row][counter_col] = "X"
            drawBoard()
            current_player = 'O'  ##收到对面信息后回到主场
            pygame.display.update()
            previewImg = previewCircleImg
        if re_flash :
            Common_Reset()


def TCP_Client():
    global send_row, send_col ,Send_Flag,row, col,Receive_Flag, i, current_player, previewImg,message,SOR,sure_flag,flash_flag
    global pi_send_flag, pi_received_flag, pi_row, pi_col, pr_flash
    pi_sr = re.compile(r'SenOrRec(\d)')
    while True:
        if SOR == 1:
            print("waiting for receiving...........")
            recved = dataSocket.recv(BUFLEN)
            rec = recved.decode()
            if not recved:
                break
            if rec:
                handle(rec)
                print("received", rec)
                dataSocket.send(message.encode())
                SOR = 0
        # time.sleep(0.3)
        if SOR == 0:
            print("sending",message)
            dataSocket.send(message.encode())
            sure_flag = 0
            flash_flag = 0
            message = "sure_f" + str(sure_flag) + "row" + str(send_row) + " col" + str(send_col) + "flash" + str(flash_flag)
            SOR = 1


client_thread = threading.Thread(target=TCP_Client)
client_thread.start()

menu()
dataSoc
```

### 正则表达式无bug

#### 服务端

```python
import pygame
import ctypes
# 导入socket 库
from socket import *
import threading
import time
import re

global pi_sure_flag,pi_row,pi_col,pi_flash,message,sure_flag,flash_flag,SOR

pi_sure_flag=re.compile(r'sure_f(\d)')
pi_row=re.compile(r'row(\d)')
pi_col=re.compile(r'col(\d)')
pi_flash=re.compile(r'flash(\d)')##刷新参数
message= "sure_f0 row0 col0 flash0 SenOrRec0"
sure_flag = 0
flash_flag = 0
send_row = 0
send_col = 0
SOR = 0 #0是发送
# 主机地址为空字符串，表示绑定本机所有网络接口ip地址
# 等待客户端来连接
IP = ''
# 端口号
PORT = 50000
# 定义一次从socket缓冲区最多读入512个字节数据
BUFLEN = 512

# 实例化一个socket对象
# 参数 AF_INET 表示该socket网络层使用IP协议
# 参数 SOCK_STREAM 表示该socket传输层使用TCP协议
listenSocket = socket(AF_INET, SOCK_STREAM)

# socket绑定地址和端口
listenSocket.bind((IP, PORT))


# 使socket处于监听状态，等待客户端的连接请求
# 参数 8 表示 最多接受多少个等待连接的客户端
listenSocket.listen(8)
print(f'服务端启动成功，在{PORT}端口等待客户端连接...')

dataSocket, addr = listenSocket.accept()
print('接受一个客户端连接:', addr)


global Send_Flag,Receive_Flag,Current_Player,If_over,previewImg,gameMode,Ini_FLag,Reset_Flag
# 初始化 pygame
pygame.init()

# 定义颜色
blue = (78, 140, 243)
light_blue = (100, 100, 255)
red = (242, 89, 97)
light_red = (255, 100, 100)
dark_grey = (85, 85, 85)
light_grey = (100, 100, 100)
background_color = (225, 225, 225)
Send_Flag = 0
Receive_Flag = 0##一开始不发送也不接受，主机
Current_Player = 'X'#X先下棋
If_over = 0
gameMode = 0
Ini_FLag = 1
# 创建窗口
screen = pygame.display.set_mode((600, 800))
pygame.display.set_caption('井字棋')

# 游戏图片
crossImg = pygame.image.load('Images/crossImg.png')
crossImg_rect = crossImg.get_rect()
crossImg_rect.center = (200, 300)
circleImg = pygame.image.load('Images/circleImg.png')
circleImg_rect = crossImg.get_rect()
circleImg_rect.center = (400, 300)
previewCrossImg = pygame.image.load('Images/prev_crossImg.png')
previewCircleImg = pygame.image.load('Images/prev_circleImg.png')

previewImg = previewCrossImg
# 按钮图片
restartImg = pygame.image.load('Images/restart.png')
restartHoveredImg = pygame.image.load('Images/restart_hovered.png')

# 定义棋盘
board = [['', '', ''],
         ['', '', ''],
         ['', '', '']]

# 定义计分板
score = {'X': 0, 'O': 0}
font = pygame.font.Font('freesansbold.ttf', 32)
X_score = pygame.image.load('Images/X_scoreImg.png')
O_score = pygame.image.load('Images/O_scoreImg.png')

# 菜单图片
buttom1 = pygame.image.load('Images/button1Img.png')
buttom1_rect = buttom1.get_rect()
buttom1_rect.center = (300, 312)
buttom2 = pygame.image.load('Images/button2Img.png')
buttom2_rect = buttom2.get_rect()
buttom2_rect.center = (300, 472)

buttom3 = pygame.image.load('Images/button3Img.png')
buttom3_rect = buttom3.get_rect()
buttom3_rect.center = (300, 632)

logo = pygame.image.load('Images/logo.png')

# 选择菜单图片
chooseImg = pygame.image.load('Images/choose.png')


def menu():
    global gameMode
    running = True
    while running:
        screen.fill(background_color)
        mx, my = pygame.mouse.get_pos()
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if buttom1_rect.collidepoint((mx, my)):
                    game(0, 'X')
                    gameMode = 0
                elif buttom2_rect.collidepoint((mx, my)):
                    player = choose()
                    if player is not None:
                        game(1, player)
                        gameMode =1
                elif buttom3_rect.collidepoint((mx, my)):
                    gameMode = 2
                    game(2, 'X')
        screen.blit(logo, (8, 25))
        screen.blit(buttom1, (100, 250))
        screen.blit(buttom2, (100, 410))
        screen.blit(buttom3, (100, 570))
        pygame.display.update()


def game(gameMode, player):
    global send_row, send_col ,Send_Flag,row, col,Receive_Flag,Current_Player,If_over,previewImg,message,sure_flag,flash_flag
    my = player
    player = 'X'
    running = True
    while running:
        mouse = pygame.mouse.get_pos()
        row, col = int(mouse[0] / 200), int(mouse[1] / 200)
        for event in pygame.event.get():
            if verifyWinner('X'):
                print("确认X胜利")
                player = 'X'
                previewImg = previewCrossImg
            if verifyWinner('O'):
                print("确认O胜利")
                player = 'X'
                previewImg = previewCrossImg
            if event.type == pygame.QUIT:
                resetGame()
                running = False
            elif isBoardFull():
                ctypes.windll.user32.MessageBoxW(0, '平局', '提示', 0)
                resetBoard()
            elif gameMode == 1 and player != my:
                computerMove(player)
                drawBoard()
                pygame.display.update()
                # if verifyWinner(player):
                #     player = 'X'
                #     previewImg = previewCrossImg
                # else:
                #     player, previewImg = updatePlayer(player)
                if verifyWinner(player):
                    player = 'X'
                    previewImg = previewCrossImg
                else:
                    player, previewImg = updatePlayer(player)
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if gameMode != 2:
                    if row < 3 and col < 3 and board[row][col] == '':
                        # send_row = row
                        # send_col = col
                        playerMove(player, row, col)
                        drawBoard()
                        Send_Flag = 1
                        time.sleep(0.5)
                        if verifyWinner('X'):
                            player = 'X'
                            previewImg = previewCrossImg
                        else :
                            player, previewImg = updatePlayer(player)
                if gameMode == 2:
                    if row < 3 and col < 3 and board[row][col] == '':
                        print("Current_Player", Current_Player)
                    if row < 3 and col < 3 and board[row][col] == '' and Current_Player == 'X':#自己的回合鼠标才能点击
                        sure_flag = 1
                        send_row = row
                        send_col = col
                        message = "sure_f"+str(sure_flag) + "row" + str(send_row)+" col"+str(send_col) + "flash"+ str(flash_flag)
                        time.sleep(0.3)
                        playerMove('X', row, col)
                        drawBoard()
                        Current_Player = 'O'#下完换对方
                        previewImg = previewCircleImg
                        print("I am going to Send message X")
                        time.sleep(0.5)
                        print("I am waiting for O message")
                    # else:
                    #         Receive_Flag = 1
                if 550 < mouse[0] < 582 and 610 < mouse[1] < 642:
                        flash_flag = 1
                        message = "sure_f"+str(sure_flag) + "row" + str(row)+" col"+str(col) + "flash"+ str(flash_flag)
                        resetGame()
                        # time.sleep(0.5)


        screen.fill(background_color)
        drawBoard()
        drawBottomMenu(mouse)
        if row < 3 and col < 3:
            visualizeMove(row, col, previewImg)
        pygame.display.update()


def choose():
    player = None
    running = True
    while running:
        mouse = pygame.mouse.get_pos()
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if crossImg_rect.collidepoint((mouse[0], mouse[1])):
                    player = 'X'
                    running = False
                elif circleImg_rect.collidepoint((mouse[0], mouse[1])):
                    player = 'O'
                    running = False
        screen.blit(crossImg, (80, 300))
        screen.blit(circleImg, (340, 300))
        screen.blit(chooseImg, (8, 25))
        pygame.display.update()
    return player


def drawBoard():
    # 画棋子
    for row in range(3):
        for col in range(3):
            pos = (row * 200 + 12, col * 200 + 12)
            if board[row][col] == 'X':
                screen.blit(crossImg, pos)
            elif board[row][col] == 'O':
                screen.blit(circleImg, pos)
    # 画网格
    width = 10
    color = dark_grey
    pygame.draw.line(screen, color, (200, 0), (200, 600), width)
    pygame.draw.line(screen, color, (400, 0), (400, 600), width)
    pygame.draw.line(screen, color, (0, 200), (600, 200), width)
    pygame.draw.line(screen, color, (0, 400), (600, 400), width)
    # 画边框
    pygame.draw.rect(screen, color, (0, 0, 10, 600))
    pygame.draw.rect(screen, color, (0, 0, 600, 10))
    pygame.draw.rect(screen, color, (590, 0, 10, 600))


def drawBottomMenu(mouse):
    pygame.draw.rect(screen, dark_grey, (0, 600, 600, 100))
    pygame.draw.rect(screen, light_grey, (10, 610, 580, 80))
    screen.blit(restartImg, (550, 610))
    # Hover animation
    if 550 < mouse[0] < 582 and 610 < mouse[1] < 642:
        screen.blit(restartHoveredImg, (548, 608))
    screen.blit(X_score, (200, 610))
    screen.blit(O_score, (370, 610))
    scoreboard = font.render(': %d x %d :' % (score['X'], score['O']), True, background_color, light_grey)
    screen.blit(scoreboard, (244, 610))


def visualizeMove(row, col, previewImg):
    if board[row][col] == '':
        screen.blit(previewImg, (row * 200 + 12, col * 200 + 12))


def playerMove(player, row, col):
    board[row][col] = player

def CounterMove(row, col):
    board[row][col] = "O"


def computerMove(player):
    bestScore = float('inf')
    for row in range(3):
        for col in range(3):
            if board[row][col] == '':
                board[row][col] = 'O'
                score = minimax(board, 'X')
                board[row][col] = ''
                if score < bestScore:
                    bestScore = score
                    bestMove = (row, col)
    board[bestMove[0]][bestMove[1]] = player


scores = {'X': 1, 'O': -1, 'tie': 0}


def minimax(board, cur_player):
    if isWinner('X'):
        return scores['X']
    elif isWinner('O'):
        return scores['O']
    elif isBoardFull():
        return scores['tie']
    if cur_player == 'X':
        bestScore = float('-inf')
        nextPlayer = 'O'
        minORmax = max
    else:
        bestScore = float('inf')
        nextPlayer = 'X'
        minORmax = min
    for row in range(3):
        for col in range(3):
            if board[row][col] == '':
                board[row][col] = cur_player
                score = minimax(board, nextPlayer)
                board[row][col] = ''
                bestScore = minORmax(score, bestScore)
            if bestScore == scores[cur_player]:
                return bestScore
    return bestScore


def updatePlayer(player):
    if player == 'X':
        newPlayer = 'O'
        previewImg = previewCircleImg
    else:
        newPlayer = 'X'
        previewImg = previewCrossImg
    return newPlayer, previewImg



def isWinner(player):
    return ((board[0][0] == player and board[0][1] == player and board[0][2] == player) or
            (board[1][0] == player and board[1][1] == player and board[1][2] == player) or
            (board[2][0] == player and board[2][1] == player and board[2][2] == player) or
            (board[0][0] == player and board[1][0] == player and board[2][0] == player) or
            (board[0][1] == player and board[1][1] == player and board[2][1] == player) or
            (board[0][2] == player and board[1][2] == player and board[2][2] == player) or
            (board[0][0] == player and board[1][1] == player and board[2][2] == player) or
            (board[0][2] == player and board[1][1] == player and board[2][0] == player))


def verifyWinner(player):
    global Send_Flag, Receive_Flag, Current_Player,dataSocket,gameMode,previewImg,SOR
    if isWinner(player):
        # dataSocket.close()
        # dataSocket, addr = listenSocket.accept()
        print(player, "win")
        if gameMode == 2:
            print("I have turn current_player to X")
            Current_Player = 'X'  # X先下棋
            previewImg = previewCrossImg
            SOR = 0
            # if player == 'O':
            #     toSend = 'Over'
            #     dataSocket.send(toSend.encode())
            #     print("send_meseage:",toSend)
            #     Send_Flag = 0
            #     Receive_Flag = 0  ##一开始不发送也不接受，主机

        score[player] += 1
        ctypes.windll.user32.MessageBoxW(0, player + ' 获胜！', '提示', 0)
        resetBoard()
        return True
    return False


def isBoardFull():
    for i in range(3):
        for j in range(3):
            if board[i][j] == '':
                return False
    return True


def resetBoard():
    for i in range(3):
        for j in range(3):
            board[i][j] = ''

def Common_Reset():##对方刷新引起的刷新
    global Send_Flag,Receive_Flag,gameMode,Current_Player,previewImg,dataSocket
    resetBoard()
    score['X'] = 0
    score['O'] = 0
    previewImg = previewCrossImg
    Current_Player = 'X'


def resetGame():
    global Send_Flag,Receive_Flag,gameMode,Current_Player,previewImg,dataSocket
    resetBoard()
    score['X'] = 0
    score['O'] = 0
    if gameMode == 2:
        Current_Player = 'X'
        print("I have turn the picture to Cross")
        previewImg = previewCrossImg


global i
i = 0

def handle(rec):
    global send_row, send_col, Send_Flag, row, col, Receive_Flag, i, Current_Player, previewImg, message
    global pi_sure_flag, pi_row, pi_col, pr_flash
    if rec:
        print("rec    in re",rec)
        re_sure_flag = int(pi_sure_flag.search(rec).group(1))
        re_row = int(pi_row.search(rec).group(1))
        re_col = int(pi_col.search(rec).group(1))
        re_flash = int(pi_flash.search(rec).group(1))
        if re_sure_flag == 1:
            counter_row = re_row
            counter_col = re_col
            board[counter_row][counter_col] = "O"
            drawBoard()
            Current_Player = 'X'  ##收到对面信息后回到主场
            pygame.display.update()
            previewImg = previewCrossImg
        if re_flash == 1:
            Common_Reset()


def TCP_Server():
    global send_row, send_col, Send_Flag, row, col, Receive_Flag, i, current_player, previewImg, message,sure_flag,flash_flag,SOR
    global pi_send_flag, pi_received_flag, pi_row, pi_col, pr_flash
    pi_sr = re.compile(r'SenOrRec(\d)')
    while True:
        if SOR == 0:
            time.sleep(0.3)
            print("Send_message", message)
            dataSocket.send(message.encode())
            # time.sleep(0.3)
            sure_flag = 0
            flash_flag = 0
            message = "sure_f" + str(sure_flag) + "row" + str(send_row) + " col" + str(send_col) + "flash" + str(flash_flag)
            print("waiting for receiving...........")
            SOR = 1
        if SOR == 1:
            recved = dataSocket.recv(BUFLEN)
            rec = recved.decode()
            if not recved:
                break
            if rec:
                # re_SOR = pi_sr.search(rec)
                # SOR = re_SOR.group(1)
                handle(rec)
                print("received", rec)
                dataSocket.send(message.encode())
                SOR = 0


server_thread = threading.Thread(target = TCP_Server )
server_thread.start()
menu()
dataSocket.close()
listenSocket.close()
```

#### 客户端

```python
import pygame
import ctypes
#  === TCP 客户端程序 client.py ===
import time
from socket import *
import threading
import re

global pi_sure_flag,pi_row,pi_col,pi_flash,message,SOR,sure_flag,flash_flag

pi_sure_flag=re.compile(r'sure_f(\d)')
pi_row=re.compile(r'row(\d)')
pi_col=re.compile(r'col(\d)')
pi_flash=re.compile(r'flash(\d)')##刷新参数
message= "sure_f0 row0 col0 flash0 SenOrRec1"
SOR = 1
sure_flag = 0
flash_flag = 0
IP = '127.0.0.1'
SERVER_PORT = 50000
BUFLEN = 1024

# 实例化一个socket对象，指明协议
dataSocket = socket(AF_INET, SOCK_STREAM)
global Send_Flag,Receive_Flag,current_player,previewImg,gameMode
Send_Flag = 0
Receive_Flag = 1
current_player = 'X'#服务端先下
gameMode = 0
send_row = 0
send_col = 0
# 连接服务端socket
dataSocket.connect((IP, SERVER_PORT))
# 初始化 pygame
pygame.init()

# 定义颜色
blue = (78, 140, 243)
light_blue = (100, 100, 255)
red = (242, 89, 97)
light_red = (255, 100, 100)
dark_grey = (85, 85, 85)
light_grey = (100, 100, 100)
background_color = (225, 225, 225)

# 创建窗口
screen = pygame.display.set_mode((600, 800))
pygame.display.set_caption('井字棋-客户端')

# 游戏图片
crossImg = pygame.image.load('Images/crossImg.png')
crossImg_rect = crossImg.get_rect()
crossImg_rect.center = (200, 300)
circleImg = pygame.image.load('Images/circleImg.png')
circleImg_rect = crossImg.get_rect()
circleImg_rect.center = (400, 300)
previewCrossImg = pygame.image.load('Images/prev_crossImg.png')
previewCircleImg = pygame.image.load('Images/prev_circleImg.png')
previewImg = previewCrossImg
# 按钮图片
restartImg = pygame.image.load('Images/restart.png')
restartHoveredImg = pygame.image.load('Images/restart_hovered.png')

# 定义棋盘
board = [['', '', ''],
         ['', '', ''],
         ['', '', '']]

# 定义计分板
score = {'X': 0, 'O': 0}
font = pygame.font.Font('freesansbold.ttf', 32)
X_score = pygame.image.load('Images/X_scoreImg.png')
O_score = pygame.image.load('Images/O_scoreImg.png')

# 菜单图片
buttom1 = pygame.image.load('Images/button1Img.png')
buttom1_rect = buttom1.get_rect()
buttom1_rect.center = (300, 312)
buttom2 = pygame.image.load('Images/button2Img.png')
buttom2_rect = buttom2.get_rect()
buttom2_rect.center = (300, 472)
buttom3 = pygame.image.load('Images/button3Img.png')
buttom3_rect = buttom3.get_rect()
buttom3_rect.center = (300, 632)
logo = pygame.image.load('Images/logo.png')

# 选择菜单图片
chooseImg = pygame.image.load('Images/choose.png')


def menu():
    global gameMode
    running = True
    while running:
        screen.fill(background_color)
        mx, my = pygame.mouse.get_pos()
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if buttom1_rect.collidepoint((mx, my)):
                    gameMode= 0
                    game(0, 'X')
                elif buttom2_rect.collidepoint((mx, my)):
                    player = choose()
                    if player is not None:
                        gameMode= 1
                        game(1, player)
                elif buttom3_rect.collidepoint((mx, my)):
                    gameMode = 2
                    game(2, 'O')
        screen.blit(logo, (8, 25))
        screen.blit(buttom1, (100, 250))
        screen.blit(buttom2, (100, 410))
        screen.blit(buttom3, (100, 570))
        pygame.display.update()


def game(gameMode, player):
    global send_row, send_col, Send_Flag, Receive_Flag,row, col,current_player,previewImg,message,sure_flag,flash_flag
    my = player
    # player = current_player
    running = True
    if gameMode == 2:
        previewImg = previewCrossImg  # 服务端先下
    else:
        previewImg = previewCircleImg

    while running:
        mouse = pygame.mouse.get_pos()
        row, col = int(mouse[0] / 200), int(mouse[1] / 200)
        for event in pygame.event.get():
            if verifyWinner('O'):
                # player = 'O'
                # previewImg = previewCrossImg
                 pass
            if verifyWinner('X'):
                # player = 'X'
                # previewImg = previewCrossImg
                pass
            if event.type == pygame.QUIT:
                resetGame()
                running = False
            elif isBoardFull():
                ctypes.windll.user32.MessageBoxW(0, '平局', '提示', 0)
                resetBoard()
            elif gameMode == 1 and player != my:
                computerMove(player)
                drawBoard()
                pygame.display.update()
                if verifyWinner(player):
                    player = 'O'
                    previewImg = previewCrossImg
                else:
                    player, previewImg = updatePlayer(player)
            # elif gameMode == 2 and player != my:
            #     CounterMove(player)
            #     drawBoard()
            #     pygame.display.update()
            #     if verifyWinner(player):
            #         player = 'O'
            #         previewImg = previewCrossImg
            #     else:
            #         player, previewImg = updatePlayer(player)
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if gameMode != 2:
                    if row < 3 and col < 3 and board[row][col] == '':
                        send_row = row
                        send_col = col
                        playerMove(player, row, col)
                        drawBoard()
                        # Send_Flag = 1
                        # time.sleep(0.5)
                        if verifyWinner('O'):
                            player = 'X'
                            previewImg = previewCrossImg
                        else :
                            player, previewImg = updatePlayer(player)
                    #
                    #     else:
                    #         Receive_Flag = 1
                    # elif 550 < mouse[0] < 582 and 610 < mouse[1] < 642:
                    #     resetGame()
                if gameMode == 2:
                    if row < 3 and col < 3 and board[row][col] == '':
                        print("Current_Player", current_player)
                    if row < 3 and col < 3 and board[row][col] == '' and current_player == 'O':#自己的回合鼠标才能点击
                        send_row = row
                        send_col = col
                        sure_flag =1
                        message = "sure_f"+str(sure_flag) + "row" + str(send_row)+" col"+str(send_col) + "flash"+ str(flash_flag)+"SenOrRec1"
                        playerMove('O', row, col)
                        drawBoard()
                        current_player = 'X'#下完换对方
                        previewImg = previewCrossImg
                        Send_Flag = 1
                        Receive_Flag = 1
                        print("I am going to send O message")
                        # time.sleep(0.5)
                        print("I am wating for message")
                        # if verifyWinner(player):
                        #     player = 'O'
                        #     previewImg = previewCrossImg
                        # elif gameMode != 2:
                        #
                    # else:
                    #         Receive_Flag = 1
                if 550 < mouse[0] < 582 and 610 < mouse[1] < 642:
                    flash_flag = 1
                    message = "sure_f" + str(sure_flag) + "row" + str(send_row) + " col" + str(send_col) + "flash" + str(flash_flag)
                    resetGame()

        screen.fill(background_color)
        drawBoard()
        drawBottomMenu(mouse)
        if row < 3 and col < 3:
            visualizeMove(row, col, previewImg)
        pygame.display.update()


def choose():
    player = None
    running = True
    while running:
        mouse = pygame.mouse.get_pos()
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if crossImg_rect.collidepoint((mouse[0], mouse[1])):
                    player = 'X'
                    running = False
                elif circleImg_rect.collidepoint((mouse[0], mouse[1])):
                    player = 'O'
                    running = False
        screen.blit(crossImg, (80, 300))
        screen.blit(circleImg, (340, 300))
        screen.blit(chooseImg, (8, 25))
        pygame.display.update()
    return player


def drawBoard():
    # 画棋子
    for row in range(3):
        for col in range(3):
            pos = (row * 200 + 12, col * 200 + 12)
            if board[row][col] == 'X':
                screen.blit(crossImg, pos)
            elif board[row][col] == 'O':
                screen.blit(circleImg, pos)
    # 画网格
    width = 10
    color = dark_grey
    pygame.draw.line(screen, color, (200, 0), (200, 600), width)
    pygame.draw.line(screen, color, (400, 0), (400, 600), width)
    pygame.draw.line(screen, color, (0, 200), (600, 200), width)
    pygame.draw.line(screen, color, (0, 400), (600, 400), width)
    # 画边框
    pygame.draw.rect(screen, color, (0, 0, 10, 600))
    pygame.draw.rect(screen, color, (0, 0, 600, 10))
    pygame.draw.rect(screen, color, (590, 0, 10, 600))


def drawBottomMenu(mouse):
    pygame.draw.rect(screen, dark_grey, (0, 600, 600, 100))
    pygame.draw.rect(screen, light_grey, (10, 610, 580, 80))
    screen.blit(restartImg, (550, 610))
    # Hover animation
    if 550 < mouse[0] < 582 and 610 < mouse[1] < 642:
        screen.blit(restartHoveredImg, (548, 608))
    screen.blit(X_score, (200, 610))
    screen.blit(O_score, (370, 610))
    scoreboard = font.render(': %d x %d :' % (score['X'], score['O']), True, background_color, light_grey)
    screen.blit(scoreboard, (244, 610))


def visualizeMove(row, col, previewImg):
    if board[row][col] == '':
        screen.blit(previewImg, (row * 200 + 12, col * 200 + 12))


def playerMove(player, row, col):
    board[row][col] = player


def computerMove(player):
    bestScore = float('inf')
    for row in range(3):
        for col in range(3):
            if board[row][col] == '':
                board[row][col] = 'O'
                score = minimax(board, 'X')
                board[row][col] = ''
                if score < bestScore:
                    bestScore = score
                    bestMove = (row, col)
    board[bestMove[0]][bestMove[1]] = player


scores = {'X': 1, 'O': -1, 'tie': 0}


def minimax(board, cur_player):
    if isWinner('X'):
        return scores['X']
    elif isWinner('O'):
        return scores['O']
    elif isBoardFull():
        return scores['tie']
    if cur_player == 'X':
        bestScore = float('-inf')
        nextPlayer = 'O'
        minORmax = max
    else:
        bestScore = float('inf')
        nextPlayer = 'X'
        minORmax = min
    for row in range(3):
        for col in range(3):
            if board[row][col] == '':
                board[row][col] = cur_player
                score = minimax(board, nextPlayer)
                board[row][col] = ''
                bestScore = minORmax(score, bestScore)
            if bestScore == scores[cur_player]:
                return bestScore
    return bestScore


def updatePlayer(player):
    if player == 'X':
        newPlayer = 'O'
        previewImg = previewCircleImg
    else:
        newPlayer = 'X'
        previewImg = previewCrossImg
    return newPlayer, previewImg



def isWinner(player):
    return ((board[0][0] == player and board[0][1] == player and board[0][2] == player) or
            (board[1][0] == player and board[1][1] == player and board[1][2] == player) or
            (board[2][0] == player and board[2][1] == player and board[2][2] == player) or
            (board[0][0] == player and board[1][0] == player and board[2][0] == player) or
            (board[0][1] == player and board[1][1] == player and board[2][1] == player) or
            (board[0][2] == player and board[1][2] == player and board[2][2] == player) or
            (board[0][0] == player and board[1][1] == player and board[2][2] == player) or
            (board[0][2] == player and board[1][1] == player and board[2][0] == player))


def verifyWinner(player):
    global  Send_Flag,Receive_Flag,current_player,dataSocket,previewImg,gameMode,SOR
    if isWinner(player):
        print(player, "win")
        if gameMode ==2:
            previewImg = previewCrossImg
            current_player = 'X'  # 服务端先下
            SOR = 0
            # if player == 'X':
                # toSend = 'Over'
                # dataSocket.send(toSend.encode())
                # print("send_meseage:", toSend)
                # Send_Flag = 0
                # Receive_Flag = 1
        score[player] += 1
        ctypes.windll.user32.MessageBoxW(0, player + ' 获胜！', '提示', 0)
        resetBoard()
        return True
    return False


def isBoardFull():
    for i in range(3):
        for j in range(3):
            if board[i][j] == '':
                return False
    return True


def resetBoard():
    for i in range(3):
        for j in range(3):
            board[i][j] = ''

def Common_Reset():##对方刷新引起的刷新，被动刷新
    global Send_Flag,Receive_Flag,gameMode,current_player,previewImg,dataSocket
    resetBoard()
    score['X'] = 0
    score['O'] = 0
    if gameMode == 2:
        current_player = 'X'
        print("I have turn the picture to Cross")
        previewImg = previewCrossImg
def resetGame():##主动刷新
    global Send_Flag, Receive_Flag, gameMode, current_player, previewImg, dataSocket
    resetBoard()
    score['X'] = 0
    score['O'] = 0
    if gameMode == 2:
        current_player = 'X'
        print("I have turn the picture to Cross")
        previewImg = previewCrossImg

    resetBoard()
    score['X'] = 0
    score['O'] = 0
global i
i = 0
def handle(rec):
    global send_row, send_col ,Send_Flag,row, col,Receive_Flag, i, current_player, previewImg,message
    global pi_sure_flag, pi_row, pi_col, pr_flash
    if rec:
        re_sure_flag = int(pi_sure_flag.search(rec).group(1))
        re_row = int(pi_row.search(rec).group(1))
        re_col = int(pi_col.search(rec).group(1))
        re_flash = int(pi_flash.search(rec).group(1))
        if re_sure_flag == 1:
            counter_row = re_row
            counter_col = re_col
            board[counter_row][counter_col] = "X"
            drawBoard()
            current_player = 'O'  ##收到对面信息后回到主场
            pygame.display.update()
            previewImg = previewCircleImg
        if re_flash ==1 :
            Common_Reset()


def TCP_Client():
    global send_row, send_col ,Send_Flag,row, col,Receive_Flag, i, current_player, previewImg,message,SOR,sure_flag,flash_flag
    global pi_send_flag, pi_received_flag, pi_row, pi_col, pr_flash
    pi_sr = re.compile(r'SenOrRec(\d)')
    while True:
        if SOR == 1:
            print("waiting for receiving...........")
            recved = dataSocket.recv(BUFLEN)
            rec = recved.decode()
            if not recved:
                break
            if rec:
                handle(rec)
                print("received", rec)
                dataSocket.send(message.encode())
                SOR = 0
        # time.sleep(0.3)
        if SOR == 0:
            print("sending",message)
            dataSocket.send(message.encode())
            sure_flag = 0
            flash_flag = 0
            message = "sure_f" + str(sure_flag) + "row" + str(send_row) + " col" + str(send_col) + "flash" + str(flash_flag)
            SOR = 1


client_thread = threading.Thread(target=TCP_Client)
client_thread.start()

menu()
dataSoc
```

### 加入悔棋按钮

#### 服务端

```python
import pygame
import ctypes
# 导入socket 库
from socket import *
import threading
import time
import re

global pi_sure_flag,pi_row,pi_col,pi_flash,message,sure_flag,flash_flag,SOR

pi_sure_flag=re.compile(r'sure_f(\d)')
pi_row=re.compile(r'row(\d)')
pi_col=re.compile(r'col(\d)')
pi_flash=re.compile(r'flash(\d)')##刷新参数
message= "sure_f0 row0 col0 flash0 SenOrRec0"
sure_flag = 0
flash_flag = 0
send_row = 0
send_col = 0
SOR = 0 #0是发送
# 主机地址为空字符串，表示绑定本机所有网络接口ip地址
# 等待客户端来连接
IP = ''
# 端口号
PORT = 50000
# 定义一次从socket缓冲区最多读入512个字节数据
BUFLEN = 512

# 实例化一个socket对象
# 参数 AF_INET 表示该socket网络层使用IP协议
# 参数 SOCK_STREAM 表示该socket传输层使用TCP协议
listenSocket = socket(AF_INET, SOCK_STREAM)

# socket绑定地址和端口
listenSocket.bind((IP, PORT))


# 使socket处于监听状态，等待客户端的连接请求
# 参数 8 表示 最多接受多少个等待连接的客户端
listenSocket.listen(8)
print(f'服务端启动成功，在{PORT}端口等待客户端连接...')

dataSocket, addr = listenSocket.accept()
print('接受一个客户端连接:', addr)


global Send_Flag,Receive_Flag,Current_Player,If_over,previewImg,gameMode,Ini_FLag,Reset_Flag
# 初始化 pygame
pygame.init()

# 定义颜色
blue = (78, 140, 243)
light_blue = (100, 100, 255)
red = (242, 89, 97)
light_red = (255, 100, 100)
dark_grey = (85, 85, 85)
light_grey = (100, 100, 100)
background_color = (225, 225, 225)
Send_Flag = 0
Receive_Flag = 0##一开始不发送也不接受，主机
Current_Player = 'X'#X先下棋
If_over = 0
gameMode = 0
Ini_FLag = 1
# 创建窗口
screen = pygame.display.set_mode((600, 800))
pygame.display.set_caption('井字棋')

# 游戏图片
crossImg = pygame.image.load('Images/crossImg.png')
crossImg_rect = crossImg.get_rect()
crossImg_rect.center = (200, 300)
circleImg = pygame.image.load('Images/circleImg.png')
circleImg_rect = crossImg.get_rect()
circleImg_rect.center = (400, 300)
previewCrossImg = pygame.image.load('Images/prev_crossImg.png')
previewCircleImg = pygame.image.load('Images/prev_circleImg.png')

previewImg = previewCrossImg
# 按钮图片
restartImg = pygame.image.load('Images/restart.png')
restartHoveredImg = pygame.image.load('Images/restart_hovered.png')
ReGretImg = pygame.image.load('Images/button4Img.png')
# 定义棋盘
board = [['', '', ''],
         ['', '', ''],
         ['', '', '']]

# 定义计分板
score = {'X': 0, 'O': 0}
font = pygame.font.Font('freesansbold.ttf', 32)
X_score = pygame.image.load('Images/X_scoreImg.png')
O_score = pygame.image.load('Images/O_scoreImg.png')

# 菜单图片
buttom1 = pygame.image.load('Images/button1Img.png')
buttom1_rect = buttom1.get_rect()
buttom1_rect.center = (300, 312)
buttom2 = pygame.image.load('Images/button2Img.png')
buttom2_rect = buttom2.get_rect()
buttom2_rect.center = (300, 472)

buttom3 = pygame.image.load('Images/button3Img.png')
buttom3_rect = buttom3.get_rect()
buttom3_rect.center = (300, 632)

buttom4_rect = ReGretImg.get_rect()
buttom4_rect.center = (478, 751)

logo = pygame.image.load('Images/logo.png')

# 选择菜单图片
chooseImg = pygame.image.load('Images/choose.png')


def menu():
    global gameMode
    running = True
    while running:
        screen.fill(background_color)
        mx, my = pygame.mouse.get_pos()
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if buttom1_rect.collidepoint((mx, my)):
                    game(0, 'X')
                    gameMode = 0
                elif buttom2_rect.collidepoint((mx, my)):
                    player = choose()
                    if player is not None:
                        game(1, player)
                        gameMode =1
                elif buttom3_rect.collidepoint((mx, my)):
                    gameMode = 2
                    game(2, 'X')
        screen.blit(logo, (8, 25))
        screen.blit(buttom1, (100, 250))
        screen.blit(buttom2, (100, 410))
        screen.blit(buttom3, (100, 570))
        pygame.display.update()


def game(gameMode, player):
    global send_row, send_col ,Send_Flag,row, col,Receive_Flag,Current_Player,If_over,previewImg,message,sure_flag,flash_flag
    my = player
    player = 'X'
    running = True
    while running:
        mouse = pygame.mouse.get_pos()
        row, col = int(mouse[0] / 200), int(mouse[1] / 200)
        for event in pygame.event.get():
            if verifyWinner('X'):
                print("确认X胜利")
                player = 'X'
                previewImg = previewCrossImg
            if verifyWinner('O'):
                print("确认O胜利")
                player = 'X'
                previewImg = previewCrossImg
            if event.type == pygame.QUIT:
                resetGame()
                running = False
            elif isBoardFull():
                ctypes.windll.user32.MessageBoxW(0, '平局', '提示', 0)
                resetBoard()
            elif gameMode == 1 and player != my:
                computerMove(player)
                drawBoard()
                pygame.display.update()
                # if verifyWinner(player):
                #     player = 'X'
                #     previewImg = previewCrossImg
                # else:
                #     player, previewImg = updatePlayer(player)
                if verifyWinner(player):
                    player = 'X'
                    previewImg = previewCrossImg
                else:
                    player, previewImg = updatePlayer(player)
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if gameMode != 2:
                    if row < 3 and col < 3 and board[row][col] == '':
                        # send_row = row
                        # send_col = col
                        playerMove(player, row, col)
                        drawBoard()
                        Send_Flag = 1
                        time.sleep(0.5)
                        if verifyWinner('X'):
                            player = 'X'
                            previewImg = previewCrossImg
                        else :
                            player, previewImg = updatePlayer(player)
                if gameMode == 2:
                    if row < 3 and col < 3 and board[row][col] == '':
                        print("Current_Player", Current_Player)
                    if row < 3 and col < 3 and board[row][col] == '' and Current_Player == 'X':#自己的回合鼠标才能点击
                        sure_flag = 1
                        send_row = row
                        send_col = col
                        message = "sure_f"+str(sure_flag) + "row" + str(send_row)+" col"+str(send_col) + "flash"+ str(flash_flag)
                        time.sleep(0.3)
                        playerMove('X', row, col)
                        drawBoard()
                        Current_Player = 'O'#下完换对方
                        previewImg = previewCircleImg
                        print("I am going to Send message X")
                        time.sleep(0.5)
                        print("I am waiting for O message")
                    # else:
                    #         Receive_Flag = 1
                if 550 < mouse[0] < 582 and 610 < mouse[1] < 642:
                    flash_flag = 1
                    message = "sure_f" + str(sure_flag) + "row" + str(row) + " col" + str(col) + "flash" + str(
                        flash_flag)
                    resetGame()
                if buttom4_rect.collidepoint((mouse[0], mouse[1])):
                    if gameMode == 0:
                        print("按钮有效")

                        # time.sleep(0.5)


        screen.fill(background_color)
        drawBoard()
        drawBottomMenu(mouse)
        if row < 3 and col < 3:
            visualizeMove(row, col, previewImg)
        pygame.display.update()


def choose():
    player = None
    running = True
    while running:
        mouse = pygame.mouse.get_pos()
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if crossImg_rect.collidepoint((mouse[0], mouse[1])):
                    player = 'X'
                    running = False
                elif circleImg_rect.collidepoint((mouse[0], mouse[1])):
                    player = 'O'
                    running = False
        screen.blit(crossImg, (80, 300))
        screen.blit(circleImg, (340, 300))
        screen.blit(chooseImg, (8, 25))
        pygame.display.update()
    return player


def drawBoard():
    # 画棋子
    for row in range(3):
        for col in range(3):
            pos = (row * 200 + 12, col * 200 + 12)
            if board[row][col] == 'X':
                screen.blit(crossImg, pos)
            elif board[row][col] == 'O':
                screen.blit(circleImg, pos)
    # 画网格
    width = 10
    color = dark_grey
    pygame.draw.line(screen, color, (200, 0), (200, 600), width)
    pygame.draw.line(screen, color, (400, 0), (400, 600), width)
    pygame.draw.line(screen, color, (0, 200), (600, 200), width)
    pygame.draw.line(screen, color, (0, 400), (600, 400), width)
    # 画边框
    pygame.draw.rect(screen, color, (0, 0, 10, 600))
    pygame.draw.rect(screen, color, (0, 0, 600, 10))
    pygame.draw.rect(screen, color, (590, 0, 10, 600))


def drawBottomMenu(mouse):
    pygame.draw.rect(screen, dark_grey, (0, 600, 600, 100))
    pygame.draw.rect(screen, light_grey, (10, 610, 580, 80))
    screen.blit(restartImg, (550, 610))
    screen.blit(ReGretImg,(400,720))
    # Hover animation
    if 550 < mouse[0] < 582 and 610 < mouse[1] < 642:
        screen.blit(restartHoveredImg, (548, 608))
    screen.blit(X_score, (200, 610))
    screen.blit(O_score, (370, 610))
    scoreboard = font.render(': %d x %d :' % (score['X'], score['O']), True, background_color, light_grey)
    screen.blit(scoreboard, (244, 610))


def visualizeMove(row, col, previewImg):
    if board[row][col] == '':
        screen.blit(previewImg, (row * 200 + 12, col * 200 + 12))


def playerMove(player, row, col):
    board[row][col] = player

def CounterMove(row, col):
    board[row][col] = "O"


def computerMove(player):
    bestScore = float('inf')
    for row in range(3):
        for col in range(3):
            if board[row][col] == '':
                board[row][col] = 'O'
                score = minimax(board, 'X')
                board[row][col] = ''
                if score < bestScore:
                    bestScore = score
                    bestMove = (row, col)
    board[bestMove[0]][bestMove[1]] = player


scores = {'X': 1, 'O': -1, 'tie': 0}


def minimax(board, cur_player):
    if isWinner('X'):
        return scores['X']
    elif isWinner('O'):
        return scores['O']
    elif isBoardFull():
        return scores['tie']
    if cur_player == 'X':
        bestScore = float('-inf')
        nextPlayer = 'O'
        minORmax = max
    else:
        bestScore = float('inf')
        nextPlayer = 'X'
        minORmax = min
    for row in range(3):
        for col in range(3):
            if board[row][col] == '':
                board[row][col] = cur_player
                score = minimax(board, nextPlayer)
                board[row][col] = ''
                bestScore = minORmax(score, bestScore)
            if bestScore == scores[cur_player]:
                return bestScore
    return bestScore


def updatePlayer(player):
    if player == 'X':
        newPlayer = 'O'
        previewImg = previewCircleImg
    else:
        newPlayer = 'X'
        previewImg = previewCrossImg
    return newPlayer, previewImg



def isWinner(player):
    return ((board[0][0] == player and board[0][1] == player and board[0][2] == player) or
            (board[1][0] == player and board[1][1] == player and board[1][2] == player) or
            (board[2][0] == player and board[2][1] == player and board[2][2] == player) or
            (board[0][0] == player and board[1][0] == player and board[2][0] == player) or
            (board[0][1] == player and board[1][1] == player and board[2][1] == player) or
            (board[0][2] == player and board[1][2] == player and board[2][2] == player) or
            (board[0][0] == player and board[1][1] == player and board[2][2] == player) or
            (board[0][2] == player and board[1][1] == player and board[2][0] == player))


def verifyWinner(player):
    global Send_Flag, Receive_Flag, Current_Player,dataSocket,gameMode,previewImg
    if isWinner(player):
        # dataSocket.close()
        # dataSocket, addr = listenSocket.accept()
        print(player, "win")
        if gameMode == 2:
            print("I have turn current_player to X")
            Current_Player = 'X'  # X先下棋
            previewImg = previewCrossImg
            if player == 'O':
                toSend = 'Over'
                dataSocket.send(toSend.encode())
                print("send_meseage:",toSend)
                Send_Flag = 0
                Receive_Flag = 0  ##一开始不发送也不接受，主机

        score[player] += 1
        ctypes.windll.user32.MessageBoxW(0, player + ' 获胜！', '提示', 0)
        resetBoard()
        return True
    return False


def isBoardFull():
    for i in range(3):
        for j in range(3):
            if board[i][j] == '':
                return False
    return True


def resetBoard():
    for i in range(3):
        for j in range(3):
            board[i][j] = ''

def Common_Reset():##对方刷新引起的刷新
    global Send_Flag,Receive_Flag,gameMode,Current_Player,previewImg,dataSocket
    resetBoard()
    score['X'] = 0
    score['O'] = 0
    previewImg = previewCrossImg
    Current_Player = 'X'


def resetGame():
    global Send_Flag,Receive_Flag,gameMode,Current_Player,previewImg,dataSocket
    resetBoard()
    score['X'] = 0
    score['O'] = 0
    if gameMode == 2:
        Current_Player = 'X'
        print("I have turn the picture to Cross")
        previewImg = previewCrossImg


global i
i = 0

def handle(rec):
    global send_row, send_col, Send_Flag, row, col, Receive_Flag, i, Current_Player, previewImg, message
    global pi_sure_flag, pi_row, pi_col, pr_flash
    if rec:
        print("rec    in re",rec)
        re_sure_flag = int(pi_sure_flag.search(rec).group(1))
        re_row = int(pi_row.search(rec).group(1))
        re_col = int(pi_col.search(rec).group(1))
        re_flash = int(pi_flash.search(rec).group(1))
        if re_sure_flag == 1:
            counter_row = re_row
            counter_col = re_col
            board[counter_row][counter_col] = "O"
            drawBoard()
            Current_Player = 'X'  ##收到对面信息后回到主场
            previewImg = previewCrossImg
            pygame.display.update()

        if re_flash:
            Common_Reset()


def TCP_Server():
    global send_row, send_col, Send_Flag, row, col, Receive_Flag, i, current_player, previewImg, message,sure_flag,flash_flag,SOR
    global pi_send_flag, pi_received_flag, pi_row, pi_col, pr_flash
    pi_sr = re.compile(r'SenOrRec(\d)')
    while True:
        if SOR == 0:
            time.sleep(0.3)
            print("Send_message", message)
            dataSocket.send(message.encode())
            # time.sleep(0.3)
            sure_flag = 0
            flash_flag = 0
            message = "sure_f" + str(sure_flag) + "row" + str(send_row) + " col" + str(send_col) + "flash" + str(flash_flag)
            print("waiting for receiving...........")
            SOR = 1
        if SOR == 1:
            recved = dataSocket.recv(BUFLEN)
            rec = recved.decode()
            if not recved:
                break
            if rec:
                # re_SOR = pi_sr.search(rec)
                # SOR = re_SOR.group(1)
                handle(rec)
                print("received", rec)
                dataSocket.send(message.encode())
                SOR = 0


server_thread = threading.Thread(target = TCP_Server )
server_thread.start()
menu()
dataSocket.close()
listenSocket.close()
```

#### 客户端

```python
import pygame
import ctypes
#  === TCP 客户端程序 client.py ===
import time
from socket import *
import threading
import re

global pi_sure_flag,pi_row,pi_col,pi_flash,message,SOR,sure_flag,flash_flag

pi_sure_flag=re.compile(r'sure_f(\d)')
pi_row=re.compile(r'row(\d)')
pi_col=re.compile(r'col(\d)')
pi_flash=re.compile(r'flash(\d)')##刷新参数
message= "sure_f0 row0 col0 flash0 SenOrRec1"
SOR = 1
sure_flag = 0
flash_flag = 0
IP = '127.0.0.1'
SERVER_PORT = 50000
BUFLEN = 1024

# 实例化一个socket对象，指明协议
dataSocket = socket(AF_INET, SOCK_STREAM)
global Send_Flag,Receive_Flag,current_player,previewImg,gameMode
Send_Flag = 0
Receive_Flag = 1
current_player = 'X'#服务端先下
gameMode = 0
send_row = 0
send_col = 0
# 连接服务端socket
dataSocket.connect((IP, SERVER_PORT))
# 初始化 pygame
pygame.init()

# 定义颜色
blue = (78, 140, 243)
light_blue = (100, 100, 255)
red = (242, 89, 97)
light_red = (255, 100, 100)
dark_grey = (85, 85, 85)
light_grey = (100, 100, 100)
background_color = (225, 225, 225)

# 创建窗口
screen = pygame.display.set_mode((600, 800))
pygame.display.set_caption('井字棋-客户端')

# 游戏图片
crossImg = pygame.image.load('Images/crossImg.png')
crossImg_rect = crossImg.get_rect()
crossImg_rect.center = (200, 300)
circleImg = pygame.image.load('Images/circleImg.png')
circleImg_rect = crossImg.get_rect()
circleImg_rect.center = (400, 300)
previewCrossImg = pygame.image.load('Images/prev_crossImg.png')
previewCircleImg = pygame.image.load('Images/prev_circleImg.png')
previewImg = previewCrossImg
# 按钮图片
restartImg = pygame.image.load('Images/restart.png')
restartHoveredImg = pygame.image.load('Images/restart_hovered.png')
ReGretImg = pygame.image.load('Images/button4Img.png')

# 定义棋盘
board = [['', '', ''],
         ['', '', ''],
         ['', '', '']]

# 定义计分板
score = {'X': 0, 'O': 0}
font = pygame.font.Font('freesansbold.ttf', 32)
X_score = pygame.image.load('Images/X_scoreImg.png')
O_score = pygame.image.load('Images/O_scoreImg.png')

# 菜单图片
buttom1 = pygame.image.load('Images/button1Img.png')
buttom1_rect = buttom1.get_rect()
buttom1_rect.center = (300, 312)
buttom2 = pygame.image.load('Images/button2Img.png')
buttom2_rect = buttom2.get_rect()
buttom2_rect.center = (300, 472)
buttom3 = pygame.image.load('Images/button3Img.png')
buttom3_rect = buttom3.get_rect()
buttom3_rect.center = (300, 632)
buttom4_rect = ReGretImg.get_rect()
buttom4_rect.center = (478, 751)
logo = pygame.image.load('Images/logo.png')

# 选择菜单图片
chooseImg = pygame.image.load('Images/choose.png')


def menu():
    global gameMode
    running = True
    while running:
        screen.fill(background_color)
        mx, my = pygame.mouse.get_pos()
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if buttom1_rect.collidepoint((mx, my)):
                    gameMode= 0
                    game(0, 'X')
                elif buttom2_rect.collidepoint((mx, my)):
                    player = choose()
                    if player is not None:
                        gameMode= 1
                        game(1, player)
                elif buttom3_rect.collidepoint((mx, my)):
                    gameMode = 2
                    game(2, 'O')
        screen.blit(logo, (8, 25))
        screen.blit(buttom1, (100, 250))
        screen.blit(buttom2, (100, 410))
        screen.blit(buttom3, (100, 570))
        pygame.display.update()


def game(gameMode, player):
    global send_row, send_col, Send_Flag, Receive_Flag,row, col,current_player,previewImg,message,sure_flag,flash_flag
    my = player
    # player = current_player
    running = True
    if gameMode == 2:
        previewImg = previewCrossImg  # 服务端先下
    else:
        previewImg = previewCircleImg

    while running:
        mouse = pygame.mouse.get_pos()
        row, col = int(mouse[0] / 200), int(mouse[1] / 200)
        for event in pygame.event.get():
            if verifyWinner('O'):
                # player = 'O'
                # previewImg = previewCrossImg
                 pass
            if verifyWinner('X'):
                # player = 'X'
                # previewImg = previewCrossImg
                pass
            if event.type == pygame.QUIT:
                resetGame()
                running = False
            elif isBoardFull():
                ctypes.windll.user32.MessageBoxW(0, '平局', '提示', 0)
                resetBoard()
            elif gameMode == 1 and player != my:
                computerMove(player)
                drawBoard()
                pygame.display.update()
                if verifyWinner(player):
                    player = 'O'
                    previewImg = previewCrossImg
                else:
                    player, previewImg = updatePlayer(player)
            # elif gameMode == 2 and player != my:
            #     CounterMove(player)
            #     drawBoard()
            #     pygame.display.update()
            #     if verifyWinner(player):
            #         player = 'O'
            #         previewImg = previewCrossImg
            #     else:
            #         player, previewImg = updatePlayer(player)
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if gameMode != 2:
                    if row < 3 and col < 3 and board[row][col] == '':
                        send_row = row
                        send_col = col
                        playerMove(player, row, col)
                        drawBoard()
                        # Send_Flag = 1
                        # time.sleep(0.5)
                        if verifyWinner('O'):
                            player = 'X'
                            previewImg = previewCrossImg
                        else :
                            player, previewImg = updatePlayer(player)
                    #
                    #     else:
                    #         Receive_Flag = 1
                    # elif 550 < mouse[0] < 582 and 610 < mouse[1] < 642:
                    #     resetGame()
                if gameMode == 2:
                    if row < 3 and col < 3 and board[row][col] == '':
                        print("Current_Player", current_player)
                    if row < 3 and col < 3 and board[row][col] == '' and current_player == 'O':#自己的回合鼠标才能点击
                        send_row = row
                        send_col = col
                        sure_flag =1
                        message = "sure_f"+str(sure_flag) + "row" + str(send_row)+" col"+str(send_col) + "flash"+ str(flash_flag)+"SenOrRec1"
                        playerMove('O', row, col)
                        drawBoard()
                        current_player = 'X'#下完换对方
                        previewImg = previewCrossImg
                        Send_Flag = 1
                        Receive_Flag = 1
                        print("I am going to send O message")
                        # time.sleep(0.5)
                        print("I am wating for message")
                        # if verifyWinner(player):
                        #     player = 'O'
                        #     previewImg = previewCrossImg
                        # elif gameMode != 2:
                        #
                    # else:
                    #         Receive_Flag = 1
                if 550 < mouse[0] < 582 and 610 < mouse[1] < 642:
                    flash_flag = 1
                    message = "sure_f" + str(sure_flag) + "row" + str(send_row) + " col" + str(
                        send_col) + "flash" + str(flash_flag) + "SenOrRec1"
                    resetGame()
                if buttom4_rect.collidepoint((mouse[0], mouse[1])):
                    if gameMode == 0:
                        print("按钮有效")

        screen.fill(background_color)
        drawBoard()
        drawBottomMenu(mouse)
        if row < 3 and col < 3:
            visualizeMove(row, col, previewImg)
        pygame.display.update()


def choose():
    player = None
    running = True
    while running:
        mouse = pygame.mouse.get_pos()
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if crossImg_rect.collidepoint((mouse[0], mouse[1])):
                    player = 'X'
                    running = False
                elif circleImg_rect.collidepoint((mouse[0], mouse[1])):
                    player = 'O'
                    running = False
        screen.blit(crossImg, (80, 300))
        screen.blit(circleImg, (340, 300))
        screen.blit(chooseImg, (8, 25))
        pygame.display.update()
    return player


def drawBoard():
    # 画棋子
    for row in range(3):
        for col in range(3):
            pos = (row * 200 + 12, col * 200 + 12)
            if board[row][col] == 'X':
                screen.blit(crossImg, pos)
            elif board[row][col] == 'O':
                screen.blit(circleImg, pos)
    # 画网格
    width = 10
    color = dark_grey
    pygame.draw.line(screen, color, (200, 0), (200, 600), width)
    pygame.draw.line(screen, color, (400, 0), (400, 600), width)
    pygame.draw.line(screen, color, (0, 200), (600, 200), width)
    pygame.draw.line(screen, color, (0, 400), (600, 400), width)
    # 画边框
    pygame.draw.rect(screen, color, (0, 0, 10, 600))
    pygame.draw.rect(screen, color, (0, 0, 600, 10))
    pygame.draw.rect(screen, color, (590, 0, 10, 600))


def drawBottomMenu(mouse):
    pygame.draw.rect(screen, dark_grey, (0, 600, 600, 100))
    pygame.draw.rect(screen, light_grey, (10, 610, 580, 80))
    screen.blit(restartImg, (550, 610))
    screen.blit(ReGretImg,(400,720))
    # Hover animation
    if 550 < mouse[0] < 582 and 610 < mouse[1] < 642:
        screen.blit(restartHoveredImg, (548, 608))
    screen.blit(X_score, (200, 610))
    screen.blit(O_score, (370, 610))
    scoreboard = font.render(': %d x %d :' % (score['X'], score['O']), True, background_color, light_grey)
    screen.blit(scoreboard, (244, 610))


def visualizeMove(row, col, previewImg):
    if board[row][col] == '':
        screen.blit(previewImg, (row * 200 + 12, col * 200 + 12))


def playerMove(player, row, col):
    board[row][col] = player


def computerMove(player):
    bestScore = float('inf')
    for row in range(3):
        for col in range(3):
            if board[row][col] == '':
                board[row][col] = 'O'
                score = minimax(board, 'X')
                board[row][col] = ''
                if score < bestScore:
                    bestScore = score
                    bestMove = (row, col)
    board[bestMove[0]][bestMove[1]] = player


scores = {'X': 1, 'O': -1, 'tie': 0}


def minimax(board, cur_player):
    if isWinner('X'):
        return scores['X']
    elif isWinner('O'):
        return scores['O']
    elif isBoardFull():
        return scores['tie']
    if cur_player == 'X':
        bestScore = float('-inf')
        nextPlayer = 'O'
        minORmax = max
    else:
        bestScore = float('inf')
        nextPlayer = 'X'
        minORmax = min
    for row in range(3):
        for col in range(3):
            if board[row][col] == '':
                board[row][col] = cur_player
                score = minimax(board, nextPlayer)
                board[row][col] = ''
                bestScore = minORmax(score, bestScore)
            if bestScore == scores[cur_player]:
                return bestScore
    return bestScore


def updatePlayer(player):
    if player == 'X':
        newPlayer = 'O'
        previewImg = previewCircleImg
    else:
        newPlayer = 'X'
        previewImg = previewCrossImg
    return newPlayer, previewImg



def isWinner(player):
    return ((board[0][0] == player and board[0][1] == player and board[0][2] == player) or
            (board[1][0] == player and board[1][1] == player and board[1][2] == player) or
            (board[2][0] == player and board[2][1] == player and board[2][2] == player) or
            (board[0][0] == player and board[1][0] == player and board[2][0] == player) or
            (board[0][1] == player and board[1][1] == player and board[2][1] == player) or
            (board[0][2] == player and board[1][2] == player and board[2][2] == player) or
            (board[0][0] == player and board[1][1] == player and board[2][2] == player) or
            (board[0][2] == player and board[1][1] == player and board[2][0] == player))


def verifyWinner(player):
    global  Send_Flag,Receive_Flag,current_player,dataSocket,previewImg,gameMode,SOR
    if isWinner(player):
        print(player, "win")
        if gameMode ==2:
            previewImg = previewCrossImg
            current_player = 'X'  # 服务端先下
            SOR = 0
            # if player == 'X':
                # toSend = 'Over'
                # dataSocket.send(toSend.encode())
                # print("send_meseage:", toSend)
                # Send_Flag = 0
                # Receive_Flag = 1
        score[player] += 1
        ctypes.windll.user32.MessageBoxW(0, player + ' 获胜！', '提示', 0)
        resetBoard()
        return True
    return False


def isBoardFull():
    for i in range(3):
        for j in range(3):
            if board[i][j] == '':
                return False
    return True


def resetBoard():
    for i in range(3):
        for j in range(3):
            board[i][j] = ''

def Common_Reset():##对方刷新引起的刷新，被动刷新
    global Send_Flag,Receive_Flag,gameMode,current_player,previewImg,dataSocket
    resetBoard()
    score['X'] = 0
    score['O'] = 0
    if gameMode == 2:
        current_player = 'X'
        print("I have turn the picture to Cross")
        previewImg = previewCrossImg
def resetGame():##主动刷新
    global Send_Flag, Receive_Flag, gameMode, current_player, previewImg, dataSocket
    resetBoard()
    score['X'] = 0
    score['O'] = 0
    if gameMode == 2:
        current_player = 'X'
        print("I have turn the picture to Cross")
        previewImg = previewCrossImg

    resetBoard()
    score['X'] = 0
    score['O'] = 0
global i
i = 0
def handle(rec):
    global send_row, send_col ,Send_Flag,row, col,Receive_Flag, i, current_player, previewImg,message
    global pi_sure_flag, pi_row, pi_col, pr_flash
    if rec:
        re_sure_flag = int(pi_sure_flag.search(rec).group(1))
        re_row = int(pi_row.search(rec).group(1))
        re_col = int(pi_col.search(rec).group(1))
        re_flash = int(pi_flash.search(rec).group(1))
        if re_sure_flag == 1:
            counter_row = re_row
            counter_col = re_col
            board[counter_row][counter_col] = "X"
            drawBoard()
            current_player = 'O'  ##收到对面信息后回到主场
            previewImg = previewCircleImg
            pygame.display.update()
        if re_flash ==1 :
            Common_Reset()


def TCP_Client():
    global send_row, send_col ,Send_Flag,row, col,Receive_Flag, i, current_player, previewImg,message,SOR,sure_flag,flash_flag
    global pi_send_flag, pi_received_flag, pi_row, pi_col, pr_flash
    pi_sr = re.compile(r'SenOrRec(\d)')
    while True:
        if SOR == 1:
            print("waiting for receiving...........")
            recved = dataSocket.recv(BUFLEN)
            rec = recved.decode()
            if not recved:
                break
            if rec:
                handle(rec)
                print("received", rec)
                dataSocket.send(message.encode())
                SOR = 0
        # time.sleep(0.3)
        if SOR == 0:
            print("sending",message)
            dataSocket.send(message.encode())
            sure_flag = 0
            flash_flag = 0
            message = "sure_f" + str(sure_flag) + "row" + str(send_row) + " col" + str(send_col) + "flash" + str(flash_flag)
            SOR = 1


client_thread = threading.Thread(target=TCP_Client)
client_thread.start()

menu()
dataSocket.close()
```

### 悔棋按钮模式0

```python
import pygame
import ctypes
# 导入socket 库
from socket import *
import threading
import time
import re
global pi_sure_flag,pi_row,pi_col,pi_flash,message,sure_flag,flash_flag,SOR, board,over_pos

pi_sure_flag=re.compile(r'sure_f(\d)')
pi_row=re.compile(r'row(\d)')
pi_col=re.compile(r'col(\d)')
pi_flash=re.compile(r'flash(\d)')##刷新参数
message= "sure_f0 row0 col0 flash0 SenOrRec0"
sure_flag = 0
flash_flag = 0
over_pos= []
send_row = 0
send_col = 0
SOR = 0 #0是发送
# 主机地址为空字符串，表示绑定本机所有网络接口ip地址
# 等待客户端来连接
IP = ''
# 端口号
PORT = 50000
# 定义一次从socket缓冲区最多读入512个字节数据
BUFLEN = 512

# 实例化一个socket对象
# 参数 AF_INET 表示该socket网络层使用IP协议
# 参数 SOCK_STREAM 表示该socket传输层使用TCP协议
listenSocket = socket(AF_INET, SOCK_STREAM)

# socket绑定地址和端口
listenSocket.bind((IP, PORT))


# 使socket处于监听状态，等待客户端的连接请求
# 参数 8 表示 最多接受多少个等待连接的客户端
listenSocket.listen(8)
print(f'服务端启动成功，在{PORT}端口等待客户端连接...')

dataSocket, addr = listenSocket.accept()
print('接受一个客户端连接:', addr)


global Send_Flag,Receive_Flag,Current_Player,If_over,previewImg,gameMode,Ini_FLag,Reset_Flag
# 初始化 pygame
pygame.init()

# 定义颜色
blue = (78, 140, 243)
light_blue = (100, 100, 255)
red = (242, 89, 97)
light_red = (255, 100, 100)
dark_grey = (85, 85, 85)
light_grey = (100, 100, 100)
background_color = (225, 225, 225)
Send_Flag = 0
Receive_Flag = 0##一开始不发送也不接受，主机
Current_Player = 'X'#X先下棋
If_over = 0
gameMode = 0
Ini_FLag = 1
# 创建窗口
screen = pygame.display.set_mode((600, 800))
pygame.display.set_caption('井字棋')

# 游戏图片
crossImg = pygame.image.load('Images/crossImg.png')
crossImg_rect = crossImg.get_rect()
crossImg_rect.center = (200, 300)
circleImg = pygame.image.load('Images/circleImg.png')
circleImg_rect = crossImg.get_rect()
circleImg_rect.center = (400, 300)
previewCrossImg = pygame.image.load('Images/prev_crossImg.png')
previewCircleImg = pygame.image.load('Images/prev_circleImg.png')

previewImg = previewCrossImg
# 按钮图片
restartImg = pygame.image.load('Images/restart.png')
restartHoveredImg = pygame.image.load('Images/restart_hovered.png')
ReGretImg = pygame.image.load('Images/button4Img.png')
# 定义棋盘
board = [['', '', ''],
         ['', '', ''],
         ['', '', '']]

# 定义计分板
score = {'X': 0, 'O': 0}
font = pygame.font.Font('freesansbold.ttf', 32)
X_score = pygame.image.load('Images/X_scoreImg.png')
O_score = pygame.image.load('Images/O_scoreImg.png')

# 菜单图片
buttom1 = pygame.image.load('Images/button1Img.png')
buttom1_rect = buttom1.get_rect()
buttom1_rect.center = (300, 312)
buttom2 = pygame.image.load('Images/button2Img.png')
buttom2_rect = buttom2.get_rect()
buttom2_rect.center = (300, 472)

buttom3 = pygame.image.load('Images/button3Img.png')
buttom3_rect = buttom3.get_rect()
buttom3_rect.center = (300, 632)

buttom4_rect = ReGretImg.get_rect()
buttom4_rect.center = (478, 751)

logo = pygame.image.load('Images/logo.png')

# 选择菜单图片
chooseImg = pygame.image.load('Images/choose.png')


def menu():
    global gameMode
    running = True
    while running:
        screen.fill(background_color)
        mx, my = pygame.mouse.get_pos()
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if buttom1_rect.collidepoint((mx, my)):
                    game(0, 'X')
                    gameMode = 0
                elif buttom2_rect.collidepoint((mx, my)):
                    player = choose()
                    if player is not None:
                        game(1, player)
                        gameMode =1
                elif buttom3_rect.collidepoint((mx, my)):
                    gameMode = 2
                    game(2, 'X')
        screen.blit(logo, (8, 25))
        screen.blit(buttom1, (100, 250))
        screen.blit(buttom2, (100, 410))
        screen.blit(buttom3, (100, 570))
        pygame.display.update()


def game(gameMode, player):
    global send_row, send_col ,Send_Flag,row, col,Receive_Flag,Current_Player,If_over,previewImg,message,sure_flag,flash_flag,board
    my = player
    player = 'X'
    running = True
    while running:
        mouse = pygame.mouse.get_pos()
        row, col = int(mouse[0] / 200), int(mouse[1] / 200)
        for event in pygame.event.get():
            if verifyWinner('X'):
                print("确认X胜利")
                player = 'X'
                previewImg = previewCrossImg
            if verifyWinner('O'):
                print("确认O胜利")
                player = 'X'
                previewImg = previewCrossImg
            if event.type == pygame.QUIT:
                resetGame()
                running = False
            elif isBoardFull():
                ctypes.windll.user32.MessageBoxW(0, '平局', '提示', 0)
                resetBoard()
            elif gameMode == 1 and player != my:
                computerMove(player)
                drawBoard()
                pygame.display.update()
                # if verifyWinner(player):
                #     player = 'X'
                #     previewImg = previewCrossImg
                # else:
                #     player, previewImg = updatePlayer(player)
                if verifyWinner(player):
                    player = 'X'
                    previewImg = previewCrossImg
                else:
                    player, previewImg = updatePlayer(player)
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if gameMode != 2:
                    if row < 3 and col < 3 and board[row][col] == '':
                        # send_row = row
                        # send_col = col
                        playerMove(player, row, col)
                        drawBoard()
                        Send_Flag = 1
                        time.sleep(0.5)
                        if verifyWinner('X'):
                            player = 'X'
                            previewImg = previewCrossImg
                        else :
                            player, previewImg = updatePlayer(player)
                if gameMode == 2:
                    if row < 3 and col < 3 and board[row][col] == '':
                        print("Current_Player", Current_Player)
                    if row < 3 and col < 3 and board[row][col] == '' and Current_Player == 'X':#自己的回合鼠标才能点击
                        sure_flag = 1
                        send_row = row
                        send_col = col
                        message = "sure_f"+str(sure_flag) + "row" + str(send_row)+" col"+str(send_col) + "flash"+ str(flash_flag)
                        time.sleep(0.3)
                        playerMove('X', row, col)
                        drawBoard()
                        Current_Player = 'O'#下完换对方
                        previewImg = previewCircleImg
                        print("I am going to Send message X")
                        time.sleep(0.5)
                        print("I am waiting for O message")
                    # else:
                    #         Receive_Flag = 1
                if 550 < mouse[0] < 582 and 610 < mouse[1] < 642:
                    flash_flag = 1
                    message = "sure_f" + str(sure_flag) + "row" + str(row) + " col" + str(col) + "flash" + str(
                        flash_flag)
                    resetGame()
                if buttom4_rect.collidepoint((mouse[0], mouse[1])):
                    if gameMode == 0:
                        print("按钮有效")
                        lenth =len(over_pos)
                        if lenth > 0:
                            x = over_pos[lenth - 1][0]
                            y = over_pos[lenth - 1][1]
                            del over_pos[lenth-1]
                            if lenth == 1:
                                resetGame()
                            elif board[x][y] == "X":
                                print("regret x")
                                Current_Player = "O"
                                previewImg = previewCircleImg
                                board[x][y] = " "
                                drawBoard()
                            elif board[x][y] == "O":
                                print("regret o")
                                Current_Player = "X"
                                previewImg = previewCrossImg
                                board[x][y] = " "
                                drawBoard()
                            pygame.display.update()
                        # time.sleep(0.5)


        screen.fill(background_color)
        drawBoard()
        drawBottomMenu(mouse)
        if row < 3 and col < 3:
            visualizeMove(row, col, previewImg)
        pygame.display.update()


def choose():
    player = None
    running = True
    while running:
        mouse = pygame.mouse.get_pos()
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if crossImg_rect.collidepoint((mouse[0], mouse[1])):
                    player = 'X'
                    running = False
                elif circleImg_rect.collidepoint((mouse[0], mouse[1])):
                    player = 'O'
                    running = False
        screen.blit(crossImg, (80, 300))
        screen.blit(circleImg, (340, 300))
        screen.blit(chooseImg, (8, 25))
        pygame.display.update()
    return player


def drawBoard():
    # 画棋子
    for row in range(3):
        for col in range(3):
            pos = (row * 200 + 12, col * 200 + 12)
            if board[row][col] == 'X':
                screen.blit(crossImg, pos)
            elif board[row][col] == 'O':
                screen.blit(circleImg, pos)
    # 画网格
    width = 10
    color = dark_grey
    pygame.draw.line(screen, color, (200, 0), (200, 600), width)
    pygame.draw.line(screen, color, (400, 0), (400, 600), width)
    pygame.draw.line(screen, color, (0, 200), (600, 200), width)
    pygame.draw.line(screen, color, (0, 400), (600, 400), width)
    # 画边框
    pygame.draw.rect(screen, color, (0, 0, 10, 600))
    pygame.draw.rect(screen, color, (0, 0, 600, 10))
    pygame.draw.rect(screen, color, (590, 0, 10, 600))


def drawBottomMenu(mouse):
    pygame.draw.rect(screen, dark_grey, (0, 600, 600, 100))
    pygame.draw.rect(screen, light_grey, (10, 610, 580, 80))
    screen.blit(restartImg, (550, 610))
    screen.blit(ReGretImg,(400,720))
    # Hover animation
    if 550 < mouse[0] < 582 and 610 < mouse[1] < 642:
        screen.blit(restartHoveredImg, (548, 608))
    screen.blit(X_score, (200, 610))
    screen.blit(O_score, (370, 610))
    scoreboard = font.render(': %d x %d :' % (score['X'], score['O']), True, background_color, light_grey)
    screen.blit(scoreboard, (244, 610))


def visualizeMove(row, col, previewImg):
    if board[row][col] == '':
        screen.blit(previewImg, (row * 200 + 12, col * 200 + 12))


def playerMove(player, row, col):
    board[row][col] = player
    over_pos.append((row,col))
def CounterMove(row, col):
    board[row][col] = "O"


def computerMove(player):
    bestScore = float('inf')
    for row in range(3):
        for col in range(3):
            if board[row][col] == '':
                board[row][col] = 'O'
                score = minimax(board, 'X')
                board[row][col] = ''
                if score < bestScore:
                    bestScore = score
                    bestMove = (row, col)
    board[bestMove[0]][bestMove[1]] = player


scores = {'X': 1, 'O': -1, 'tie': 0}


def minimax(board, cur_player):
    if isWinner('X'):
        return scores['X']
    elif isWinner('O'):
        return scores['O']
    elif isBoardFull():
        return scores['tie']
    if cur_player == 'X':
        bestScore = float('-inf')
        nextPlayer = 'O'
        minORmax = max
    else:
        bestScore = float('inf')
        nextPlayer = 'X'
        minORmax = min
    for row in range(3):
        for col in range(3):
            if board[row][col] == '':
                board[row][col] = cur_player
                score = minimax(board, nextPlayer)
                board[row][col] = ''
                bestScore = minORmax(score, bestScore)
            if bestScore == scores[cur_player]:
                return bestScore
    return bestScore


def updatePlayer(player):
    if player == 'X':
        newPlayer = 'O'
        previewImg = previewCircleImg
    else:
        newPlayer = 'X'
        previewImg = previewCrossImg
    return newPlayer, previewImg



def isWinner(player):
    return ((board[0][0] == player and board[0][1] == player and board[0][2] == player) or
            (board[1][0] == player and board[1][1] == player and board[1][2] == player) or
            (board[2][0] == player and board[2][1] == player and board[2][2] == player) or
            (board[0][0] == player and board[1][0] == player and board[2][0] == player) or
            (board[0][1] == player and board[1][1] == player and board[2][1] == player) or
            (board[0][2] == player and board[1][2] == player and board[2][2] == player) or
            (board[0][0] == player and board[1][1] == player and board[2][2] == player) or
            (board[0][2] == player and board[1][1] == player and board[2][0] == player))


def verifyWinner(player):
    global Send_Flag, Receive_Flag, Current_Player,dataSocket,gameMode,previewImg
    if isWinner(player):
        # dataSocket.close()
        # dataSocket, addr = listenSocket.accept()
        print(player, "win")
        if gameMode == 2:
            print("I have turn current_player to X")
            Current_Player = 'X'  # X先下棋
            previewImg = previewCrossImg
            if player == 'O':
                toSend = 'Over'
                dataSocket.send(toSend.encode())
                print("send_meseage:",toSend)
                Send_Flag = 0
                Receive_Flag = 0  ##一开始不发送也不接受，主机

        score[player] += 1
        ctypes.windll.user32.MessageBoxW(0, player + ' 获胜！', '提示', 0)
        resetBoard()
        return True
    return False


def isBoardFull():
    for i in range(3):
        for j in range(3):
            if board[i][j] == '':
                return False
    return True


def resetBoard():
    for i in range(3):
        for j in range(3):
            board[i][j] = ''

def Common_Reset():##对方刷新引起的刷新
    global Send_Flag,Receive_Flag,gameMode,Current_Player,previewImg,dataSocket
    resetBoard()
    score['X'] = 0
    score['O'] = 0
    previewImg = previewCrossImg
    Current_Player = 'X'


def resetGame():
    global Send_Flag,Receive_Flag,gameMode,Current_Player,previewImg,dataSocket
    resetBoard()
    score['X'] = 0
    score['O'] = 0
    if gameMode == 2:
        Current_Player = 'X'
        print("I have turn the picture to Cross")
        previewImg = previewCrossImg


global i
i = 0

def handle(rec):
    global send_row, send_col, Send_Flag, row, col, Receive_Flag, i, Current_Player, previewImg, message
    global pi_sure_flag, pi_row, pi_col, pr_flash
    if rec:
        print("rec    in re",rec)
        re_sure_flag = int(pi_sure_flag.search(rec).group(1))
        re_row = int(pi_row.search(rec).group(1))
        re_col = int(pi_col.search(rec).group(1))
        re_flash = int(pi_flash.search(rec).group(1))
        if re_sure_flag == 1:
            counter_row = re_row
            counter_col = re_col
            board[counter_row][counter_col] = "O"
            drawBoard()
            Current_Player = 'X'  ##收到对面信息后回到主场
            previewImg = previewCrossImg
            pygame.display.update()

        if re_flash:
            Common_Reset()


def TCP_Server():
    global send_row, send_col, Send_Flag, row, col, Receive_Flag, i, current_player, previewImg, message,sure_flag,flash_flag,SOR
    global pi_send_flag, pi_received_flag, pi_row, pi_col, pr_flash
    pi_sr = re.compile(r'SenOrRec(\d)')
    while True:
        if SOR == 0:
            time.sleep(0.3)
            print("Send_message", message)
            dataSocket.send(message.encode())
            # time.sleep(0.3)
            sure_flag = 0
            flash_flag = 0
            message = "sure_f" + str(sure_flag) + "row" + str(send_row) + " col" + str(send_col) + "flash" + str(flash_flag)
            print("waiting for receiving...........")
            SOR = 1
        if SOR == 1:
            recved = dataSocket.recv(BUFLEN)
            rec = recved.decode()
            if not recved:
                break
            if rec:
                # re_SOR = pi_sr.search(rec)
                # SOR = re_SOR.group(1)
                handle(rec)
                print("received", rec)
                dataSocket.send(message.encode())
                SOR = 0


server_thread = threading.Thread(target = TCP_Server )
server_thread.start()
menu()
dataSocket.close()
listenSocket.close()
```

#### 客户端

```python
import pygame
import ctypes
#  === TCP 客户端程序 client.py ===
import time
from socket import *
import threading
import re

global pi_sure_flag,pi_row,pi_col,pi_flash,message,SOR,sure_flag,flash_flag,over_pos

pi_sure_flag=re.compile(r'sure_f(\d)')
pi_row=re.compile(r'row(\d)')
pi_col=re.compile(r'col(\d)')
pi_flash=re.compile(r'flash(\d)')##刷新参数
message= "sure_f0 row0 col0 flash0 SenOrRec1"
SOR = 1
sure_flag = 0
flash_flag = 0
over_pos= []
IP = '127.0.0.1'
SERVER_PORT = 50000
BUFLEN = 1024

# 实例化一个socket对象，指明协议
dataSocket = socket(AF_INET, SOCK_STREAM)
global Send_Flag,Receive_Flag,current_player,previewImg,gameMode
Send_Flag = 0
Receive_Flag = 1
current_player = 'X'#服务端先下
gameMode = 0
send_row = 0
send_col = 0
# 连接服务端socket
dataSocket.connect((IP, SERVER_PORT))
# 初始化 pygame
pygame.init()

# 定义颜色
blue = (78, 140, 243)
light_blue = (100, 100, 255)
red = (242, 89, 97)
light_red = (255, 100, 100)
dark_grey = (85, 85, 85)
light_grey = (100, 100, 100)
background_color = (225, 225, 225)

# 创建窗口
screen = pygame.display.set_mode((600, 800))
pygame.display.set_caption('井字棋-客户端')

# 游戏图片
crossImg = pygame.image.load('Images/crossImg.png')
crossImg_rect = crossImg.get_rect()
crossImg_rect.center = (200, 300)
circleImg = pygame.image.load('Images/circleImg.png')
circleImg_rect = crossImg.get_rect()
circleImg_rect.center = (400, 300)
previewCrossImg = pygame.image.load('Images/prev_crossImg.png')
previewCircleImg = pygame.image.load('Images/prev_circleImg.png')
previewImg = previewCrossImg
# 按钮图片
restartImg = pygame.image.load('Images/restart.png')
restartHoveredImg = pygame.image.load('Images/restart_hovered.png')
ReGretImg = pygame.image.load('Images/button4Img.png')

# 定义棋盘
board = [['', '', ''],
         ['', '', ''],
         ['', '', '']]

# 定义计分板
score = {'X': 0, 'O': 0}
font = pygame.font.Font('freesansbold.ttf', 32)
X_score = pygame.image.load('Images/X_scoreImg.png')
O_score = pygame.image.load('Images/O_scoreImg.png')

# 菜单图片
buttom1 = pygame.image.load('Images/button1Img.png')
buttom1_rect = buttom1.get_rect()
buttom1_rect.center = (300, 312)
buttom2 = pygame.image.load('Images/button2Img.png')
buttom2_rect = buttom2.get_rect()
buttom2_rect.center = (300, 472)
buttom3 = pygame.image.load('Images/button3Img.png')
buttom3_rect = buttom3.get_rect()
buttom3_rect.center = (300, 632)
buttom4_rect = ReGretImg.get_rect()
buttom4_rect.center = (478, 751)
logo = pygame.image.load('Images/logo.png')

# 选择菜单图片
chooseImg = pygame.image.load('Images/choose.png')


def menu():
    global gameMode
    running = True
    while running:
        screen.fill(background_color)
        mx, my = pygame.mouse.get_pos()
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if buttom1_rect.collidepoint((mx, my)):
                    gameMode= 0
                    game(0, 'X')
                elif buttom2_rect.collidepoint((mx, my)):
                    player = choose()
                    if player is not None:
                        gameMode= 1
                        game(1, player)
                elif buttom3_rect.collidepoint((mx, my)):
                    gameMode = 2
                    game(2, 'O')
        screen.blit(logo, (8, 25))
        screen.blit(buttom1, (100, 250))
        screen.blit(buttom2, (100, 410))
        screen.blit(buttom3, (100, 570))
        pygame.display.update()


def game(gameMode, player):
    global send_row, send_col, Send_Flag, Receive_Flag,row, col,current_player,previewImg,message,sure_flag,flash_flag,over_pos
    my = player
    # player = current_player
    running = True
    if gameMode == 2:
        previewImg = previewCrossImg  # 服务端先下
    else:
        previewImg = previewCircleImg

    while running:
        mouse = pygame.mouse.get_pos()
        row, col = int(mouse[0] / 200), int(mouse[1] / 200)
        for event in pygame.event.get():
            if verifyWinner('O'):
                # player = 'O'
                # previewImg = previewCrossImg
                 pass
            if verifyWinner('X'):
                # player = 'X'
                # previewImg = previewCrossImg
                pass
            if event.type == pygame.QUIT:
                resetGame()
                running = False
            elif isBoardFull():
                ctypes.windll.user32.MessageBoxW(0, '平局', '提示', 0)
                resetBoard()
            elif gameMode == 1 and player != my:
                computerMove(player)
                drawBoard()
                pygame.display.update()
                if verifyWinner(player):
                    player = 'O'
                    previewImg = previewCrossImg
                else:
                    player, previewImg = updatePlayer(player)
            # elif gameMode == 2 and player != my:
            #     CounterMove(player)
            #     drawBoard()
            #     pygame.display.update()
            #     if verifyWinner(player):
            #         player = 'O'
            #         previewImg = previewCrossImg
            #     else:
            #         player, previewImg = updatePlayer(player)
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if gameMode != 2:
                    if row < 3 and col < 3 and board[row][col] == '':
                        send_row = row
                        send_col = col
                        playerMove(player, row, col)
                        drawBoard()
                        # Send_Flag = 1
                        # time.sleep(0.5)
                        if verifyWinner('O'):
                            player = 'X'
                            previewImg = previewCrossImg
                        else :
                            player, previewImg = updatePlayer(player)
                    #
                    #     else:
                    #         Receive_Flag = 1
                    # elif 550 < mouse[0] < 582 and 610 < mouse[1] < 642:
                    #     resetGame()
                if gameMode == 2:
                    if row < 3 and col < 3 and board[row][col] == '':
                        print("Current_Player", current_player)
                    if row < 3 and col < 3 and board[row][col] == '' and current_player == 'O':#自己的回合鼠标才能点击
                        send_row = row
                        send_col = col
                        sure_flag =1
                        message = "sure_f"+str(sure_flag) + "row" + str(send_row)+" col"+str(send_col) + "flash"+ str(flash_flag)+"SenOrRec1"
                        playerMove('O', row, col)
                        drawBoard()
                        current_player = 'X'#下完换对方
                        previewImg = previewCrossImg
                        Send_Flag = 1
                        Receive_Flag = 1
                        print("I am going to send O message")
                        # time.sleep(0.5)
                        print("I am wating for message")
                        # if verifyWinner(player):
                        #     player = 'O'
                        #     previewImg = previewCrossImg
                        # elif gameMode != 2:
                        #
                    # else:
                    #         Receive_Flag = 1
                if 550 < mouse[0] < 582 and 610 < mouse[1] < 642:
                    flash_flag = 1
                    message = "sure_f" + str(sure_flag) + "row" + str(send_row) + " col" + str(
                        send_col) + "flash" + str(flash_flag) + "SenOrRec1"
                    resetGame()
                if buttom4_rect.collidepoint((mouse[0], mouse[1])):
                    if gameMode == 0:
                        print("按钮有效")
                        lenth =len(over_pos)
                        if lenth > 0:
                            x = over_pos[lenth - 1][0]
                            y = over_pos[lenth - 1][1]
                            del over_pos[lenth-1]
                            if lenth == 1:
                                resetGame()
                            elif board[x][y] == "X":
                                print("regret x")
                                Current_Player = "O"
                                previewImg = previewCircleImg
                                board[x][y] = " "
                                drawBoard()
                            elif board[x][y] == "O":
                                print("regret o")
                                Current_Player = "X"
                                previewImg = previewCrossImg
                                board[x][y] = " "
                                drawBoard()
                            pygame.display.update()


        screen.fill(background_color)
        drawBoard()
        drawBottomMenu(mouse)
        if row < 3 and col < 3:
            visualizeMove(row, col, previewImg)
        pygame.display.update()


def choose():
    player = None
    running = True
    while running:
        mouse = pygame.mouse.get_pos()
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if crossImg_rect.collidepoint((mouse[0], mouse[1])):
                    player = 'X'
                    running = False
                elif circleImg_rect.collidepoint((mouse[0], mouse[1])):
                    player = 'O'
                    running = False
        screen.blit(crossImg, (80, 300))
        screen.blit(circleImg, (340, 300))
        screen.blit(chooseImg, (8, 25))
        pygame.display.update()
    return player


def drawBoard():
    # 画棋子
    for row in range(3):
        for col in range(3):
            pos = (row * 200 + 12, col * 200 + 12)
            if board[row][col] == 'X':
                screen.blit(crossImg, pos)
            elif board[row][col] == 'O':
                screen.blit(circleImg, pos)
    # 画网格
    width = 10
    color = dark_grey
    pygame.draw.line(screen, color, (200, 0), (200, 600), width)
    pygame.draw.line(screen, color, (400, 0), (400, 600), width)
    pygame.draw.line(screen, color, (0, 200), (600, 200), width)
    pygame.draw.line(screen, color, (0, 400), (600, 400), width)
    # 画边框
    pygame.draw.rect(screen, color, (0, 0, 10, 600))
    pygame.draw.rect(screen, color, (0, 0, 600, 10))
    pygame.draw.rect(screen, color, (590, 0, 10, 600))


def drawBottomMenu(mouse):
    pygame.draw.rect(screen, dark_grey, (0, 600, 600, 100))
    pygame.draw.rect(screen, light_grey, (10, 610, 580, 80))
    screen.blit(restartImg, (550, 610))
    screen.blit(ReGretImg,(400,720))
    # Hover animation
    if 550 < mouse[0] < 582 and 610 < mouse[1] < 642:
        screen.blit(restartHoveredImg, (548, 608))
    screen.blit(X_score, (200, 610))
    screen.blit(O_score, (370, 610))
    scoreboard = font.render(': %d x %d :' % (score['X'], score['O']), True, background_color, light_grey)
    screen.blit(scoreboard, (244, 610))


def visualizeMove(row, col, previewImg):
    if board[row][col] == '':
        screen.blit(previewImg, (row * 200 + 12, col * 200 + 12))


def playerMove(player, row, col):
    board[row][col] = player
    over_pos.append((row,col))

def computerMove(player):
    bestScore = float('inf')
    for row in range(3):
        for col in range(3):
            if board[row][col] == '':
                board[row][col] = 'O'
                score = minimax(board, 'X')
                board[row][col] = ''
                if score < bestScore:
                    bestScore = score
                    bestMove = (row, col)
    board[bestMove[0]][bestMove[1]] = player


scores = {'X': 1, 'O': -1, 'tie': 0}


def minimax(board, cur_player):
    if isWinner('X'):
        return scores['X']
    elif isWinner('O'):
        return scores['O']
    elif isBoardFull():
        return scores['tie']
    if cur_player == 'X':
        bestScore = float('-inf')
        nextPlayer = 'O'
        minORmax = max
    else:
        bestScore = float('inf')
        nextPlayer = 'X'
        minORmax = min
    for row in range(3):
        for col in range(3):
            if board[row][col] == '':
                board[row][col] = cur_player
                score = minimax(board, nextPlayer)
                board[row][col] = ''
                bestScore = minORmax(score, bestScore)
            if bestScore == scores[cur_player]:
                return bestScore
    return bestScore


def updatePlayer(player):
    if player == 'X':
        newPlayer = 'O'
        previewImg = previewCircleImg
    else:
        newPlayer = 'X'
        previewImg = previewCrossImg
    return newPlayer, previewImg



def isWinner(player):
    return ((board[0][0] == player and board[0][1] == player and board[0][2] == player) or
            (board[1][0] == player and board[1][1] == player and board[1][2] == player) or
            (board[2][0] == player and board[2][1] == player and board[2][2] == player) or
            (board[0][0] == player and board[1][0] == player and board[2][0] == player) or
            (board[0][1] == player and board[1][1] == player and board[2][1] == player) or
            (board[0][2] == player and board[1][2] == player and board[2][2] == player) or
            (board[0][0] == player and board[1][1] == player and board[2][2] == player) or
            (board[0][2] == player and board[1][1] == player and board[2][0] == player))


def verifyWinner(player):
    global  Send_Flag,Receive_Flag,current_player,dataSocket,previewImg,gameMode,SOR
    if isWinner(player):
        print(player, "win")
        if gameMode ==2:
            previewImg = previewCrossImg
            current_player = 'X'  # 服务端先下
            SOR = 0
            # if player == 'X':
                # toSend = 'Over'
                # dataSocket.send(toSend.encode())
                # print("send_meseage:", toSend)
                # Send_Flag = 0
                # Receive_Flag = 1
        score[player] += 1
        ctypes.windll.user32.MessageBoxW(0, player + ' 获胜！', '提示', 0)
        resetBoard()
        return True
    return False


def isBoardFull():
    for i in range(3):
        for j in range(3):
            if board[i][j] == '':
                return False
    return True


def resetBoard():
    for i in range(3):
        for j in range(3):
            board[i][j] = ''

def Common_Reset():##对方刷新引起的刷新，被动刷新
    global Send_Flag,Receive_Flag,gameMode,current_player,previewImg,dataSocket
    resetBoard()
    score['X'] = 0
    score['O'] = 0
    if gameMode == 2:
        current_player = 'X'
        print("I have turn the picture to Cross")
        previewImg = previewCrossImg
def resetGame():##主动刷新
    global Send_Flag, Receive_Flag, gameMode, current_player, previewImg, dataSocket
    resetBoard()
    score['X'] = 0
    score['O'] = 0
    if gameMode == 2:
        current_player = 'X'
        print("I have turn the picture to Cross")
        previewImg = previewCrossImg

    resetBoard()
    score['X'] = 0
    score['O'] = 0
global i
i = 0
def handle(rec):
    global send_row, send_col ,Send_Flag,row, col,Receive_Flag, i, current_player, previewImg,message
    global pi_sure_flag, pi_row, pi_col, pr_flash
    if rec:
        re_sure_flag = int(pi_sure_flag.search(rec).group(1))
        re_row = int(pi_row.search(rec).group(1))
        re_col = int(pi_col.search(rec).group(1))
        re_flash = int(pi_flash.search(rec).group(1))
        if re_sure_flag == 1:
            counter_row = re_row
            counter_col = re_col
            board[counter_row][counter_col] = "X"
            drawBoard()
            current_player = 'O'  ##收到对面信息后回到主场
            previewImg = previewCircleImg
            pygame.display.update()
        if re_flash ==1 :
            Common_Reset()


def TCP_Client():
    global send_row, send_col ,Send_Flag,row, col,Receive_Flag, i, current_player, previewImg,message,SOR,sure_flag,flash_flag
    global pi_send_flag, pi_received_flag, pi_row, pi_col, pr_flash
    pi_sr = re.compile(r'SenOrRec(\d)')
    while True:
        if SOR == 1:
            print("waiting for receiving...........")
            recved = dataSocket.recv(BUFLEN)
            rec = recved.decode()
            if not recved:
                break
            if rec:
                handle(rec)
                print("received", rec)
                dataSocket.send(message.encode())
                SOR = 0
        # time.sleep(0.3)
        if SOR == 0:
            print("sending",message)
            dataSocket.send(message.encode())
            sure_flag = 0
            flash_flag = 0
            message = "sure_f" + str(sure_flag) + "row" + str(send_row) + " col" + str(send_col) + "flash" + str(flash_flag)
            SOR = 1


client_thread = threading.Thread(target=TCP_Client)
client_thread.start()

menu()
dataSocket.close()
```

### 模式1悔棋

#### 服务端

```python
import pygame
import ctypes
# 导入socket 库
from socket import *
import threading
import time
import re
global pi_sure_flag,pi_row,pi_col,pi_flash,message,sure_flag,flash_flag,SOR, board,over_pos

pi_sure_flag=re.compile(r'sure_f(\d)')
pi_row=re.compile(r'row(\d)')
pi_col=re.compile(r'col(\d)')
pi_flash=re.compile(r'flash(\d)')##刷新参数
message= "sure_f0 row0 col0 flash0 SenOrRec0"
sure_flag = 0
flash_flag = 0
over_pos= []
send_row = 0
send_col = 0
SOR = 0 #0是发送
# 主机地址为空字符串，表示绑定本机所有网络接口ip地址
# 等待客户端来连接
IP = ''
# 端口号
PORT = 50000
# 定义一次从socket缓冲区最多读入512个字节数据
BUFLEN = 512

# 实例化一个socket对象
# 参数 AF_INET 表示该socket网络层使用IP协议
# 参数 SOCK_STREAM 表示该socket传输层使用TCP协议
listenSocket = socket(AF_INET, SOCK_STREAM)

# socket绑定地址和端口
listenSocket.bind((IP, PORT))


# 使socket处于监听状态，等待客户端的连接请求
# 参数 8 表示 最多接受多少个等待连接的客户端
listenSocket.listen(8)
print(f'服务端启动成功，在{PORT}端口等待客户端连接...')

dataSocket, addr = listenSocket.accept()
print('接受一个客户端连接:', addr)


global Send_Flag,Receive_Flag,Current_Player,If_over,previewImg,gameMode,Ini_FLag,Reset_Flag
# 初始化 pygame
pygame.init()

# 定义颜色
blue = (78, 140, 243)
light_blue = (100, 100, 255)
red = (242, 89, 97)
light_red = (255, 100, 100)
dark_grey = (85, 85, 85)
light_grey = (100, 100, 100)
background_color = (225, 225, 225)
Send_Flag = 0
Receive_Flag = 0##一开始不发送也不接受，主机
Current_Player = 'X'#X先下棋
If_over = 0
gameMode = 0
Ini_FLag = 1
# 创建窗口
screen = pygame.display.set_mode((600, 800))
pygame.display.set_caption('井字棋')

# 游戏图片
crossImg = pygame.image.load('Images/crossImg.png')
crossImg_rect = crossImg.get_rect()
crossImg_rect.center = (200, 300)
circleImg = pygame.image.load('Images/circleImg.png')
circleImg_rect = crossImg.get_rect()
circleImg_rect.center = (400, 300)
previewCrossImg = pygame.image.load('Images/prev_crossImg.png')
previewCircleImg = pygame.image.load('Images/prev_circleImg.png')

previewImg = previewCrossImg
# 按钮图片
restartImg = pygame.image.load('Images/restart.png')
restartHoveredImg = pygame.image.load('Images/restart_hovered.png')
ReGretImg = pygame.image.load('Images/button4Img.png')
# 定义棋盘
board = [['', '', ''],
         ['', '', ''],
         ['', '', '']]

# 定义计分板
score = {'X': 0, 'O': 0}
font = pygame.font.Font('freesansbold.ttf', 32)
X_score = pygame.image.load('Images/X_scoreImg.png')
O_score = pygame.image.load('Images/O_scoreImg.png')

# 菜单图片
buttom1 = pygame.image.load('Images/button1Img.png')
buttom1_rect = buttom1.get_rect()
buttom1_rect.center = (300, 312)
buttom2 = pygame.image.load('Images/button2Img.png')
buttom2_rect = buttom2.get_rect()
buttom2_rect.center = (300, 472)

buttom3 = pygame.image.load('Images/button3Img.png')
buttom3_rect = buttom3.get_rect()
buttom3_rect.center = (300, 632)

buttom4_rect = ReGretImg.get_rect()
buttom4_rect.center = (478, 751)

logo = pygame.image.load('Images/logo.png')

# 选择菜单图片
chooseImg = pygame.image.load('Images/choose.png')


def menu():
    global gameMode
    running = True
    while running:
        screen.fill(background_color)
        mx, my = pygame.mouse.get_pos()
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if buttom1_rect.collidepoint((mx, my)):
                    game(0, 'X')
                    gameMode = 0
                elif buttom2_rect.collidepoint((mx, my)):
                    player = choose()
                    if player is not None:
                        game(1, player)
                        gameMode =1
                elif buttom3_rect.collidepoint((mx, my)):
                    gameMode = 2
                    game(2, 'X')
        screen.blit(logo, (8, 25))
        screen.blit(buttom1, (100, 250))
        screen.blit(buttom2, (100, 410))
        screen.blit(buttom3, (100, 570))
        pygame.display.update()


def game(gameMode, player):
    global send_row, send_col ,Send_Flag,row, col,Receive_Flag,Current_Player,If_over,previewImg,message,sure_flag,flash_flag,board
    my = player
    player = 'X'
    running = True
    while running:
        mouse = pygame.mouse.get_pos()
        row, col = int(mouse[0] / 200), int(mouse[1] / 200)
        for event in pygame.event.get():
            if verifyWinner('X'):
                print("确认X胜利")
                player = 'X'
                previewImg = previewCrossImg
            if verifyWinner('O'):
                print("确认O胜利")
                player = 'X'
                previewImg = previewCrossImg
            if event.type == pygame.QUIT:
                resetGame()
                running = False
            elif isBoardFull():
                ctypes.windll.user32.MessageBoxW(0, '平局', '提示', 0)
                resetBoard()
            elif gameMode == 1 and player != my:
                computerMove(player)
                drawBoard()
                pygame.display.update()
                # if verifyWinner(player):
                #     player = 'X'
                #     previewImg = previewCrossImg
                # else:
                #     player, previewImg = updatePlayer(player)
                if verifyWinner(player):
                    player = 'X'
                    previewImg = previewCrossImg
                else:
                    player, previewImg = updatePlayer(player)
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if gameMode != 2:
                    if row < 3 and col < 3 and board[row][col] == '':
                        # send_row = row
                        # send_col = col
                        playerMove(player, row, col)
                        drawBoard()
                        Send_Flag = 1
                        time.sleep(0.5)
                        if verifyWinner('X'):
                            player = 'X'
                            previewImg = previewCrossImg
                        else :
                            player, previewImg = updatePlayer(player)
                if gameMode == 2:
                    if row < 3 and col < 3 and board[row][col] == '':
                        print("Current_Player", Current_Player)
                    if row < 3 and col < 3 and board[row][col] == '' and Current_Player == 'X':#自己的回合鼠标才能点击
                        sure_flag = 1
                        send_row = row
                        send_col = col
                        message = "sure_f"+str(sure_flag) + "row" + str(send_row)+" col"+str(send_col) + "flash"+ str(flash_flag)
                        time.sleep(0.3)
                        playerMove('X', row, col)
                        drawBoard()
                        Current_Player = 'O'#下完换对方
                        previewImg = previewCircleImg
                        print("I am going to Send message X")
                        time.sleep(0.5)
                        print("I am waiting for O message")
                    # else:
                    #         Receive_Flag = 1
                if 550 < mouse[0] < 582 and 610 < mouse[1] < 642:
                    flash_flag = 1
                    message = "sure_f" + str(sure_flag) + "row" + str(row) + " col" + str(col) + "flash" + str(
                        flash_flag)
                    resetGame()
                if buttom4_rect.collidepoint((mouse[0], mouse[1])):
                    if gameMode == 0:
                        print("按钮有效")
                        lenth =len(over_pos)
                        if lenth > 0:
                            x = over_pos[lenth - 1][0]
                            y = over_pos[lenth - 1][1]
                            del over_pos[lenth-1]
                            if lenth == 1:
                                resetGame()
                            elif board[x][y] == "X":
                                print("regret x")
                                Current_Player = "O"
                                previewImg = previewCircleImg
                                board[x][y] = " "
                                drawBoard()
                            elif board[x][y] == "O":
                                print("regret o")
                                Current_Player = "X"
                                previewImg = previewCrossImg
                                board[x][y] = " "
                                drawBoard()
                            pygame.display.update()
                        # time.sleep(0.5)
                    if gameMode == 1:
                        print("按钮有效")
                        lenth =len(over_pos)
                        print("regret,computer1111")
                        if lenth > 1 and Current_Player == my:
                            print("regret,computer")
                            x1 = over_pos[lenth - 1][0]
                            y1 = over_pos[lenth - 1][1]
                            x2 = over_pos[lenth - 2][0]
                            y2 = over_pos[lenth - 2][1]
                            del over_pos[lenth-1]
                            del over_pos[lenth-2]
                            board[x1][y1]= ' '
                            board[x2][y2]= ' '
                            drawBoard()
                            pygame.display.update()
                        # time.sleep(0.5)

        screen.fill(background_color)
        drawBoard()
        drawBottomMenu(mouse)
        if row < 3 and col < 3:
            visualizeMove(row, col, previewImg)
        pygame.display.update()


def choose():
    player = None
    running = True
    while running:
        mouse = pygame.mouse.get_pos()
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if crossImg_rect.collidepoint((mouse[0], mouse[1])):
                    player = 'X'
                    running = False
                elif circleImg_rect.collidepoint((mouse[0], mouse[1])):
                    player = 'O'
                    running = False
        screen.blit(crossImg, (80, 300))
        screen.blit(circleImg, (340, 300))
        screen.blit(chooseImg, (8, 25))
        pygame.display.update()
    return player


def drawBoard():
    # 画棋子
    for row in range(3):
        for col in range(3):
            pos = (row * 200 + 12, col * 200 + 12)
            if board[row][col] == 'X':
                screen.blit(crossImg, pos)
            elif board[row][col] == 'O':
                screen.blit(circleImg, pos)
    # 画网格
    width = 10
    color = dark_grey
    pygame.draw.line(screen, color, (200, 0), (200, 600), width)
    pygame.draw.line(screen, color, (400, 0), (400, 600), width)
    pygame.draw.line(screen, color, (0, 200), (600, 200), width)
    pygame.draw.line(screen, color, (0, 400), (600, 400), width)
    # 画边框
    pygame.draw.rect(screen, color, (0, 0, 10, 600))
    pygame.draw.rect(screen, color, (0, 0, 600, 10))
    pygame.draw.rect(screen, color, (590, 0, 10, 600))


def drawBottomMenu(mouse):
    pygame.draw.rect(screen, dark_grey, (0, 600, 600, 100))
    pygame.draw.rect(screen, light_grey, (10, 610, 580, 80))
    screen.blit(restartImg, (550, 610))
    screen.blit(ReGretImg,(400,720))
    # Hover animation
    if 550 < mouse[0] < 582 and 610 < mouse[1] < 642:
        screen.blit(restartHoveredImg, (548, 608))
    screen.blit(X_score, (200, 610))
    screen.blit(O_score, (370, 610))
    scoreboard = font.render(': %d x %d :' % (score['X'], score['O']), True, background_color, light_grey)
    screen.blit(scoreboard, (244, 610))


def visualizeMove(row, col, previewImg):
    if board[row][col] == '':
        screen.blit(previewImg, (row * 200 + 12, col * 200 + 12))


def playerMove(player, row, col):
    board[row][col] = player
    over_pos.append((row,col))
def CounterMove(row, col):
    board[row][col] = "O"


def computerMove(player):
    global over_pos
    bestScore = float('inf')
    for row in range(3):
        for col in range(3):
            if board[row][col] == '':
                board[row][col] = 'O'
                score = minimax(board, 'X')
                board[row][col] = ''
                if score < bestScore:
                    bestScore = score
                    bestMove = (row, col)
    board[bestMove[0]][bestMove[1]] = player
    over_pos.append((bestMove[0],bestMove[1]))


scores = {'X': 1, 'O': -1, 'tie': 0}


def minimax(board, cur_player):
    if isWinner('X'):
        return scores['X']
    elif isWinner('O'):
        return scores['O']
    elif isBoardFull():
        return scores['tie']
    if cur_player == 'X':
        bestScore = float('-inf')
        nextPlayer = 'O'
        minORmax = max
    else:
        bestScore = float('inf')
        nextPlayer = 'X'
        minORmax = min
    for row in range(3):
        for col in range(3):
            if board[row][col] == '':
                board[row][col] = cur_player
                score = minimax(board, nextPlayer)
                board[row][col] = ''
                bestScore = minORmax(score, bestScore)
            if bestScore == scores[cur_player]:
                return bestScore
    return bestScore


def updatePlayer(player):
    if player == 'X':
        newPlayer = 'O'
        previewImg = previewCircleImg
    else:
        newPlayer = 'X'
        previewImg = previewCrossImg
    return newPlayer, previewImg



def isWinner(player):
    return ((board[0][0] == player and board[0][1] == player and board[0][2] == player) or
            (board[1][0] == player and board[1][1] == player and board[1][2] == player) or
            (board[2][0] == player and board[2][1] == player and board[2][2] == player) or
            (board[0][0] == player and board[1][0] == player and board[2][0] == player) or
            (board[0][1] == player and board[1][1] == player and board[2][1] == player) or
            (board[0][2] == player and board[1][2] == player and board[2][2] == player) or
            (board[0][0] == player and board[1][1] == player and board[2][2] == player) or
            (board[0][2] == player and board[1][1] == player and board[2][0] == player))


def verifyWinner(player):
    global Send_Flag, Receive_Flag, Current_Player,dataSocket,gameMode,previewImg
    if isWinner(player):
        # dataSocket.close()
        # dataSocket, addr = listenSocket.accept()
        print(player, "win")
        if gameMode == 2:
            print("I have turn current_player to X")
            Current_Player = 'X'  # X先下棋
            previewImg = previewCrossImg
            if player == 'O':
                toSend = 'Over'
                dataSocket.send(toSend.encode())
                print("send_meseage:",toSend)
                Send_Flag = 0
                Receive_Flag = 0  ##一开始不发送也不接受，主机

        score[player] += 1
        ctypes.windll.user32.MessageBoxW(0, player + ' 获胜！', '提示', 0)
        resetBoard()
        return True
    return False


def isBoardFull():
    for i in range(3):
        for j in range(3):
            if board[i][j] == '':
                return False
    return True


def resetBoard():
    for i in range(3):
        for j in range(3):
            board[i][j] = ''

def Common_Reset():##对方刷新引起的刷新
    global Send_Flag,Receive_Flag,gameMode,Current_Player,previewImg,dataSocket
    resetBoard()
    score['X'] = 0
    score['O'] = 0
    previewImg = previewCrossImg
    Current_Player = 'X'


def resetGame():
    global Send_Flag,Receive_Flag,gameMode,Current_Player,previewImg,dataSocket,over_pos
    over_pos= []
    resetBoard()
    score['X'] = 0
    score['O'] = 0
    if gameMode == 2:
        Current_Player = 'X'
        print("I have turn the picture to Cross")
        previewImg = previewCrossImg


global i
i = 0

def handle(rec):
    global send_row, send_col, Send_Flag, row, col, Receive_Flag, i, Current_Player, previewImg, message
    global pi_sure_flag, pi_row, pi_col, pr_flash
    if rec:
        print("rec    in re",rec)
        re_sure_flag = int(pi_sure_flag.search(rec).group(1))
        re_row = int(pi_row.search(rec).group(1))
        re_col = int(pi_col.search(rec).group(1))
        re_flash = int(pi_flash.search(rec).group(1))
        if re_sure_flag == 1:
            counter_row = re_row
            counter_col = re_col
            board[counter_row][counter_col] = "O"
            drawBoard()
            Current_Player = 'X'  ##收到对面信息后回到主场
            previewImg = previewCrossImg
            pygame.display.update()

        if re_flash:
            Common_Reset()


def TCP_Server():
    global send_row, send_col, Send_Flag, row, col, Receive_Flag, i, current_player, previewImg, message,sure_flag,flash_flag,SOR
    global pi_send_flag, pi_received_flag, pi_row, pi_col, pr_flash
    pi_sr = re.compile(r'SenOrRec(\d)')
    while True:
        if SOR == 0:
            time.sleep(0.3)
            print("Send_message", message)
            dataSocket.send(message.encode())
            # time.sleep(0.3)
            sure_flag = 0
            flash_flag = 0
            message = "sure_f" + str(sure_flag) + "row" + str(send_row) + " col" + str(send_col) + "flash" + str(flash_flag)
            print("waiting for receiving...........")
            SOR = 1
        if SOR == 1:
            recved = dataSocket.recv(BUFLEN)
            rec = recved.decode()
            if not recved:
                break
            if rec:
                # re_SOR = pi_sr.search(rec)
                # SOR = re_SOR.group(1)
                handle(rec)
                print("received", rec)
                dataSocket.send(message.encode())
                SOR = 0


server_thread = threading.Thread(target = TCP_Server )
server_thread.start()
menu()
dataSocket.close()
listenSocket.close()
```

#### 客户端

```python
import pygame
import ctypes
#  === TCP 客户端程序 client.py ===
import time
from socket import *
import threading
import re

global pi_sure_flag,pi_row,pi_col,pi_flash,message,SOR,sure_flag,flash_flag,over_pos

pi_sure_flag=re.compile(r'sure_f(\d)')
pi_row=re.compile(r'row(\d)')
pi_col=re.compile(r'col(\d)')
pi_flash=re.compile(r'flash(\d)')##刷新参数
message= "sure_f0 row0 col0 flash0 SenOrRec1"
SOR = 1
sure_flag = 0
flash_flag = 0
over_pos= []
IP = '127.0.0.1'
SERVER_PORT = 50000
BUFLEN = 1024

# 实例化一个socket对象，指明协议
dataSocket = socket(AF_INET, SOCK_STREAM)
global Send_Flag,Receive_Flag,current_player,previewImg,gameMode
Send_Flag = 0
Receive_Flag = 1
current_player = 'X'#服务端先下
gameMode = 0
send_row = 0
send_col = 0
# 连接服务端socket
dataSocket.connect((IP, SERVER_PORT))
# 初始化 pygame
pygame.init()

# 定义颜色
blue = (78, 140, 243)
light_blue = (100, 100, 255)
red = (242, 89, 97)
light_red = (255, 100, 100)
dark_grey = (85, 85, 85)
light_grey = (100, 100, 100)
background_color = (225, 225, 225)

# 创建窗口
screen = pygame.display.set_mode((600, 800))
pygame.display.set_caption('井字棋-客户端')

# 游戏图片
crossImg = pygame.image.load('Images/crossImg.png')
crossImg_rect = crossImg.get_rect()
crossImg_rect.center = (200, 300)
circleImg = pygame.image.load('Images/circleImg.png')
circleImg_rect = crossImg.get_rect()
circleImg_rect.center = (400, 300)
previewCrossImg = pygame.image.load('Images/prev_crossImg.png')
previewCircleImg = pygame.image.load('Images/prev_circleImg.png')
previewImg = previewCrossImg
# 按钮图片
restartImg = pygame.image.load('Images/restart.png')
restartHoveredImg = pygame.image.load('Images/restart_hovered.png')
ReGretImg = pygame.image.load('Images/button4Img.png')

# 定义棋盘
board = [['', '', ''],
         ['', '', ''],
         ['', '', '']]

# 定义计分板
score = {'X': 0, 'O': 0}
font = pygame.font.Font('freesansbold.ttf', 32)
X_score = pygame.image.load('Images/X_scoreImg.png')
O_score = pygame.image.load('Images/O_scoreImg.png')

# 菜单图片
buttom1 = pygame.image.load('Images/button1Img.png')
buttom1_rect = buttom1.get_rect()
buttom1_rect.center = (300, 312)
buttom2 = pygame.image.load('Images/button2Img.png')
buttom2_rect = buttom2.get_rect()
buttom2_rect.center = (300, 472)
buttom3 = pygame.image.load('Images/button3Img.png')
buttom3_rect = buttom3.get_rect()
buttom3_rect.center = (300, 632)
buttom4_rect = ReGretImg.get_rect()
buttom4_rect.center = (478, 751)
logo = pygame.image.load('Images/logo.png')

# 选择菜单图片
chooseImg = pygame.image.load('Images/choose.png')


def menu():
    global gameMode
    running = True
    while running:
        screen.fill(background_color)
        mx, my = pygame.mouse.get_pos()
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if buttom1_rect.collidepoint((mx, my)):
                    gameMode= 0
                    game(0, 'X')
                elif buttom2_rect.collidepoint((mx, my)):
                    player = choose()
                    if player is not None:
                        gameMode= 1
                        game(1, player)
                elif buttom3_rect.collidepoint((mx, my)):
                    gameMode = 2
                    game(2, 'O')
        screen.blit(logo, (8, 25))
        screen.blit(buttom1, (100, 250))
        screen.blit(buttom2, (100, 410))
        screen.blit(buttom3, (100, 570))
        pygame.display.update()


def game(gameMode, player):
    global send_row, send_col, Send_Flag, Receive_Flag,row, col,current_player,previewImg,message,sure_flag,flash_flag,over_pos
    my = player
    # player = current_player
    running = True
    if gameMode == 2:
        previewImg = previewCrossImg  # 服务端先下
    else:
        previewImg = previewCircleImg

    while running:
        mouse = pygame.mouse.get_pos()
        row, col = int(mouse[0] / 200), int(mouse[1] / 200)
        for event in pygame.event.get():
            if verifyWinner('O'):
                # player = 'O'
                # previewImg = previewCrossImg
                 pass
            if verifyWinner('X'):
                # player = 'X'
                # previewImg = previewCrossImg
                pass
            if event.type == pygame.QUIT:
                resetGame()
                running = False
            elif isBoardFull():
                ctypes.windll.user32.MessageBoxW(0, '平局', '提示', 0)
                resetBoard()
            elif gameMode == 1 and player != my:
                computerMove(player)
                drawBoard()
                pygame.display.update()
                if verifyWinner(player):
                    player = 'O'
                    previewImg = previewCrossImg
                else:
                    player, previewImg = updatePlayer(player)
            # elif gameMode == 2 and player != my:
            #     CounterMove(player)
            #     drawBoard()
            #     pygame.display.update()
            #     if verifyWinner(player):
            #         player = 'O'
            #         previewImg = previewCrossImg
            #     else:
            #         player, previewImg = updatePlayer(player)
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if gameMode != 2:
                    if row < 3 and col < 3 and board[row][col] == '':
                        send_row = row
                        send_col = col
                        playerMove(player, row, col)
                        drawBoard()
                        # Send_Flag = 1
                        # time.sleep(0.5)
                        if verifyWinner('O'):
                            player = 'X'
                            previewImg = previewCrossImg
                        else :
                            player, previewImg = updatePlayer(player)
                    #
                    #     else:
                    #         Receive_Flag = 1
                    # elif 550 < mouse[0] < 582 and 610 < mouse[1] < 642:
                    #     resetGame()
                if gameMode == 2:
                    if row < 3 and col < 3 and board[row][col] == '':
                        print("Current_Player", current_player)
                    if row < 3 and col < 3 and board[row][col] == '' and current_player == 'O':#自己的回合鼠标才能点击
                        send_row = row
                        send_col = col
                        sure_flag =1
                        message = "sure_f"+str(sure_flag) + "row" + str(send_row)+" col"+str(send_col) + "flash"+ str(flash_flag)+"SenOrRec1"
                        playerMove('O', row, col)
                        drawBoard()
                        current_player = 'X'#下完换对方
                        previewImg = previewCrossImg
                        Send_Flag = 1
                        Receive_Flag = 1
                        print("I am going to send O message")
                        # time.sleep(0.5)
                        print("I am wating for message")
                        # if verifyWinner(player):
                        #     player = 'O'
                        #     previewImg = previewCrossImg
                        # elif gameMode != 2:
                        #
                    # else:
                    #         Receive_Flag = 1
                if 550 < mouse[0] < 582 and 610 < mouse[1] < 642:
                    flash_flag = 1
                    message = "sure_f" + str(sure_flag) + "row" + str(send_row) + " col" + str(
                        send_col) + "flash" + str(flash_flag) + "SenOrRec1"
                    resetGame()
                if buttom4_rect.collidepoint((mouse[0], mouse[1])):
                    if gameMode == 0:
                        print("按钮有效")
                        lenth =len(over_pos)
                        if lenth > 0:
                            x = over_pos[lenth - 1][0]
                            y = over_pos[lenth - 1][1]
                            del over_pos[lenth-1]
                            if lenth == 1:
                                resetGame()
                            elif board[x][y] == "X":
                                print("regret x")
                                Current_Player = "O"
                                previewImg = previewCircleImg
                                board[x][y] = " "
                                drawBoard()
                            elif board[x][y] == "O":
                                print("regret o")
                                Current_Player = "X"
                                previewImg = previewCrossImg
                                board[x][y] = " "
                                drawBoard()
                            pygame.display.update()
                    if gameMode == 1:
                        print("按钮有效")
                        lenth =len(over_pos)
                        print("regret,computer1111")
                        if lenth > 1 and current_player == my:
                            print("regret,computer")
                            x1 = over_pos[lenth - 1][0]
                            y1 = over_pos[lenth - 1][1]
                            x2 = over_pos[lenth - 2][0]
                            y2 = over_pos[lenth - 2][1]
                            del over_pos[lenth-1]
                            del over_pos[lenth-2]
                            board[x1][y1]= ' '
                            board[x2][y2]= ' '
                            drawBoard()
                            pygame.display.update()

        screen.fill(background_color)
        drawBoard()
        drawBottomMenu(mouse)
        if row < 3 and col < 3:
            visualizeMove(row, col, previewImg)
        pygame.display.update()


def choose():
    player = None
    running = True
    while running:
        mouse = pygame.mouse.get_pos()
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if crossImg_rect.collidepoint((mouse[0], mouse[1])):
                    player = 'X'
                    running = False
                elif circleImg_rect.collidepoint((mouse[0], mouse[1])):
                    player = 'O'
                    running = False
        screen.blit(crossImg, (80, 300))
        screen.blit(circleImg, (340, 300))
        screen.blit(chooseImg, (8, 25))
        pygame.display.update()
    return player


def drawBoard():
    # 画棋子
    for row in range(3):
        for col in range(3):
            pos = (row * 200 + 12, col * 200 + 12)
            if board[row][col] == 'X':
                screen.blit(crossImg, pos)
            elif board[row][col] == 'O':
                screen.blit(circleImg, pos)
    # 画网格
    width = 10
    color = dark_grey
    pygame.draw.line(screen, color, (200, 0), (200, 600), width)
    pygame.draw.line(screen, color, (400, 0), (400, 600), width)
    pygame.draw.line(screen, color, (0, 200), (600, 200), width)
    pygame.draw.line(screen, color, (0, 400), (600, 400), width)
    # 画边框
    pygame.draw.rect(screen, color, (0, 0, 10, 600))
    pygame.draw.rect(screen, color, (0, 0, 600, 10))
    pygame.draw.rect(screen, color, (590, 0, 10, 600))


def drawBottomMenu(mouse):
    pygame.draw.rect(screen, dark_grey, (0, 600, 600, 100))
    pygame.draw.rect(screen, light_grey, (10, 610, 580, 80))
    screen.blit(restartImg, (550, 610))
    screen.blit(ReGretImg,(400,720))
    # Hover animation
    if 550 < mouse[0] < 582 and 610 < mouse[1] < 642:
        screen.blit(restartHoveredImg, (548, 608))
    screen.blit(X_score, (200, 610))
    screen.blit(O_score, (370, 610))
    scoreboard = font.render(': %d x %d :' % (score['X'], score['O']), True, background_color, light_grey)
    screen.blit(scoreboard, (244, 610))


def visualizeMove(row, col, previewImg):
    if board[row][col] == '':
        screen.blit(previewImg, (row * 200 + 12, col * 200 + 12))


def playerMove(player, row, col):
    board[row][col] = player
    over_pos.append((row,col))

def computerMove(player):
    global  over_pos
    bestScore = float('inf')
    for row in range(3):
        for col in range(3):
            if board[row][col] == '':
                board[row][col] = 'O'
                score = minimax(board, 'X')
                board[row][col] = ''
                if score < bestScore:
                    bestScore = score
                    bestMove = (row, col)
    board[bestMove[0]][bestMove[1]] = player
    over_pos.append((bestMove[0],bestMove[1]))

scores = {'X': 1, 'O': -1, 'tie': 0}


def minimax(board, cur_player):
    if isWinner('X'):
        return scores['X']
    elif isWinner('O'):
        return scores['O']
    elif isBoardFull():
        return scores['tie']
    if cur_player == 'X':
        bestScore = float('-inf')
        nextPlayer = 'O'
        minORmax = max
    else:
        bestScore = float('inf')
        nextPlayer = 'X'
        minORmax = min
    for row in range(3):
        for col in range(3):
            if board[row][col] == '':
                board[row][col] = cur_player
                score = minimax(board, nextPlayer)
                board[row][col] = ''
                bestScore = minORmax(score, bestScore)
            if bestScore == scores[cur_player]:
                return bestScore
    return bestScore


def updatePlayer(player):
    if player == 'X':
        newPlayer = 'O'
        previewImg = previewCircleImg
    else:
        newPlayer = 'X'
        previewImg = previewCrossImg
    return newPlayer, previewImg



def isWinner(player):
    return ((board[0][0] == player and board[0][1] == player and board[0][2] == player) or
            (board[1][0] == player and board[1][1] == player and board[1][2] == player) or
            (board[2][0] == player and board[2][1] == player and board[2][2] == player) or
            (board[0][0] == player and board[1][0] == player and board[2][0] == player) or
            (board[0][1] == player and board[1][1] == player and board[2][1] == player) or
            (board[0][2] == player and board[1][2] == player and board[2][2] == player) or
            (board[0][0] == player and board[1][1] == player and board[2][2] == player) or
            (board[0][2] == player and board[1][1] == player and board[2][0] == player))


def verifyWinner(player):
    global  Send_Flag,Receive_Flag,current_player,dataSocket,previewImg,gameMode,SOR
    if isWinner(player):
        print(player, "win")
        if gameMode ==2:
            previewImg = previewCrossImg
            current_player = 'X'  # 服务端先下
            SOR = 0
            # if player == 'X':
                # toSend = 'Over'
                # dataSocket.send(toSend.encode())
                # print("send_meseage:", toSend)
                # Send_Flag = 0
                # Receive_Flag = 1
        score[player] += 1
        ctypes.windll.user32.MessageBoxW(0, player + ' 获胜！', '提示', 0)
        resetBoard()
        return True
    return False


def isBoardFull():
    for i in range(3):
        for j in range(3):
            if board[i][j] == '':
                return False
    return True


def resetBoard():
    for i in range(3):
        for j in range(3):
            board[i][j] = ''

def Common_Reset():##对方刷新引起的刷新，被动刷新
    global Send_Flag,Receive_Flag,gameMode,current_player,previewImg,dataSocket
    resetBoard()
    score['X'] = 0
    score['O'] = 0
    if gameMode == 2:
        current_player = 'X'
        print("I have turn the picture to Cross")
        previewImg = previewCrossImg
def resetGame():##主动刷新
    global Send_Flag, Receive_Flag, gameMode, current_player, previewImg, dataSocket,over_pos
    resetBoard()
    over_pos= []
    score['X'] = 0
    score['O'] = 0
    if gameMode == 2:
        current_player = 'X'
        print("I have turn the picture to Cross")
        previewImg = previewCrossImg

    resetBoard()
    score['X'] = 0
    score['O'] = 0
global i
i = 0
def handle(rec):
    global send_row, send_col ,Send_Flag,row, col,Receive_Flag, i, current_player, previewImg,message
    global pi_sure_flag, pi_row, pi_col, pr_flash
    if rec:
        re_sure_flag = int(pi_sure_flag.search(rec).group(1))
        re_row = int(pi_row.search(rec).group(1))
        re_col = int(pi_col.search(rec).group(1))
        re_flash = int(pi_flash.search(rec).group(1))
        if re_sure_flag == 1:
            counter_row = re_row
            counter_col = re_col
            board[counter_row][counter_col] = "X"
            drawBoard()
            current_player = 'O'  ##收到对面信息后回到主场
            previewImg = previewCircleImg
            pygame.display.update()
        if re_flash ==1 :
            Common_Reset()


def TCP_Client():
    global send_row, send_col ,Send_Flag,row, col,Receive_Flag, i, current_player, previewImg,message,SOR,sure_flag,flash_flag
    global pi_send_flag, pi_received_flag, pi_row, pi_col, pr_flash
    pi_sr = re.compile(r'SenOrRec(\d)')
    while True:
        if SOR == 1:
            print("waiting for receiving...........")
            recved = dataSocket.recv(BUFLEN)
            rec = recved.decode()
            if not recved:
                break
            if rec:
                handle(rec)
                print("received", rec)
                dataSocket.send(message.encode())
                SOR = 0
        # time.sleep(0.3)
        if SOR == 0:
            print("sending",message)
            dataSocket.send(message.encode())
            sure_flag = 0
            flash_flag = 0
            message = "sure_f" + str(sure_flag) + "row" + str(send_row) + " col" + str(send_col) + "flash" + str(flash_flag)
            SOR = 1


client_thread = threading.Thread(target=TCP_Client)
client_thread.start()

menu()
dataSocket.close()
```

### 联机悔棋

#### 服务端

```python
import pygame
import ctypes
# 导入socket 库
from socket import *
import threading
import time
import re
global pi_reg,pi_sure_flag,pi_row,pi_col,pi_flash,message,sure_flag,flash_flag,SOR, board,over_pos,regret_flag

pi_sure_flag=re.compile(r'sure_f(\d)')
pi_row=re.compile(r'row(\d)')
pi_col=re.compile(r'col(\d)')
pi_flash=re.compile(r'flash(\d)')##刷新参数
pi_reg = re.compile(r'reg(\d)')
message= "sure_f0 row0 col0 flash0 SenOrRec0 reg0"
sure_flag = 0
flash_flag = 0
regret_flag = 0
over_pos= []
send_row = 0
send_col = 0
SOR = 0 #0是发送
# 主机地址为空字符串，表示绑定本机所有网络接口ip地址
# 等待客户端来连接
IP = ''
# 端口号
PORT = 50000
# 定义一次从socket缓冲区最多读入512个字节数据
BUFLEN = 512

# 实例化一个socket对象
# 参数 AF_INET 表示该socket网络层使用IP协议
# 参数 SOCK_STREAM 表示该socket传输层使用TCP协议
listenSocket = socket(AF_INET, SOCK_STREAM)

# socket绑定地址和端口
listenSocket.bind((IP, PORT))


# 使socket处于监听状态，等待客户端的连接请求
# 参数 8 表示 最多接受多少个等待连接的客户端
listenSocket.listen(8)
print(f'服务端启动成功，在{PORT}端口等待客户端连接...')

dataSocket, addr = listenSocket.accept()
print('接受一个客户端连接:', addr)


global Send_Flag,Receive_Flag,Current_Player,If_over,previewImg,gameMode,Ini_FLag,Reset_Flag
# 初始化 pygame
pygame.init()

# 定义颜色
blue = (78, 140, 243)
light_blue = (100, 100, 255)
red = (242, 89, 97)
light_red = (255, 100, 100)
dark_grey = (85, 85, 85)
light_grey = (100, 100, 100)
background_color = (225, 225, 225)
Send_Flag = 0
Receive_Flag = 0##一开始不发送也不接受，主机
Current_Player = 'X'#X先下棋
If_over = 0
gameMode = 0
Ini_FLag = 1
# 创建窗口
screen = pygame.display.set_mode((600, 800))
pygame.display.set_caption('井字棋')

# 游戏图片
crossImg = pygame.image.load('Images/crossImg.png')
crossImg_rect = crossImg.get_rect()
crossImg_rect.center = (200, 300)
circleImg = pygame.image.load('Images/circleImg.png')
circleImg_rect = crossImg.get_rect()
circleImg_rect.center = (400, 300)
previewCrossImg = pygame.image.load('Images/prev_crossImg.png')
previewCircleImg = pygame.image.load('Images/prev_circleImg.png')

previewImg = previewCrossImg
# 按钮图片
restartImg = pygame.image.load('Images/restart.png')
restartHoveredImg = pygame.image.load('Images/restart_hovered.png')
ReGretImg = pygame.image.load('Images/button4Img.png')
# 定义棋盘
board = [['', '', ''],
         ['', '', ''],
         ['', '', '']]

# 定义计分板
score = {'X': 0, 'O': 0}
font = pygame.font.Font('freesansbold.ttf', 32)
X_score = pygame.image.load('Images/X_scoreImg.png')
O_score = pygame.image.load('Images/O_scoreImg.png')

# 菜单图片
buttom1 = pygame.image.load('Images/button1Img.png')
buttom1_rect = buttom1.get_rect()
buttom1_rect.center = (300, 312)
buttom2 = pygame.image.load('Images/button2Img.png')
buttom2_rect = buttom2.get_rect()
buttom2_rect.center = (300, 472)

buttom3 = pygame.image.load('Images/button3Img.png')
buttom3_rect = buttom3.get_rect()
buttom3_rect.center = (300, 632)

buttom4_rect = ReGretImg.get_rect()
buttom4_rect.center = (478, 751)

logo = pygame.image.load('Images/logo.png')

# 选择菜单图片
chooseImg = pygame.image.load('Images/choose.png')


def menu():
    global gameMode
    running = True
    while running:
        screen.fill(background_color)
        mx, my = pygame.mouse.get_pos()
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if buttom1_rect.collidepoint((mx, my)):
                    game(0, 'X')
                    gameMode = 0
                elif buttom2_rect.collidepoint((mx, my)):
                    player = choose()
                    if player is not None:
                        game(1, player)
                        gameMode =1
                elif buttom3_rect.collidepoint((mx, my)):
                    gameMode = 2
                    game(2, 'X')
        screen.blit(logo, (8, 25))
        screen.blit(buttom1, (100, 250))
        screen.blit(buttom2, (100, 410))
        screen.blit(buttom3, (100, 570))
        pygame.display.update()


def game(gameMode, player):
    global send_row, send_col ,Send_Flag,row, col,Receive_Flag,Current_Player,If_over,previewImg,message,sure_flag,flash_flag,board,regret_flag
    my = player
    player = 'X'
    running = True
    while running:
        mouse = pygame.mouse.get_pos()
        row, col = int(mouse[0] / 200), int(mouse[1] / 200)
        for event in pygame.event.get():
            if verifyWinner('X'):
                print("确认X胜利")
                player = 'X'
                previewImg = previewCrossImg
            if verifyWinner('O'):
                print("确认O胜利")
                player = 'X'
                previewImg = previewCrossImg
            if event.type == pygame.QUIT:
                resetGame()
                running = False
            elif isBoardFull():
                ctypes.windll.user32.MessageBoxW(0, '平局', '提示', 0)
                resetBoard()
            elif gameMode == 1 and player != my:
                computerMove(player)
                drawBoard()
                pygame.display.update()
                # if verifyWinner(player):
                #     player = 'X'
                #     previewImg = previewCrossImg
                # else:
                #     player, previewImg = updatePlayer(player)
                if verifyWinner(player):
                    player = 'X'
                    previewImg = previewCrossImg
                else:
                    player, previewImg = updatePlayer(player)
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if gameMode != 2:
                    if row < 3 and col < 3 and board[row][col] == '':
                        # send_row = row
                        # send_col = col
                        playerMove(player, row, col)
                        drawBoard()
                        Send_Flag = 1
                        time.sleep(0.5)
                        if verifyWinner('X'):
                            player = 'X'
                            previewImg = previewCrossImg
                        else :
                            player, previewImg = updatePlayer(player)
                if gameMode == 2:
                    if row < 3 and col < 3 and board[row][col] == '':
                        print("Current_Player", Current_Player)
                    if row < 3 and col < 3 and board[row][col] == '' and Current_Player == 'X':#自己的回合鼠标才能点击
                        sure_flag = 1
                        send_row = row
                        send_col = col
                        regret_flag = 0
                        message = "sure_f"+str(sure_flag) + "row" + str(send_row)+" col"+str(send_col) + "flash"+ str(flash_flag)+"reg"+str(regret_flag)
                        time.sleep(0.3)
                        playerMove('X', row, col)
                        drawBoard()
                        Current_Player = 'O'#下完换对方
                        previewImg = previewCircleImg
                        print("I am going to Send message X")
                        time.sleep(0.5)
                        print("I am waiting for O message")
                    # else:
                    #         Receive_Flag = 1
                if 550 < mouse[0] < 582 and 610 < mouse[1] < 642:
                    flash_flag = 1
                    message = "sure_f" + str(sure_flag) + "row" + str(send_row) + " col" + str(
                        send_col) + "flash" + str(flash_flag) + "reg" + str(regret_flag)
                    resetGame()
                if buttom4_rect.collidepoint((mouse[0], mouse[1])):
                    if gameMode != 0 :
                        print("按钮有效")
                        lenth =len(over_pos)
                        if lenth > 0:
                            x = over_pos[lenth - 1][0]
                            y = over_pos[lenth - 1][1]
                            del over_pos[lenth-1]
                            if lenth == 1:
                                resetGame()
                            elif board[x][y] == "X":
                                print("regret x")
                                Current_Player = "O"
                                previewImg = previewCircleImg
                                board[x][y] = " "
                                drawBoard()
                            elif board[x][y] == "O":
                                print("regret o")
                                Current_Player = "X"
                                previewImg = previewCrossImg
                                board[x][y] = " "
                                drawBoard()
                            pygame.display.update()
                        # time.sleep(0.5)
                    if gameMode == 1:
                        print("按钮有效")
                        lenth =len(over_pos)
                        print("regret,computer1111")
                        if lenth > 1 and Current_Player == my:
                            print("regret,computer")
                            x1 = over_pos[lenth - 1][0]
                            y1 = over_pos[lenth - 1][1]
                            x2 = over_pos[lenth - 2][0]
                            y2 = over_pos[lenth - 2][1]
                            del over_pos[lenth-1]
                            del over_pos[lenth-2]
                            board[x1][y1]= ' '
                            board[x2][y2]= ' '
                            drawBoard()
                            pygame.display.update()
                        # time.sleep(0.5)
                    if gameMode == 2 :
                        print("regret>>>")
                        regret_flag = 1
                        message = "sure_f"+str(sure_flag) + "row" + str(send_row)+" col"+str(send_col) + "flash"+ str(flash_flag)+"reg"+str(regret_flag)
                            # time.sleep(0.5)
        screen.fill(background_color)
        drawBoard()
        drawBottomMenu(mouse)
        if row < 3 and col < 3:
            visualizeMove(row, col, previewImg)
        pygame.display.update()


def choose():
    player = None
    running = True
    while running:
        mouse = pygame.mouse.get_pos()
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if crossImg_rect.collidepoint((mouse[0], mouse[1])):
                    player = 'X'
                    running = False
                elif circleImg_rect.collidepoint((mouse[0], mouse[1])):
                    player = 'O'
                    running = False
        screen.blit(crossImg, (80, 300))
        screen.blit(circleImg, (340, 300))
        screen.blit(chooseImg, (8, 25))
        pygame.display.update()
    return player


def drawBoard():
    # 画棋子
    for row in range(3):
        for col in range(3):
            pos = (row * 200 + 12, col * 200 + 12)
            if board[row][col] == 'X':
                screen.blit(crossImg, pos)
            elif board[row][col] == 'O':
                screen.blit(circleImg, pos)
    # 画网格
    width = 10
    color = dark_grey
    pygame.draw.line(screen, color, (200, 0), (200, 600), width)
    pygame.draw.line(screen, color, (400, 0), (400, 600), width)
    pygame.draw.line(screen, color, (0, 200), (600, 200), width)
    pygame.draw.line(screen, color, (0, 400), (600, 400), width)
    # 画边框
    pygame.draw.rect(screen, color, (0, 0, 10, 600))
    pygame.draw.rect(screen, color, (0, 0, 600, 10))
    pygame.draw.rect(screen, color, (590, 0, 10, 600))


def drawBottomMenu(mouse):
    pygame.draw.rect(screen, dark_grey, (0, 600, 600, 100))
    pygame.draw.rect(screen, light_grey, (10, 610, 580, 80))
    screen.blit(restartImg, (550, 610))
    screen.blit(ReGretImg,(400,720))
    # Hover animation
    if 550 < mouse[0] < 582 and 610 < mouse[1] < 642:
        screen.blit(restartHoveredImg, (548, 608))
    screen.blit(X_score, (200, 610))
    screen.blit(O_score, (370, 610))
    scoreboard = font.render(': %d x %d :' % (score['X'], score['O']), True, background_color, light_grey)
    screen.blit(scoreboard, (244, 610))


def visualizeMove(row, col, previewImg):
    if board[row][col] == '':
        screen.blit(previewImg, (row * 200 + 12, col * 200 + 12))


def playerMove(player, row, col):
    board[row][col] = player
    over_pos.append((row,col))
def CounterMove(row, col):
    board[row][col] = "O"


def computerMove(player):
    global over_pos
    bestScore = float('inf')
    for row in range(3):
        for col in range(3):
            if board[row][col] == '':
                board[row][col] = 'O'
                score = minimax(board, 'X')
                board[row][col] = ''
                if score < bestScore:
                    bestScore = score
                    bestMove = (row, col)
    board[bestMove[0]][bestMove[1]] = player
    over_pos.append((bestMove[0],bestMove[1]))


scores = {'X': 1, 'O': -1, 'tie': 0}


def minimax(board, cur_player):
    if isWinner('X'):
        return scores['X']
    elif isWinner('O'):
        return scores['O']
    elif isBoardFull():
        return scores['tie']
    if cur_player == 'X':
        bestScore = float('-inf')
        nextPlayer = 'O'
        minORmax = max
    else:
        bestScore = float('inf')
        nextPlayer = 'X'
        minORmax = min
    for row in range(3):
        for col in range(3):
            if board[row][col] == '':
                board[row][col] = cur_player
                score = minimax(board, nextPlayer)
                board[row][col] = ''
                bestScore = minORmax(score, bestScore)
            if bestScore == scores[cur_player]:
                return bestScore
    return bestScore


def updatePlayer(player):
    if player == 'X':
        newPlayer = 'O'
        previewImg = previewCircleImg
    else:
        newPlayer = 'X'
        previewImg = previewCrossImg
    return newPlayer, previewImg



def isWinner(player):
    return ((board[0][0] == player and board[0][1] == player and board[0][2] == player) or
            (board[1][0] == player and board[1][1] == player and board[1][2] == player) or
            (board[2][0] == player and board[2][1] == player and board[2][2] == player) or
            (board[0][0] == player and board[1][0] == player and board[2][0] == player) or
            (board[0][1] == player and board[1][1] == player and board[2][1] == player) or
            (board[0][2] == player and board[1][2] == player and board[2][2] == player) or
            (board[0][0] == player and board[1][1] == player and board[2][2] == player) or
            (board[0][2] == player and board[1][1] == player and board[2][0] == player))


def verifyWinner(player):
    global Send_Flag, Receive_Flag, Current_Player,dataSocket,gameMode,previewImg
    if isWinner(player):
        # dataSocket.close()
        # dataSocket, addr = listenSocket.accept()
        print(player, "win")
        if gameMode == 2:
            print("I have turn current_player to X")
            Current_Player = 'X'  # X先下棋
            previewImg = previewCrossImg
            if player == 'O':
                toSend = 'Over'
                dataSocket.send(toSend.encode())
                print("send_meseage:",toSend)
                Send_Flag = 0
                Receive_Flag = 0  ##一开始不发送也不接受，主机

        score[player] += 1
        ctypes.windll.user32.MessageBoxW(0, player + ' 获胜！', '提示', 0)
        resetBoard()
        return True
    return False


def isBoardFull():
    for i in range(3):
        for j in range(3):
            if board[i][j] == '':
                return False
    return True


def resetBoard():
    for i in range(3):
        for j in range(3):
            board[i][j] = ''

def Common_Reset():##对方刷新引起的刷新
    global Send_Flag,Receive_Flag,gameMode,Current_Player,previewImg,dataSocket,over_pos
    resetBoard()
    over_pos = []
    score['X'] = 0
    score['O'] = 0
    previewImg = previewCrossImg
    Current_Player = 'X'


def resetGame():
    global Send_Flag,Receive_Flag,gameMode,Current_Player,previewImg,dataSocket,over_pos
    over_pos= []
    resetBoard()
    score['X'] = 0
    score['O'] = 0
    if gameMode == 2:
        Current_Player = 'X'
        print("I have turn the picture to Cross")
        previewImg = previewCrossImg


global i
i = 0

def handle(rec):
    global send_row, send_col, Send_Flag, row, col, Receive_Flag, i, Current_Player, previewImg, message,over_pos
    global pi_sure_flag, pi_row, pi_col, pr_flash,pi_row,pi_reg
    if rec:
        print("rec    in re",rec)
        re_sure_flag = int(pi_sure_flag.search(rec).group(1))
        re_row = int(pi_row.search(rec).group(1))
        re_col = int(pi_col.search(rec).group(1))
        re_flash = int(pi_flash.search(rec).group(1))
        re_reg = int(pi_reg.search(rec).group(1))
        if re_sure_flag == 1:
            counter_row = re_row
            counter_col = re_col
            board[counter_row][counter_col] = "O"
            over_pos.append((counter_row,counter_col))
            drawBoard()
            Current_Player = 'X'  ##收到对面信息后回到主场
            previewImg = previewCrossImg
            pygame.display.update()

        if re_flash:
            Common_Reset()
        if re_reg == 1:
            print("接收reg")
            lenth = len(over_pos)
            if lenth > 0:
                x = over_pos[lenth - 1][0]
                y = over_pos[lenth - 1][1]
                del over_pos[lenth - 1]
                if lenth == 1:
                    resetGame()
                elif board[x][y] == "X":
                    print("regret x")
                    Current_Player = "O"
                    previewImg = previewCircleImg
                    board[x][y] = " "
                    drawBoard()
                elif board[x][y] == "O":
                    print("regret o")
                    Current_Player = "X"
                    previewImg = previewCrossImg
                    board[x][y] = " "
                    drawBoard()
                pygame.display.update()
            # time.sleep(0.5)



def TCP_Server():
    global send_row, send_col, Send_Flag, row, col, Receive_Flag, i, current_player, previewImg, message,sure_flag,flash_flag,SOR
    global pi_send_flag, pi_received_flag, pi_row, pi_col, pr_flash
    pi_sr = re.compile(r'SenOrRec(\d)')
    while True:
        if SOR == 0:
            time.sleep(0.3)
            print("Send_message", message)
            dataSocket.send(message.encode())
            sure_flag = 0
            flash_flag = 0
            regret_flag = 0
            message = "sure_f" + str(sure_flag) + "row" + str(send_row) + " col" + str(send_col) + "flash" + str(
                flash_flag) + "reg" + str(regret_flag)
            print("waiting for receiving...........")
            # time.sleep(0.1)
            SOR = 1
        if SOR == 1:
            recved = dataSocket.recv(BUFLEN)
            rec = recved.decode()
            if not recved:
                break
            if rec:
                # re_SOR = pi_sr.search(rec)
                # SOR = re_SOR.group(1)
                handle(rec)
                print("received", rec)
                dataSocket.send(message.encode())
                SOR = 0


server_thread = threading.Thread(target = TCP_Server )
server_thread.start()
menu()
dataSocket.close()
listenSocket.close()
```

#### 客户端

```python
import pygame
import ctypes
#  === TCP 客户端程序 client.py ===
import time
from socket import *
import threading
import re

global pi_reg,pi_sure_flag,pi_row,pi_col,pi_flash,message,SOR,sure_flag,flash_flag,over_pos,regret_flag,over_flag

pi_sure_flag=re.compile(r'sure_f(\d)')
pi_row=re.compile(r'row(\d)')
pi_col=re.compile(r'col(\d)')
pi_flash=re.compile(r'flash(\d)')##刷新参数
pi_reg = re.compile(r'reg(\d)')
message= "sure_f0 row0 col0 flash0 SenOrRec0 reg0"
SOR = 1
sure_flag = 0
flash_flag = 0
regret_flag = 0
over_pos= []
IP = '127.0.0.1'
SERVER_PORT = 50000
BUFLEN = 1024

# 实例化一个socket对象，指明协议
dataSocket = socket(AF_INET, SOCK_STREAM)
global Send_Flag,Receive_Flag,current_player,previewImg,gameMode
Send_Flag = 0
Receive_Flag = 1
current_player = 'X'#服务端先下
gameMode = 0
send_row = 0
send_col = 0
# 连接服务端socket
dataSocket.connect((IP, SERVER_PORT))
# 初始化 pygame
pygame.init()

# 定义颜色
blue = (78, 140, 243)
light_blue = (100, 100, 255)
red = (242, 89, 97)
light_red = (255, 100, 100)
dark_grey = (85, 85, 85)
light_grey = (100, 100, 100)
background_color = (225, 225, 225)

# 创建窗口
screen = pygame.display.set_mode((600, 800))
pygame.display.set_caption('井字棋-客户端')

# 游戏图片
crossImg = pygame.image.load('Images/crossImg.png')
crossImg_rect = crossImg.get_rect()
crossImg_rect.center = (200, 300)
circleImg = pygame.image.load('Images/circleImg.png')
circleImg_rect = crossImg.get_rect()
circleImg_rect.center = (400, 300)
previewCrossImg = pygame.image.load('Images/prev_crossImg.png')
previewCircleImg = pygame.image.load('Images/prev_circleImg.png')
previewImg = previewCrossImg
# 按钮图片
restartImg = pygame.image.load('Images/restart.png')
restartHoveredImg = pygame.image.load('Images/restart_hovered.png')
ReGretImg = pygame.image.load('Images/button4Img.png')

# 定义棋盘
board = [['', '', ''],
         ['', '', ''],
         ['', '', '']]

# 定义计分板
score = {'X': 0, 'O': 0}
font = pygame.font.Font('freesansbold.ttf', 32)
X_score = pygame.image.load('Images/X_scoreImg.png')
O_score = pygame.image.load('Images/O_scoreImg.png')

# 菜单图片
buttom1 = pygame.image.load('Images/button1Img.png')
buttom1_rect = buttom1.get_rect()
buttom1_rect.center = (300, 312)
buttom2 = pygame.image.load('Images/button2Img.png')
buttom2_rect = buttom2.get_rect()
buttom2_rect.center = (300, 472)
buttom3 = pygame.image.load('Images/button3Img.png')
buttom3_rect = buttom3.get_rect()
buttom3_rect.center = (300, 632)
buttom4_rect = ReGretImg.get_rect()
buttom4_rect.center = (478, 751)
logo = pygame.image.load('Images/logo.png')

# 选择菜单图片
chooseImg = pygame.image.load('Images/choose.png')


def menu():
    global gameMode
    running = True
    while running:
        screen.fill(background_color)
        mx, my = pygame.mouse.get_pos()
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if buttom1_rect.collidepoint((mx, my)):
                    gameMode= 0
                    game(0, 'X')
                elif buttom2_rect.collidepoint((mx, my)):
                    player = choose()
                    if player is not None:
                        gameMode= 1
                        game(1, player)
                elif buttom3_rect.collidepoint((mx, my)):
                    gameMode = 2
                    game(2, 'O')
        screen.blit(logo, (8, 25))
        screen.blit(buttom1, (100, 250))
        screen.blit(buttom2, (100, 410))
        screen.blit(buttom3, (100, 570))
        pygame.display.update()


def game(gameMode, player):
    global send_row, send_col, Send_Flag, Receive_Flag,row, col,current_player,previewImg,message,sure_flag,flash_flag,over,regret_flag
    my = player
    # player = current_player
    running = True
    if gameMode == 2:
        previewImg = previewCrossImg  # 服务端先下
    else:
        previewImg = previewCircleImg

    while running:
        mouse = pygame.mouse.get_pos()
        row, col = int(mouse[0] / 200), int(mouse[1] / 200)
        for event in pygame.event.get():
            if verifyWinner('O'):
                # player = 'O'
                # previewImg = previewCrossImg
                 pass
            if verifyWinner('X'):
                # player = 'X'
                # previewImg = previewCrossImg
                pass
            if event.type == pygame.QUIT:
                resetGame()
                running = False
            elif isBoardFull():
                ctypes.windll.user32.MessageBoxW(0, '平局', '提示', 0)
                resetBoard()
            elif gameMode == 1 and player != my:
                computerMove(player)
                drawBoard()
                pygame.display.update()
                if verifyWinner(player):
                    player = 'O'
                    previewImg = previewCrossImg
                else:
                    player, previewImg = updatePlayer(player)
            # elif gameMode == 2 and player != my:
            #     CounterMove(player)
            #     drawBoard()
            #     pygame.display.update()
            #     if verifyWinner(player):
            #         player = 'O'
            #         previewImg = previewCrossImg
            #     else:
            #         player, previewImg = updatePlayer(player)
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if gameMode != 2:
                    if row < 3 and col < 3 and board[row][col] == '':
                        send_row = row
                        send_col = col
                        playerMove(player, row, col)
                        drawBoard()
                        # Send_Flag = 1
                        # time.sleep(0.5)
                        if verifyWinner('O'):
                            player = 'X'
                            previewImg = previewCrossImg
                        else :
                            player, previewImg = updatePlayer(player)
                    #
                    #     else:
                    #         Receive_Flag = 1
                    # elif 550 < mouse[0] < 582 and 610 < mouse[1] < 642:
                    #     resetGame()
                if gameMode == 2:
                    if row < 3 and col < 3 and board[row][col] == '':
                        print("Current_Player", current_player)
                    if row < 3 and col < 3 and board[row][col] == '' and current_player == 'O':#自己的回合鼠标才能点击
                        send_row = row
                        send_col = col
                        sure_flag =1
                        message = "sure_f" + str(sure_flag) + "row" + str(send_row) + " col" + str(
                            send_col) + "flash" + str(
                            flash_flag) + "reg" + str(regret_flag)
                        playerMove('O', row, col)
                        drawBoard()
                        current_player = 'X'#下完换对方
                        previewImg = previewCrossImg
                        regret_flag = 0
                        Send_Flag = 1
                        Receive_Flag = 1
                        print("I am going to send O message")
                        # time.sleep(0.5)
                        print("I am wating for message")
                        # if verifyWinner(player):
                        #     player = 'O'
                        #     previewImg = previewCrossImg
                        # elif gameMode != 2:
                        #
                    # else:
                    #         Receive_Flag = 1
                if 550 < mouse[0] < 582 and 610 < mouse[1] < 642:
                    flash_flag = 1
                    message = "sure_f" + str(sure_flag) + "row" + str(send_row) + " col" + str(
                        send_col) + "flash" + str(flash_flag) + "reg" + str(regret_flag)
                    resetGame()
                if buttom4_rect.collidepoint((mouse[0], mouse[1])):
                    if gameMode != 1:
                        print("悔棋一次")
                        lenth =len(over_pos)
                        if lenth > 0:
                            x = over_pos[lenth - 1][0]
                            y = over_pos[lenth - 1][1]
                            del over_pos[lenth-1]
                            if lenth == 1:
                                resetGame()
                            elif board[x][y] == "X":
                                print("regret x")
                                Current_Player = "O"
                                previewImg = previewCircleImg
                                board[x][y] = " "
                                drawBoard()
                            elif board[x][y] == "O":
                                print("regret o")
                                Current_Player = "X"
                                previewImg = previewCrossImg
                                board[x][y] = " "
                                drawBoard()
                            pygame.display.update()
                    if gameMode == 1:
                        print("按钮有效")
                        lenth =len(over_pos)
                        print("regret,computer1111")
                        if lenth > 1 and current_player == my:
                            print("regret,computer")
                            x1 = over_pos[lenth - 1][0]
                            y1 = over_pos[lenth - 1][1]
                            x2 = over_pos[lenth - 2][0]
                            y2 = over_pos[lenth - 2][1]
                            del over_pos[lenth-1]
                            del over_pos[lenth-2]
                            board[x1][y1]= ' '
                            board[x2][y2]= ' '
                            drawBoard()
                            pygame.display.update()
                    if gameMode == 2 :
                        print("regret.....in  ..here")
                        regret_flag = 1
                        message = "sure_f"+str(sure_flag) + "row" + str(send_row)+" col"+str(send_col) + "flash"+ str(flash_flag)+"reg"+str(regret_flag)
        screen.fill(background_color)
        drawBoard()
        drawBottomMenu(mouse)
        if row < 3 and col < 3:
            visualizeMove(row, col, previewImg)
        pygame.display.update()


def choose():
    player = None
    running = True
    while running:
        mouse = pygame.mouse.get_pos()
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if crossImg_rect.collidepoint((mouse[0], mouse[1])):
                    player = 'X'
                    running = False
                elif circleImg_rect.collidepoint((mouse[0], mouse[1])):
                    player = 'O'
                    running = False
        screen.blit(crossImg, (80, 300))
        screen.blit(circleImg, (340, 300))
        screen.blit(chooseImg, (8, 25))
        pygame.display.update()
    return player


def drawBoard():
    # 画棋子
    for row in range(3):
        for col in range(3):
            pos = (row * 200 + 12, col * 200 + 12)
            if board[row][col] == 'X':
                screen.blit(crossImg, pos)
            elif board[row][col] == 'O':
                screen.blit(circleImg, pos)
    # 画网格
    width = 10
    color = dark_grey
    pygame.draw.line(screen, color, (200, 0), (200, 600), width)
    pygame.draw.line(screen, color, (400, 0), (400, 600), width)
    pygame.draw.line(screen, color, (0, 200), (600, 200), width)
    pygame.draw.line(screen, color, (0, 400), (600, 400), width)
    # 画边框
    pygame.draw.rect(screen, color, (0, 0, 10, 600))
    pygame.draw.rect(screen, color, (0, 0, 600, 10))
    pygame.draw.rect(screen, color, (590, 0, 10, 600))


def drawBottomMenu(mouse):
    pygame.draw.rect(screen, dark_grey, (0, 600, 600, 100))
    pygame.draw.rect(screen, light_grey, (10, 610, 580, 80))
    screen.blit(restartImg, (550, 610))
    screen.blit(ReGretImg,(400,720))
    # Hover animation
    if 550 < mouse[0] < 582 and 610 < mouse[1] < 642:
        screen.blit(restartHoveredImg, (548, 608))
    screen.blit(X_score, (200, 610))
    screen.blit(O_score, (370, 610))
    scoreboard = font.render(': %d x %d :' % (score['X'], score['O']), True, background_color, light_grey)
    screen.blit(scoreboard, (244, 610))


def visualizeMove(row, col, previewImg):
    if board[row][col] == '':
        screen.blit(previewImg, (row * 200 + 12, col * 200 + 12))


def playerMove(player, row, col):
    board[row][col] = player
    over_pos.append((row,col))

def computerMove(player):
    global  over_pos
    bestScore = float('inf')
    for row in range(3):
        for col in range(3):
            if board[row][col] == '':
                board[row][col] = 'O'
                score = minimax(board, 'X')
                board[row][col] = ''
                if score < bestScore:
                    bestScore = score
                    bestMove = (row, col)
    board[bestMove[0]][bestMove[1]] = player
    over_pos.append((bestMove[0],bestMove[1]))

scores = {'X': 1, 'O': -1, 'tie': 0}


def minimax(board, cur_player):
    if isWinner('X'):
        return scores['X']
    elif isWinner('O'):
        return scores['O']
    elif isBoardFull():
        return scores['tie']
    if cur_player == 'X':
        bestScore = float('-inf')
        nextPlayer = 'O'
        minORmax = max
    else:
        bestScore = float('inf')
        nextPlayer = 'X'
        minORmax = min
    for row in range(3):
        for col in range(3):
            if board[row][col] == '':
                board[row][col] = cur_player
                score = minimax(board, nextPlayer)
                board[row][col] = ''
                bestScore = minORmax(score, bestScore)
            if bestScore == scores[cur_player]:
                return bestScore
    return bestScore


def updatePlayer(player):
    if player == 'X':
        newPlayer = 'O'
        previewImg = previewCircleImg
    else:
        newPlayer = 'X'
        previewImg = previewCrossImg
    return newPlayer, previewImg



def isWinner(player):
    return ((board[0][0] == player and board[0][1] == player and board[0][2] == player) or
            (board[1][0] == player and board[1][1] == player and board[1][2] == player) or
            (board[2][0] == player and board[2][1] == player and board[2][2] == player) or
            (board[0][0] == player and board[1][0] == player and board[2][0] == player) or
            (board[0][1] == player and board[1][1] == player and board[2][1] == player) or
            (board[0][2] == player and board[1][2] == player and board[2][2] == player) or
            (board[0][0] == player and board[1][1] == player and board[2][2] == player) or
            (board[0][2] == player and board[1][1] == player and board[2][0] == player))


def verifyWinner(player):
    global  Send_Flag,Receive_Flag,current_player,dataSocket,previewImg,gameMode,SOR
    if isWinner(player):
        print(player, "win")
        if gameMode ==2:
            previewImg = previewCrossImg
            current_player = 'X'  # 服务端先下
            SOR = 0
            # if player == 'X':
                # toSend = 'Over'
                # dataSocket.send(toSend.encode())
                # print("send_meseage:", toSend)
                # Send_Flag = 0
                # Receive_Flag = 1
        score[player] += 1
        ctypes.windll.user32.MessageBoxW(0, player + ' 获胜！', '提示', 0)
        resetBoard()
        return True
    return False


def isBoardFull():
    for i in range(3):
        for j in range(3):
            if board[i][j] == '':
                return False
    return True


def resetBoard():
    for i in range(3):
        for j in range(3):
            board[i][j] = ''

def Common_Reset():##对方刷新引起的刷新，被动刷新
    global Send_Flag,Receive_Flag,gameMode,current_player,previewImg,dataSocket
    resetBoard()
    score['X'] = 0
    score['O'] = 0
    if gameMode == 2:
        current_player = 'X'
        print("I have turn the picture to Cross")
        previewImg = previewCrossImg
def resetGame():##主动刷新
    global Send_Flag, Receive_Flag, gameMode, current_player, previewImg, dataSocket,over_pos
    resetBoard()
    over_pos= []
    score['X'] = 0
    score['O'] = 0
    if gameMode == 2:
        current_player = 'X'
        print("I have turn the picture to Cross")
        previewImg = previewCrossImg

    resetBoard()
    score['X'] = 0
    score['O'] = 0
global i
i = 0
def handle(rec):
    global send_row, send_col ,Send_Flag,row, col,Receive_Flag, i, current_player, previewImg,message,over_pos
    global pi_sure_flag, pi_row, pi_col, pr_flash
    if rec:
        re_sure_flag = int(pi_sure_flag.search(rec).group(1))
        re_row = int(pi_row.search(rec).group(1))
        re_col = int(pi_col.search(rec).group(1))
        re_flash = int(pi_flash.search(rec).group(1))
        re_reg = int(pi_reg.search(rec).group(1))
        if re_sure_flag == 1:
            counter_row = re_row
            counter_col = re_col
            board[counter_row][counter_col] = "X"
            over_pos.append((counter_row,counter_col))
            drawBoard()
            current_player = 'O'  ##收到对面信息后回到主场
            previewImg = previewCircleImg
            pygame.display.update()
        if re_flash ==1 :
            Common_Reset()
        if re_reg == 1:
            print("悔棋一次")
            lenth = len(over_pos)
            if lenth > 0:
                x = over_pos[lenth - 1][0]
                y = over_pos[lenth - 1][1]
                del over_pos[lenth - 1]
                if lenth == 1:
                    resetGame()
                elif board[x][y] == "X":
                    print("regret x")
                    Current_Player = "O"
                    previewImg = previewCircleImg
                    board[x][y] = " "
                    drawBoard()
                elif board[x][y] == "O":
                    print("regret o")
                    Current_Player = "X"
                    previewImg = previewCrossImg
                    board[x][y] = " "
                    drawBoard()
                pygame.display.update()



def TCP_Client():
    global send_row, send_col ,Send_Flag,row, col,Receive_Flag, i, current_player, previewImg,message,SOR,sure_flag,flash_flag,regret_flag
    global pi_send_flag, pi_received_flag, pi_row, pi_col, pr_flash
    pi_sr = re.compile(r'SenOrRec(\d)')
    while True:
        if SOR == 1:
            print("waiting for receiving...........")
            recved = dataSocket.recv(BUFLEN)
            rec = recved.decode()
            if not recved:
                break
            if rec:
                handle(rec)
                print("received", rec)
                dataSocket.send(message.encode())
                SOR = 0
        # time.sleep(0.3)
        if SOR == 0:
            print("sending",message)
            dataSocket.send(message.encode())
            sure_flag = 0
            flash_flag = 0
            regret_flag = 0
            message = "sure_f" + str(sure_flag) + "row" + str(send_row) + " col" + str(send_col) + "flash" + str(
                flash_flag) + "reg" + str(regret_flag)
            # time.sleep(0.1)
            SOR = 1


client_thread = threading.Thread(target=TCP_Client)
client_thread.start()

menu()
dataSocket.close()
```

### 临时版本

#### 服务端

```pythin
import pygame
import ctypes
# 导入socket 库
from socket import *
import threading
import time
import re
global pi_reg,pi_sure_flag,pi_row,pi_col,pi_flash,message,sure_flag,flash_flag,SOR, board,over_pos,regret_flag,Socket_init_Flag,dataSocket
Socket_init_Flag = 0
pi_sure_flag=re.compile(r'sure_f(\d)')
pi_row=re.compile(r'row(\d)')
pi_col=re.compile(r'col(\d)')
pi_flash=re.compile(r'flash(\d)')##刷新参数
pi_reg = re.compile(r'reg(\d)')
message= "sure_f0 row0 col0 flash0 SenOrRec0 reg0"
sure_flag = 0
flash_flag = 0
regret_flag = 0
over_pos= []
send_row = 0
send_col = 0
SOR = 0 #0是发送
# 主机地址为空字符串，表示绑定本机所有网络接口ip地址
# 等待客户端来连接
IP = '192.168.196.156'
# 端口号
PORT = 50000
# 定义一次从socket缓冲区最多读入512个字节数据
BUFLEN = 512

def Client_socket():
    global dataSocket,Socket_init_Flag
    # 实例化一个socket对象
    # 参数 AF_INET 表示该socket网络层使用IP协议
    # 参数 SOCK_STREAM 表示该socket传输层使用TCP协议
    listenSocket = socket(AF_INET, SOCK_STREAM)

    # socket绑定地址和端口
    listenSocket.bind((IP, PORT))

    # 使socket处于监听状态，等待客户端的连接请求
    # 参数 8 表示 最多接受多少个等待连接的客户端
    listenSocket.listen(8)
    print(f'服务端启动成功，在{PORT}端口等待客户端连接...')

    dataSocket, addr = listenSocket.accept()
    Socket_init_Flag = 1
    print('接受一个客户端连接:', addr)
global Send_Flag,Receive_Flag,Current_Player,If_over,previewImg,gameMode,Ini_FLag,Reset_Flag
# 初始化 pygame
pygame.init()

# 定义颜色
blue = (78, 140, 243)
light_blue = (100, 100, 255)
red = (242, 89, 97)
light_red = (255, 100, 100)
dark_grey = (85, 85, 85)
light_grey = (100, 100, 100)
background_color = (225, 225, 225)
Send_Flag = 0
Receive_Flag = 0##一开始不发送也不接受，主机
Current_Player = 'X'#X先下棋
If_over = 0
gameMode = 0
Ini_FLag = 1
# 创建窗口
screen = pygame.display.set_mode((600, 800))
pygame.display.set_caption('井字棋')

# 游戏图片
crossImg = pygame.image.load('Images/crossImg.png')
crossImg_rect = crossImg.get_rect()
crossImg_rect.center = (200, 300)
circleImg = pygame.image.load('Images/circleImg.png')
circleImg_rect = crossImg.get_rect()
circleImg_rect.center = (400, 300)
previewCrossImg = pygame.image.load('Images/prev_crossImg.png')
previewCircleImg = pygame.image.load('Images/prev_circleImg.png')

previewImg = previewCrossImg
# 按钮图片
restartImg = pygame.image.load('Images/restart.png')
restartHoveredImg = pygame.image.load('Images/restart_hovered.png')
ReGretImg = pygame.image.load('Images/button4Img.png')
# 定义棋盘
board = [['', '', ''],
         ['', '', ''],
         ['', '', '']]

# 定义计分板
score = {'X': 0, 'O': 0}
font = pygame.font.Font('freesansbold.ttf', 32)
X_score = pygame.image.load('Images/X_scoreImg.png')
O_score = pygame.image.load('Images/O_scoreImg.png')

# 菜单图片
buttom1 = pygame.image.load('Images/button1Img.png')
buttom1_rect = buttom1.get_rect()
buttom1_rect.center = (300, 312)
buttom2 = pygame.image.load('Images/button2Img.png')
buttom2_rect = buttom2.get_rect()
buttom2_rect.center = (300, 472)

buttom3 = pygame.image.load('Images/button3Img.png')
buttom3_rect = buttom3.get_rect()
buttom3_rect.center = (300, 632)

buttom4_rect = ReGretImg.get_rect()
buttom4_rect.center = (478, 751)

logo = pygame.image.load('Images/logo.png')

# 选择菜单图片
chooseImg = pygame.image.load('Images/choose.png')


def menu():
    global gameMode
    running = True
    while running:
        screen.fill(background_color)
        mx, my = pygame.mouse.get_pos()
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if buttom1_rect.collidepoint((mx, my)):
                    game(0, 'X')
                    gameMode = 0
                elif buttom2_rect.collidepoint((mx, my)):
                    player = choose()
                    if player is not None:
                        game(1, player)
                        gameMode =1
                elif buttom3_rect.collidepoint((mx, my)):
                    Client_socket()
                    gameMode = 2
                    game(2, 'X')
        screen.blit(logo, (8, 25))
        screen.blit(buttom1, (100, 250))
        screen.blit(buttom2, (100, 410))
        screen.blit(buttom3, (100, 570))
        pygame.display.update()


def game(gameMode, player):
    global send_row, send_col ,Send_Flag,row, col,Receive_Flag,Current_Player,If_over,previewImg,message,sure_flag,flash_flag,board,regret_flag
    my = player
    player = 'X'
    running = True
    while running:
        mouse = pygame.mouse.get_pos()
        row, col = int(mouse[0] / 200), int(mouse[1] / 200)
        for event in pygame.event.get():
            if verifyWinner('X'):
                print("确认X胜利")
                player = 'X'
                previewImg = previewCrossImg
            if verifyWinner('O'):
                print("确认O胜利")
                player = 'X'
                previewImg = previewCrossImg
            if event.type == pygame.QUIT:
                resetGame()
                running = False
            elif isBoardFull():
                ctypes.windll.user32.MessageBoxW(0, '平局', '提示', 0)
                resetBoard()
            elif gameMode == 1 and player != my:
                computerMove(player)
                drawBoard()
                pygame.display.update()
                # if verifyWinner(player):
                #     player = 'X'
                #     previewImg = previewCrossImg
                # else:
                #     player, previewImg = updatePlayer(player)
                if verifyWinner(player):
                    player = 'X'
                    previewImg = previewCrossImg
                else:
                    player, previewImg = updatePlayer(player)
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if gameMode != 2:
                    if row < 3 and col < 3 and board[row][col] == '':
                        # send_row = row
                        # send_col = col
                        playerMove(player, row, col)
                        drawBoard()
                        Send_Flag = 1
                        time.sleep(0.5)
                        if verifyWinner('X'):
                            player = 'X'
                            previewImg = previewCrossImg
                        else :
                            player, previewImg = updatePlayer(player)
                if gameMode == 2:
                    if row < 3 and col < 3 and board[row][col] == '':
                        print("Current_Player", Current_Player)
                    if row < 3 and col < 3 and board[row][col] == '' and Current_Player == 'X':#自己的回合鼠标才能点击
                        sure_flag = 1
                        send_row = row
                        send_col = col
                        regret_flag = 0
                        message = "sure_f"+str(sure_flag) + "row" + str(send_row)+" col"+str(send_col) + "flash"+ str(flash_flag)+"reg"+str(regret_flag)
                        time.sleep(0.3)
                        playerMove('X', row, col)
                        drawBoard()
                        Current_Player = 'O'#下完换对方
                        previewImg = previewCircleImg
                        print("I am going to Send message X")
                        time.sleep(0.5)
                        print("I am waiting for O message")
                    # else:
                    #         Receive_Flag = 1
                if 550 < mouse[0] < 582 and 610 < mouse[1] < 642:
                    flash_flag = 1
                    message = "sure_f" + str(sure_flag) + "row" + str(send_row) + " col" + str(
                        send_col) + "flash" + str(flash_flag) + "reg" + str(regret_flag)
                    resetGame()
                if buttom4_rect.collidepoint((mouse[0], mouse[1])):
                    if gameMode != 0 :
                        print("按钮有效")
                        lenth =len(over_pos)
                        if lenth > 0:
                            x = over_pos[lenth - 1][0]
                            y = over_pos[lenth - 1][1]
                            del over_pos[lenth-1]
                            if lenth == 1:
                                resetGame()
                            elif board[x][y] == "X":
                                print("regret x")
                                Current_Player = "O"
                                previewImg = previewCircleImg
                                board[x][y] = " "
                                drawBoard()
                            elif board[x][y] == "O":
                                print("regret o")
                                Current_Player = "X"
                                previewImg = previewCrossImg
                                board[x][y] = " "
                                drawBoard()
                            pygame.display.update()
                        # time.sleep(0.5)
                    if gameMode == 1:
                        print("按钮有效")
                        lenth =len(over_pos)
                        print("regret,computer1111")
                        if lenth > 1 and Current_Player == my:
                            print("regret,computer")
                            x1 = over_pos[lenth - 1][0]
                            y1 = over_pos[lenth - 1][1]
                            x2 = over_pos[lenth - 2][0]
                            y2 = over_pos[lenth - 2][1]
                            del over_pos[lenth-1]
                            del over_pos[lenth-2]
                            board[x1][y1]= ' '
                            board[x2][y2]= ' '
                            drawBoard()
                            pygame.display.update()
                        # time.sleep(0.5)
                    if gameMode == 2 :
                        print("regret>>>")
                        regret_flag = 1
                        message = "sure_f"+str(sure_flag) + "row" + str(send_row)+" col"+str(send_col) + "flash"+ str(flash_flag)+"reg"+str(regret_flag)
                            # time.sleep(0.5)
        screen.fill(background_color)
        drawBoard()
        drawBottomMenu(mouse)
        if row < 3 and col < 3:
            visualizeMove(row, col, previewImg)
        pygame.display.update()


def choose():
    player = None
    running = True
    while running:
        mouse = pygame.mouse.get_pos()
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if crossImg_rect.collidepoint((mouse[0], mouse[1])):
                    player = 'X'
                    running = False
                elif circleImg_rect.collidepoint((mouse[0], mouse[1])):
                    player = 'O'
                    running = False
        screen.blit(crossImg, (80, 300))
        screen.blit(circleImg, (340, 300))
        screen.blit(chooseImg, (8, 25))
        pygame.display.update()
    return player


def drawBoard():
    # 画棋子
    for row in range(3):
        for col in range(3):
            pos = (row * 200 + 12, col * 200 + 12)
            if board[row][col] == 'X':
                screen.blit(crossImg, pos)
            elif board[row][col] == 'O':
                screen.blit(circleImg, pos)
    # 画网格
    width = 10
    color = dark_grey
    pygame.draw.line(screen, color, (200, 0), (200, 600), width)
    pygame.draw.line(screen, color, (400, 0), (400, 600), width)
    pygame.draw.line(screen, color, (0, 200), (600, 200), width)
    pygame.draw.line(screen, color, (0, 400), (600, 400), width)
    # 画边框
    pygame.draw.rect(screen, color, (0, 0, 10, 600))
    pygame.draw.rect(screen, color, (0, 0, 600, 10))
    pygame.draw.rect(screen, color, (590, 0, 10, 600))


def drawBottomMenu(mouse):
    pygame.draw.rect(screen, dark_grey, (0, 600, 600, 100))
    pygame.draw.rect(screen, light_grey, (10, 610, 580, 80))
    screen.blit(restartImg, (550, 610))
    screen.blit(ReGretImg,(400,720))
    # Hover animation
    if 550 < mouse[0] < 582 and 610 < mouse[1] < 642:
        screen.blit(restartHoveredImg, (548, 608))
    screen.blit(X_score, (200, 610))
    screen.blit(O_score, (370, 610))
    scoreboard = font.render(': %d x %d :' % (score['X'], score['O']), True, background_color, light_grey)
    screen.blit(scoreboard, (244, 610))


def visualizeMove(row, col, previewImg):
    if board[row][col] == '':
        screen.blit(previewImg, (row * 200 + 12, col * 200 + 12))


def playerMove(player, row, col):
    board[row][col] = player
    over_pos.append((row,col))
def CounterMove(row, col):
    board[row][col] = "O"


def computerMove(player):
    global over_pos
    bestScore = float('inf')
    for row in range(3):
        for col in range(3):
            if board[row][col] == '':
                board[row][col] = 'O'
                score = minimax(board, 'X')
                board[row][col] = ''
                if score < bestScore:
                    bestScore = score
                    bestMove = (row, col)
    board[bestMove[0]][bestMove[1]] = player
    over_pos.append((bestMove[0],bestMove[1]))


scores = {'X': 1, 'O': -1, 'tie': 0}


def minimax(board, cur_player):
    if isWinner('X'):
        return scores['X']
    elif isWinner('O'):
        return scores['O']
    elif isBoardFull():
        return scores['tie']
    if cur_player == 'X':
        bestScore = float('-inf')
        nextPlayer = 'O'
        minORmax = max
    else:
        bestScore = float('inf')
        nextPlayer = 'X'
        minORmax = min
    for row in range(3):
        for col in range(3):
            if board[row][col] == '':
                board[row][col] = cur_player
                score = minimax(board, nextPlayer)
                board[row][col] = ''
                bestScore = minORmax(score, bestScore)
            if bestScore == scores[cur_player]:
                return bestScore
    return bestScore


def updatePlayer(player):
    if player == 'X':
        newPlayer = 'O'
        previewImg = previewCircleImg
    else:
        newPlayer = 'X'
        previewImg = previewCrossImg
    return newPlayer, previewImg



def isWinner(player):
    return ((board[0][0] == player and board[0][1] == player and board[0][2] == player) or
            (board[1][0] == player and board[1][1] == player and board[1][2] == player) or
            (board[2][0] == player and board[2][1] == player and board[2][2] == player) or
            (board[0][0] == player and board[1][0] == player and board[2][0] == player) or
            (board[0][1] == player and board[1][1] == player and board[2][1] == player) or
            (board[0][2] == player and board[1][2] == player and board[2][2] == player) or
            (board[0][0] == player and board[1][1] == player and board[2][2] == player) or
            (board[0][2] == player and board[1][1] == player and board[2][0] == player))


def verifyWinner(player):
    global Send_Flag, Receive_Flag, Current_Player,dataSocket,gameMode,previewImg
    if isWinner(player):
        # dataSocket.close()
        # dataSocket, addr = listenSocket.accept()
        print(player, "win")
        if gameMode == 2:
            print("I have turn current_player to X")
            Current_Player = 'X'  # X先下棋
            previewImg = previewCrossImg
            if player == 'O':
                toSend = 'Over'
                dataSocket.send(toSend.encode())
                print("send_meseage:",toSend)
                Send_Flag = 0
                Receive_Flag = 0  ##一开始不发送也不接受，主机

        score[player] += 1
        ctypes.windll.user32.MessageBoxW(0, player + ' 获胜！', '提示', 0)
        resetBoard()
        return True
    return False


def isBoardFull():
    for i in range(3):
        for j in range(3):
            if board[i][j] == '':
                return False
    return True


def resetBoard():
    for i in range(3):
        for j in range(3):
            board[i][j] = ''

def Common_Reset():##对方刷新引起的刷新
    global Send_Flag,Receive_Flag,gameMode,Current_Player,previewImg,dataSocket,over_pos
    resetBoard()
    over_pos = []
    score['X'] = 0
    score['O'] = 0
    previewImg = previewCrossImg
    Current_Player = 'X'


def resetGame():
    global Send_Flag,Receive_Flag,gameMode,Current_Player,previewImg,dataSocket,over_pos
    over_pos= []
    resetBoard()
    score['X'] = 0
    score['O'] = 0
    if gameMode == 2:
        Current_Player = 'X'
        print("I have turn the picture to Cross")
        previewImg = previewCrossImg


global i
i = 0

def handle(rec):
    global send_row, send_col, Send_Flag, row, col, Receive_Flag, i, Current_Player, previewImg, message,over_pos
    global pi_sure_flag, pi_row, pi_col, pr_flash,pi_row,pi_reg
    if rec:
        print("rec    in re",rec)
        re_sure_flag = int(pi_sure_flag.search(rec).group(1))
        re_row = int(pi_row.search(rec).group(1))
        re_col = int(pi_col.search(rec).group(1))
        re_flash = int(pi_flash.search(rec).group(1))
        re_reg = int(pi_reg.search(rec).group(1))
        if re_sure_flag == 1:
            counter_row = re_row
            counter_col = re_col
            board[counter_row][counter_col] = "O"
            over_pos.append((counter_row,counter_col))
            drawBoard()
            Current_Player = 'X'  ##收到对面信息后回到主场
            previewImg = previewCrossImg
            pygame.display.update()

        if re_flash:
            Common_Reset()
        if re_reg == 1:
            print("接收reg")
            lenth = len(over_pos)
            if lenth > 0:
                x = over_pos[lenth - 1][0]
                y = over_pos[lenth - 1][1]
                del over_pos[lenth - 1]
                if lenth == 1:
                    resetGame()
                elif board[x][y] == "X":
                    print("regret x")
                    Current_Player = "O"
                    previewImg = previewCircleImg
                    board[x][y] = " "
                    drawBoard()
                elif board[x][y] == "O":
                    print("regret o")
                    Current_Player = "X"
                    previewImg = previewCrossImg
                    board[x][y] = " "
                    drawBoard()
                pygame.display.update()
            # time.sleep(0.5)



def TCP_Server():
    global send_row, send_col, Send_Flag, row, col, Receive_Flag, i, current_player, previewImg, message,sure_flag,flash_flag,SOR,gameMode,Socket_init_Flag,dataSocket
    global pi_send_flag, pi_received_flag, pi_row, pi_col, pr_flash
    while gameMode == 2 and Socket_init_Flag == 1:
        if SOR == 0:
            time.sleep(0.3)
            print("Send_message", message)
            dataSocket.send(message.encode())
            sure_flag = 0
            flash_flag = 0
            regret_flag = 0
            message = "sure_f" + str(sure_flag) + "row" + str(send_row) + " col" + str(send_col) + "flash" + str(
                flash_flag) + "reg" + str(regret_flag)
            print("waiting for receiving...........")
            # time.sleep(0.1)
            SOR = 1
        if SOR == 1:
            recved = dataSocket.recv(BUFLEN)
            rec = recved.decode()
            if not recved:
                break
            if rec:
                # re_SOR = pi_sr.search(rec)
                # SOR = re_SOR.group(1)
                handle(rec)
                print("received", rec)
                dataSocket.send(message.encode())
                SOR = 0


server_thread = threading.Thread(target = TCP_Server )
server_thread.start()
menu()
dataSocket.close()
listenSocket.close()
```

### 点击联机模式才开始连接

#### 服务端

```python
import pygame
import ctypes
# 导入socket 库
from socket import *
import threading
import time
import re
global pi_reg,pi_sure_flag,pi_row,pi_col,pi_flash,message,sure_flag,flash_flag,SOR, board,over_pos,regret_flag,Socket_init_Flag,dataSocket
Socket_init_Flag = 0
pi_sure_flag=re.compile(r'sure_f(\d)')
pi_row=re.compile(r'row(\d)')
pi_col=re.compile(r'col(\d)')
pi_flash=re.compile(r'flash(\d)')##刷新参数
pi_reg = re.compile(r'reg(\d)')
message= "sure_f0 row0 col0 flash0 SenOrRec0 reg0"
sure_flag = 0
flash_flag = 0
regret_flag = 0
over_pos= []
send_row = 0
send_col = 0
SOR = 0 #0是发送
# 主机地址为空字符串，表示绑定本机所有网络接口ip地址
# 等待客户端来连接
IP = '192.168.196.156'
# 端口号
PORT = 50000
# 定义一次从socket缓冲区最多读入512个字节数据
BUFLEN = 512

def Client_socket():
    global dataSocket,Socket_init_Flag
    # 实例化一个socket对象
    # 参数 AF_INET 表示该socket网络层使用IP协议
    # 参数 SOCK_STREAM 表示该socket传输层使用TCP协议
    listenSocket = socket(AF_INET, SOCK_STREAM)

    # socket绑定地址和端口
    listenSocket.bind((IP, PORT))

    # 使socket处于监听状态，等待客户端的连接请求
    # 参数 8 表示 最多接受多少个等待连接的客户端
    listenSocket.listen(8)
    print(f'服务端启动成功，在{PORT}端口等待客户端连接...')

    dataSocket, addr = listenSocket.accept()
    Socket_init_Flag = 1
    print('接受一个客户端连接:', addr)
global Send_Flag,Receive_Flag,Current_Player,If_over,previewImg,gameMode,Ini_FLag,Reset_Flag
# 初始化 pygame
pygame.init()

# 定义颜色
blue = (78, 140, 243)
light_blue = (100, 100, 255)
red = (242, 89, 97)
light_red = (255, 100, 100)
dark_grey = (85, 85, 85)
light_grey = (100, 100, 100)
background_color = (225, 225, 225)
Send_Flag = 0
Receive_Flag = 0##一开始不发送也不接受，主机
Current_Player = 'X'#X先下棋
If_over = 0
gameMode = 0
Ini_FLag = 1
# 创建窗口
screen = pygame.display.set_mode((600, 800))
pygame.display.set_caption('井字棋')

# 游戏图片
crossImg = pygame.image.load('Images/crossImg.png')
crossImg_rect = crossImg.get_rect()
crossImg_rect.center = (200, 300)
circleImg = pygame.image.load('Images/circleImg.png')
circleImg_rect = crossImg.get_rect()
circleImg_rect.center = (400, 300)
previewCrossImg = pygame.image.load('Images/prev_crossImg.png')
previewCircleImg = pygame.image.load('Images/prev_circleImg.png')

previewImg = previewCrossImg
# 按钮图片
restartImg = pygame.image.load('Images/restart.png')
restartHoveredImg = pygame.image.load('Images/restart_hovered.png')
ReGretImg = pygame.image.load('Images/button4Img.png')
# 定义棋盘
board = [['', '', ''],
         ['', '', ''],
         ['', '', '']]

# 定义计分板
score = {'X': 0, 'O': 0}
font = pygame.font.Font('freesansbold.ttf', 32)
X_score = pygame.image.load('Images/X_scoreImg.png')
O_score = pygame.image.load('Images/O_scoreImg.png')

# 菜单图片
buttom1 = pygame.image.load('Images/button1Img.png')
buttom1_rect = buttom1.get_rect()
buttom1_rect.center = (300, 312)
buttom2 = pygame.image.load('Images/button2Img.png')
buttom2_rect = buttom2.get_rect()
buttom2_rect.center = (300, 472)

buttom3 = pygame.image.load('Images/button3Img.png')
buttom3_rect = buttom3.get_rect()
buttom3_rect.center = (300, 632)

buttom4_rect = ReGretImg.get_rect()
buttom4_rect.center = (478, 751)

logo = pygame.image.load('Images/logo.png')

# 选择菜单图片
chooseImg = pygame.image.load('Images/choose.png')


def menu():
    global gameMode
    running = True
    while running:
        screen.fill(background_color)
        mx, my = pygame.mouse.get_pos()
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if buttom1_rect.collidepoint((mx, my)):
                    game(0, 'X')
                    gameMode = 0
                elif buttom2_rect.collidepoint((mx, my)):
                    player = choose()
                    if player is not None:
                        game(1, player)
                        gameMode =1
                elif buttom3_rect.collidepoint((mx, my)):
                    Client_socket()
                    gameMode = 2
                    game(2, 'X')
        screen.blit(logo, (8, 25))
        screen.blit(buttom1, (100, 250))
        screen.blit(buttom2, (100, 410))
        screen.blit(buttom3, (100, 570))
        pygame.display.update()


def game(gameMode, player):
    global send_row, send_col ,Send_Flag,row, col,Receive_Flag,Current_Player,If_over,previewImg,message,sure_flag,flash_flag,board,regret_flag
    my = player
    player = 'X'
    running = True
    while running:
        mouse = pygame.mouse.get_pos()
        row, col = int(mouse[0] / 200), int(mouse[1] / 200)
        for event in pygame.event.get():
            if verifyWinner('X'):
                print("确认X胜利")
                player = 'X'
                previewImg = previewCrossImg
            if verifyWinner('O'):
                print("确认O胜利")
                player = 'X'
                previewImg = previewCrossImg
            if event.type == pygame.QUIT:
                resetGame()
                running = False
            elif isBoardFull():
                ctypes.windll.user32.MessageBoxW(0, '平局', '提示', 0)
                resetBoard()
            elif gameMode == 1 and player != my:
                computerMove(player)
                drawBoard()
                pygame.display.update()
                # if verifyWinner(player):
                #     player = 'X'
                #     previewImg = previewCrossImg
                # else:
                #     player, previewImg = updatePlayer(player)
                if verifyWinner(player):
                    player = 'X'
                    previewImg = previewCrossImg
                else:
                    player, previewImg = updatePlayer(player)
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if gameMode != 2:
                    if row < 3 and col < 3 and board[row][col] == '':
                        # send_row = row
                        # send_col = col
                        playerMove(player, row, col)
                        drawBoard()
                        Send_Flag = 1
                        time.sleep(0.5)
                        if verifyWinner('X'):
                            player = 'X'
                            previewImg = previewCrossImg
                        else :
                            player, previewImg = updatePlayer(player)
                if gameMode == 2:
                    if row < 3 and col < 3 and board[row][col] == '':
                        print("Current_Player", Current_Player)
                    if row < 3 and col < 3 and board[row][col] == '' and Current_Player == 'X':#自己的回合鼠标才能点击
                        sure_flag = 1
                        send_row = row
                        send_col = col
                        regret_flag = 0
                        message = "sure_f"+str(sure_flag) + "row" + str(send_row)+" col"+str(send_col) + "flash"+ str(flash_flag)+"reg"+str(regret_flag)
                        time.sleep(0.3)
                        playerMove('X', row, col)
                        drawBoard()
                        Current_Player = 'O'#下完换对方
                        previewImg = previewCircleImg
                        print("I am going to Send message X")
                        time.sleep(0.5)
                        print("I am waiting for O message")
                    # else:
                    #         Receive_Flag = 1
                if 550 < mouse[0] < 582 and 610 < mouse[1] < 642:
                    flash_flag = 1
                    message = "sure_f" + str(sure_flag) + "row" + str(send_row) + " col" + str(
                        send_col) + "flash" + str(flash_flag) + "reg" + str(regret_flag)
                    resetGame()
                if buttom4_rect.collidepoint((mouse[0], mouse[1])):
                    if gameMode != 0 :
                        print("按钮有效")
                        lenth =len(over_pos)
                        if lenth > 0:
                            x = over_pos[lenth - 1][0]
                            y = over_pos[lenth - 1][1]
                            del over_pos[lenth-1]
                            if lenth == 1:
                                resetGame()
                            elif board[x][y] == "X":
                                print("regret x")
                                Current_Player = "O"
                                previewImg = previewCircleImg
                                board[x][y] = " "
                                drawBoard()
                            elif board[x][y] == "O":
                                print("regret o")
                                Current_Player = "X"
                                previewImg = previewCrossImg
                                board[x][y] = " "
                                drawBoard()
                            pygame.display.update()
                        # time.sleep(0.5)
                    if gameMode == 1:
                        print("按钮有效")
                        lenth =len(over_pos)
                        print("regret,computer1111")
                        if lenth > 1 and Current_Player == my:
                            print("regret,computer")
                            x1 = over_pos[lenth - 1][0]
                            y1 = over_pos[lenth - 1][1]
                            x2 = over_pos[lenth - 2][0]
                            y2 = over_pos[lenth - 2][1]
                            del over_pos[lenth-1]
                            del over_pos[lenth-2]
                            board[x1][y1]= ' '
                            board[x2][y2]= ' '
                            drawBoard()
                            pygame.display.update()
                        # time.sleep(0.5)
                    if gameMode == 2 :
                        print("regret>>>")
                        regret_flag = 1
                        message = "sure_f"+str(sure_flag) + "row" + str(send_row)+" col"+str(send_col) + "flash"+ str(flash_flag)+"reg"+str(regret_flag)
                            # time.sleep(0.5)
        screen.fill(background_color)
        drawBoard()
        drawBottomMenu(mouse)
        if row < 3 and col < 3:
            visualizeMove(row, col, previewImg)
        pygame.display.update()


def choose():
    player = None
    running = True
    while running:
        mouse = pygame.mouse.get_pos()
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if crossImg_rect.collidepoint((mouse[0], mouse[1])):
                    player = 'X'
                    running = False
                elif circleImg_rect.collidepoint((mouse[0], mouse[1])):
                    player = 'O'
                    running = False
        screen.blit(crossImg, (80, 300))
        screen.blit(circleImg, (340, 300))
        screen.blit(chooseImg, (8, 25))
        pygame.display.update()
    return player


def drawBoard():
    # 画棋子
    for row in range(3):
        for col in range(3):
            pos = (row * 200 + 12, col * 200 + 12)
            if board[row][col] == 'X':
                screen.blit(crossImg, pos)
            elif board[row][col] == 'O':
                screen.blit(circleImg, pos)
    # 画网格
    width = 10
    color = dark_grey
    pygame.draw.line(screen, color, (200, 0), (200, 600), width)
    pygame.draw.line(screen, color, (400, 0), (400, 600), width)
    pygame.draw.line(screen, color, (0, 200), (600, 200), width)
    pygame.draw.line(screen, color, (0, 400), (600, 400), width)
    # 画边框
    pygame.draw.rect(screen, color, (0, 0, 10, 600))
    pygame.draw.rect(screen, color, (0, 0, 600, 10))
    pygame.draw.rect(screen, color, (590, 0, 10, 600))


def drawBottomMenu(mouse):
    pygame.draw.rect(screen, dark_grey, (0, 600, 600, 100))
    pygame.draw.rect(screen, light_grey, (10, 610, 580, 80))
    screen.blit(restartImg, (550, 610))
    screen.blit(ReGretImg,(400,720))
    # Hover animation
    if 550 < mouse[0] < 582 and 610 < mouse[1] < 642:
        screen.blit(restartHoveredImg, (548, 608))
    screen.blit(X_score, (200, 610))
    screen.blit(O_score, (370, 610))
    scoreboard = font.render(': %d x %d :' % (score['X'], score['O']), True, background_color, light_grey)
    screen.blit(scoreboard, (244, 610))


def visualizeMove(row, col, previewImg):
    if board[row][col] == '':
        screen.blit(previewImg, (row * 200 + 12, col * 200 + 12))


def playerMove(player, row, col):
    board[row][col] = player
    over_pos.append((row,col))
def CounterMove(row, col):
    board[row][col] = "O"


def computerMove(player):
    global over_pos
    bestScore = float('inf')
    for row in range(3):
        for col in range(3):
            if board[row][col] == '':
                board[row][col] = 'O'
                score = minimax(board, 'X')
                board[row][col] = ''
                if score < bestScore:
                    bestScore = score
                    bestMove = (row, col)
    board[bestMove[0]][bestMove[1]] = player
    over_pos.append((bestMove[0],bestMove[1]))


scores = {'X': 1, 'O': -1, 'tie': 0}


def minimax(board, cur_player):
    if isWinner('X'):
        return scores['X']
    elif isWinner('O'):
        return scores['O']
    elif isBoardFull():
        return scores['tie']
    if cur_player == 'X':
        bestScore = float('-inf')
        nextPlayer = 'O'
        minORmax = max
    else:
        bestScore = float('inf')
        nextPlayer = 'X'
        minORmax = min
    for row in range(3):
        for col in range(3):
            if board[row][col] == '':
                board[row][col] = cur_player
                score = minimax(board, nextPlayer)
                board[row][col] = ''
                bestScore = minORmax(score, bestScore)
            if bestScore == scores[cur_player]:
                return bestScore
    return bestScore


def updatePlayer(player):
    if player == 'X':
        newPlayer = 'O'
        previewImg = previewCircleImg
    else:
        newPlayer = 'X'
        previewImg = previewCrossImg
    return newPlayer, previewImg



def isWinner(player):
    return ((board[0][0] == player and board[0][1] == player and board[0][2] == player) or
            (board[1][0] == player and board[1][1] == player and board[1][2] == player) or
            (board[2][0] == player and board[2][1] == player and board[2][2] == player) or
            (board[0][0] == player and board[1][0] == player and board[2][0] == player) or
            (board[0][1] == player and board[1][1] == player and board[2][1] == player) or
            (board[0][2] == player and board[1][2] == player and board[2][2] == player) or
            (board[0][0] == player and board[1][1] == player and board[2][2] == player) or
            (board[0][2] == player and board[1][1] == player and board[2][0] == player))


def verifyWinner(player):
    global Send_Flag, Receive_Flag, Current_Player,dataSocket,gameMode,previewImg
    if isWinner(player):
        # dataSocket.close()
        # dataSocket, addr = listenSocket.accept()
        print(player, "win")
        if gameMode == 2:
            print("I have turn current_player to X")
            Current_Player = 'X'  # X先下棋
            previewImg = previewCrossImg
            if player == 'O':
                toSend = 'Over'
                dataSocket.send(toSend.encode())
                print("send_meseage:",toSend)
                Send_Flag = 0
                Receive_Flag = 0  ##一开始不发送也不接受，主机

        score[player] += 1
        ctypes.windll.user32.MessageBoxW(0, player + ' 获胜！', '提示', 0)
        resetBoard()
        return True
    return False


def isBoardFull():
    for i in range(3):
        for j in range(3):
            if board[i][j] == '':
                return False
    return True


def resetBoard():
    for i in range(3):
        for j in range(3):
            board[i][j] = ''

def Common_Reset():##对方刷新引起的刷新
    global Send_Flag,Receive_Flag,gameMode,Current_Player,previewImg,dataSocket,over_pos
    resetBoard()
    over_pos = []
    score['X'] = 0
    score['O'] = 0
    previewImg = previewCrossImg
    Current_Player = 'X'


def resetGame():
    global Send_Flag,Receive_Flag,gameMode,Current_Player,previewImg,dataSocket,over_pos
    over_pos= []
    resetBoard()
    score['X'] = 0
    score['O'] = 0
    if gameMode == 2:
        Current_Player = 'X'
        print("I have turn the picture to Cross")
        previewImg = previewCrossImg


global i
i = 0

def handle(rec):
    global send_row, send_col, Send_Flag, row, col, Receive_Flag, i, Current_Player, previewImg, message,over_pos
    global pi_sure_flag, pi_row, pi_col, pr_flash,pi_row,pi_reg
    if rec:
        print("rec    in re",rec)
        re_sure_flag = int(pi_sure_flag.search(rec).group(1))
        re_row = int(pi_row.search(rec).group(1))
        re_col = int(pi_col.search(rec).group(1))
        re_flash = int(pi_flash.search(rec).group(1))
        re_reg = int(pi_reg.search(rec).group(1))
        if re_sure_flag == 1:
            counter_row = re_row
            counter_col = re_col
            board[counter_row][counter_col] = "O"
            over_pos.append((counter_row,counter_col))
            drawBoard()
            Current_Player = 'X'  ##收到对面信息后回到主场
            previewImg = previewCrossImg
            pygame.display.update()

        if re_flash:
            Common_Reset()
        if re_reg == 1:
            print("接收reg")
            lenth = len(over_pos)
            if lenth > 0:
                x = over_pos[lenth - 1][0]
                y = over_pos[lenth - 1][1]
                del over_pos[lenth - 1]
                if lenth == 1:
                    resetGame()
                elif board[x][y] == "X":
                    print("regret x")
                    Current_Player = "O"
                    previewImg = previewCircleImg
                    board[x][y] = " "
                    drawBoard()
                elif board[x][y] == "O":
                    print("regret o")
                    Current_Player = "X"
                    previewImg = previewCrossImg
                    board[x][y] = " "
                    drawBoard()
                pygame.display.update()
            # time.sleep(0.5)



def TCP_Server():
    global send_row, send_col, Send_Flag, row, col, Receive_Flag, i, current_player, previewImg, message,sure_flag,flash_flag,SOR,gameMode,Socket_init_Flag,dataSocket
    global pi_send_flag, pi_received_flag, pi_row, pi_col, pr_flash

    while True:
        if Socket_init_Flag == 1:
            print("进入TCP")
            if SOR == 0:
                time.sleep(0.3)
                print("Send_message", message)
                dataSocket.send(message.encode())
                sure_flag = 0
                flash_flag = 0
                regret_flag = 0
                message = "sure_f" + str(sure_flag) + "row" + str(send_row) + " col" + str(send_col) + "flash" + str(
                    flash_flag) + "reg" + str(regret_flag)
                print("waiting for receiving...........")
                # time.sleep(0.1)
                SOR = 1
            if SOR == 1:
                recved = dataSocket.recv(BUFLEN)
                rec = recved.decode()
                if not recved:
                    break
                if rec:
                    # re_SOR = pi_sr.search(rec)
                    # SOR = re_SOR.group(1)
                    handle(rec)
                    print("received", rec)
                    dataSocket.send(message.encode())
                    SOR = 0


server_thread = threading.Thread(target = TCP_Server )
server_thread.start()
menu()
dataSocket.close()
listenSocket.close()
```

### 修复悔棋bug

#### 服务端


```python
import pygame
import ctypes
# 导入socket 库
from socket import *
import threading
import time
import re
global pi_reg,pi_sure_flag,pi_row,pi_col,pi_flash,message,sure_flag,flash_flag,SOR, board,over_pos,regret_flag,Socket_init_Flag,dataSocket
Socket_init_Flag = 0
pi_sure_flag=re.compile(r'sure_f(\d)')
pi_row=re.compile(r'row(\d)')
pi_col=re.compile(r'col(\d)')
pi_flash=re.compile(r'flash(\d)')##刷新参数
pi_reg = re.compile(r'reg(\d)')
message= "sure_f0 row0 col0 flash0 SenOrRec0 reg0"
sure_flag = 0
flash_flag = 0
regret_flag = 0
over_pos= []
send_row = 0
send_col = 0
SOR = 0 #0是发送
# 主机地址为空字符串，表示绑定本机所有网络接口ip地址
# 等待客户端来连接
IP = '192.168.196.156'
# 端口号
PORT = 50000
# 定义一次从socket缓冲区最多读入512个字节数据
BUFLEN = 512

def Client_socket():
    global dataSocket,Socket_init_Flag
    # 实例化一个socket对象
    # 参数 AF_INET 表示该socket网络层使用IP协议
    # 参数 SOCK_STREAM 表示该socket传输层使用TCP协议
    listenSocket = socket(AF_INET, SOCK_STREAM)

    # socket绑定地址和端口
    listenSocket.bind((IP, PORT))

    # 使socket处于监听状态，等待客户端的连接请求
    # 参数 8 表示 最多接受多少个等待连接的客户端
    listenSocket.listen(8)
    print(f'服务端启动成功，在{PORT}端口等待客户端连接...')

    dataSocket, addr = listenSocket.accept()
    Socket_init_Flag = 1
    print('接受一个客户端连接:', addr)
global Send_Flag,Receive_Flag,Current_Player,If_over,previewImg,gameMode,Ini_FLag,Reset_Flag
# 初始化 pygame
pygame.init()

# 定义颜色
blue = (78, 140, 243)
light_blue = (100, 100, 255)
red = (242, 89, 97)
light_red = (255, 100, 100)
dark_grey = (85, 85, 85)
light_grey = (100, 100, 100)
background_color = (225, 225, 225)
Send_Flag = 0
Receive_Flag = 0##一开始不发送也不接受，主机
Current_Player = 'X'#X先下棋
If_over = 0
gameMode = 0
Ini_FLag = 1
# 创建窗口
screen = pygame.display.set_mode((600, 800))
pygame.display.set_caption('井字棋')

# 游戏图片
crossImg = pygame.image.load('Images/crossImg.png')
crossImg_rect = crossImg.get_rect()
crossImg_rect.center = (200, 300)
circleImg = pygame.image.load('Images/circleImg.png')
circleImg_rect = crossImg.get_rect()
circleImg_rect.center = (400, 300)
previewCrossImg = pygame.image.load('Images/prev_crossImg.png')
previewCircleImg = pygame.image.load('Images/prev_circleImg.png')

previewImg = previewCrossImg
# 按钮图片
restartImg = pygame.image.load('Images/restart.png')
restartHoveredImg = pygame.image.load('Images/restart_hovered.png')
ReGretImg = pygame.image.load('Images/button4Img.png')
# 定义棋盘
board = [['', '', ''],
         ['', '', ''],
         ['', '', '']]

# 定义计分板
score = {'X': 0, 'O': 0}
font = pygame.font.Font('freesansbold.ttf', 32)
X_score = pygame.image.load('Images/X_scoreImg.png')
O_score = pygame.image.load('Images/O_scoreImg.png')

# 菜单图片
buttom1 = pygame.image.load('Images/button1Img.png')
buttom1_rect = buttom1.get_rect()
buttom1_rect.center = (300, 312)
buttom2 = pygame.image.load('Images/button2Img.png')
buttom2_rect = buttom2.get_rect()
buttom2_rect.center = (300, 472)

buttom3 = pygame.image.load('Images/button3Img.png')
buttom3_rect = buttom3.get_rect()
buttom3_rect.center = (300, 632)

buttom4_rect = ReGretImg.get_rect()
buttom4_rect.center = (478, 751)

logo = pygame.image.load('Images/logo.png')

# 选择菜单图片
chooseImg = pygame.image.load('Images/choose.png')


def menu():
    global gameMode
    running = True
    while running:
        screen.fill(background_color)
        mx, my = pygame.mouse.get_pos()
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if buttom1_rect.collidepoint((mx, my)):
                    game(0, 'X')
                    gameMode = 0
                elif buttom2_rect.collidepoint((mx, my)):
                    player = choose()
                    if player is not None:
                        game(1, player)
                        gameMode =1
                elif buttom3_rect.collidepoint((mx, my)):
                    Client_socket()
                    gameMode = 2
                    game(2, 'X')
        screen.blit(logo, (8, 25))
        screen.blit(buttom1, (100, 250))
        screen.blit(buttom2, (100, 410))
        screen.blit(buttom3, (100, 570))
        pygame.display.update()


def game(gameMode, player):
    global send_row, send_col ,Send_Flag,row, col,Receive_Flag,Current_Player,If_over,previewImg,message,sure_flag,flash_flag,board,regret_flag
    my = player
    player = 'X'
    running = True
    if gameMode == 2:
        previewImg = previewCrossImg  # 服务端先下
    else:
        if player == 'X':
            previewImg = previewCrossImg
        else:
            previewImg = previewCircleImg
    while running:
        mouse = pygame.mouse.get_pos()
        row, col = int(mouse[0] / 200), int(mouse[1] / 200)
        for event in pygame.event.get():
            if verifyWinner('X'):
                print("确认X胜利")
                player = 'X'
                previewImg = previewCrossImg
            if verifyWinner('O'):
                print("确认O胜利")
                player = 'X'
                previewImg = previewCrossImg
            if event.type == pygame.QUIT:
                resetGame()
                running = False
            elif isBoardFull():
                ctypes.windll.user32.MessageBoxW(0, '平局', '提示', 0)
                resetBoard()
            elif gameMode == 1 and player != my:
                computerMove(player)
                drawBoard()
                pygame.display.update()
                # if verifyWinner(player):
                #     player = 'X'
                #     previewImg = previewCrossImg
                # else:
                #     player, previewImg = updatePlayer(player)
                if verifyWinner(player):
                    player = 'X'
                    previewImg = previewCrossImg
                else:
                    player, previewImg = updatePlayer(player)
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if gameMode != 2:
                    if row < 3 and col < 3 and board[row][col] == '':
                        # send_row = row
                        # send_col = col
                        playerMove(player, row, col)
                        drawBoard()
                        Send_Flag = 1
                        time.sleep(0.5)
                        if verifyWinner('X'):
                            player = 'X'
                            previewImg = previewCrossImg
                        else :
                            player, previewImg = updatePlayer(player)
                if gameMode == 2:
                    if row < 3 and col < 3 and board[row][col] == '':
                        print("Current_Player", Current_Player)
                    if row < 3 and col < 3 and board[row][col] == '' and Current_Player == 'X':#自己的回合鼠标才能点击
                        sure_flag = 1
                        send_row = row
                        send_col = col
                        regret_flag = 0
                        message = "sure_f"+str(sure_flag) + "row" + str(send_row)+" col"+str(send_col) + "flash"+ str(flash_flag)+"reg"+str(regret_flag)
                        time.sleep(0.3)
                        playerMove('X', row, col)
                        drawBoard()
                        Current_Player = 'O'#下完换对方
                        previewImg = previewCircleImg
                        print("I am going to Send message X")
                        time.sleep(0.5)
                        print("I am waiting for O message")
                    # else:
                    #         Receive_Flag = 1
                if 550 < mouse[0] < 582 and 610 < mouse[1] < 642:

                    flash_flag = 1
                    message = "sure_f" + str(sure_flag) + "row" + str(send_row) + " col" + str(
                        send_col) + "flash" + str(flash_flag) + "reg" + str(regret_flag)
                    resetGame()
                    player = "X"
                    previewImg =previewCrossImg
                if buttom4_rect.collidepoint((mouse[0], mouse[1])):
                    print("board",board)
                    if gameMode != 1 :
                        print("按钮有效")
                        lenth =len(over_pos)
                        if lenth > 0:
                            x = over_pos[lenth - 1][0]
                            y = over_pos[lenth - 1][1]
                            del over_pos[lenth-1]
                            if lenth == 1:
                                player = 'X'
                                previewImg = previewCrossImg
                                Current_Player = 'X'
                                resetGame()
                            elif board[x][y] == "X":
                                print("regret x")
                                Current_Player = "X"
                                player = "X"
                                previewImg = previewCrossImg
                                board[x][y] = ''
                                drawBoard()
                            elif board[x][y] == "O":
                                print("regret o")
                                Current_Player = "O"
                                player = "O"
                                previewImg = previewCircleImg
                                board[x][y] = ''
                                drawBoard()
                            pygame.display.update()
                        # time.sleep(0.5)
                    if gameMode == 1:
                        print("按钮有效")
                        lenth =len(over_pos)
                        print("regret,computer1111")
                        if lenth > 1 :
                            print("regret,computer")
                            print("board",board)
                            x1 = over_pos[lenth - 1][0]
                            y1 = over_pos[lenth - 1][1]
                            x2 = over_pos[lenth - 2][0]
                            y2 = over_pos[lenth - 2][1]
                            print("board[x1][y1]", board[x1][y1])
                            print("board[x2][y2] ", board[x2][y2] )
                            print("player",player)
                            del over_pos[lenth-1]
                            del over_pos[lenth-2]
                            board[x1][y1] = ''
                            board[x2][y2] = ''
                            drawBoard()
                            pygame.display.update()
                        # time.sleep(0.5)
                    if gameMode == 2 :
                        print("regret>>>")
                        regret_flag = 1
                        message = "sure_f"+str(sure_flag) + "row" + str(send_row)+" col"+str(send_col) + "flash"+ str(flash_flag)+"reg"+str(regret_flag)
                            # time.sleep(0.5)
        screen.fill(background_color)
        drawBoard()
        drawBottomMenu(mouse)
        if row < 3 and col < 3:
            visualizeMove(row, col, previewImg)
        pygame.display.update()


def choose():
    player = None
    running = True
    while running:
        mouse = pygame.mouse.get_pos()
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if crossImg_rect.collidepoint((mouse[0], mouse[1])):
                    player = 'X'
                    running = False
                elif circleImg_rect.collidepoint((mouse[0], mouse[1])):
                    player = 'O'
                    running = False
        screen.blit(crossImg, (80, 300))
        screen.blit(circleImg, (340, 300))
        screen.blit(chooseImg, (8, 25))
        pygame.display.update()
    return player


def drawBoard():
    # 画棋子
    for row in range(3):
        for col in range(3):
            pos = (row * 200 + 12, col * 200 + 12)
            if board[row][col] == 'X':
                screen.blit(crossImg, pos)
            elif board[row][col] == 'O':
                screen.blit(circleImg, pos)
    # 画网格
    width = 10
    color = dark_grey
    pygame.draw.line(screen, color, (200, 0), (200, 600), width)
    pygame.draw.line(screen, color, (400, 0), (400, 600), width)
    pygame.draw.line(screen, color, (0, 200), (600, 200), width)
    pygame.draw.line(screen, color, (0, 400), (600, 400), width)
    # 画边框
    pygame.draw.rect(screen, color, (0, 0, 10, 600))
    pygame.draw.rect(screen, color, (0, 0, 600, 10))
    pygame.draw.rect(screen, color, (590, 0, 10, 600))


def drawBottomMenu(mouse):
    pygame.draw.rect(screen, dark_grey, (0, 600, 600, 100))
    pygame.draw.rect(screen, light_grey, (10, 610, 580, 80))
    screen.blit(restartImg, (550, 610))
    screen.blit(ReGretImg,(400,720))
    # Hover animation
    if 550 < mouse[0] < 582 and 610 < mouse[1] < 642:
        screen.blit(restartHoveredImg, (548, 608))
    screen.blit(X_score, (200, 610))
    screen.blit(O_score, (370, 610))
    scoreboard = font.render(': %d x %d :' % (score['X'], score['O']), True, background_color, light_grey)
    screen.blit(scoreboard, (244, 610))


def visualizeMove(row, col, previewImg):
    if board[row][col] == '':
        screen.blit(previewImg, (row * 200 + 12, col * 200 + 12))


def playerMove(player, row, col):
    board[row][col] = player
    over_pos.append((row,col))
def CounterMove(row, col):
    board[row][col] = "O"


def computerMove(player):
    global over_pos
    bestScore = float('inf')
    for row in range(3):
        for col in range(3):
            if board[row][col] == '':
                board[row][col] = 'O'
                score = minimax(board, 'X')
                board[row][col] = ''
                if score < bestScore:
                    bestScore = score
                    bestMove = (row, col)
    board[bestMove[0]][bestMove[1]] = player
    over_pos.append((bestMove[0],bestMove[1]))


scores = {'X': 1, 'O': -1, 'tie': 0}


def minimax(board, cur_player):
    if isWinner('X'):
        return scores['X']
    elif isWinner('O'):
        return scores['O']
    elif isBoardFull():
        return scores['tie']
    if cur_player == 'X':
        bestScore = float('-inf')
        nextPlayer = 'O'
        minORmax = max
    else:
        bestScore = float('inf')
        nextPlayer = 'X'
        minORmax = min
    for row in range(3):
        for col in range(3):
            if board[row][col] == '':
                board[row][col] = cur_player
                score = minimax(board, nextPlayer)
                board[row][col] = ''
                bestScore = minORmax(score, bestScore)
            if bestScore == scores[cur_player]:
                return bestScore
    return bestScore


def updatePlayer(player):
    if player == 'X':
        newPlayer = 'O'
        previewImg = previewCircleImg
    else:
        newPlayer = 'X'
        previewImg = previewCrossImg
    return newPlayer, previewImg



def isWinner(player):
    return ((board[0][0] == player and board[0][1] == player and board[0][2] == player) or
            (board[1][0] == player and board[1][1] == player and board[1][2] == player) or
            (board[2][0] == player and board[2][1] == player and board[2][2] == player) or
            (board[0][0] == player and board[1][0] == player and board[2][0] == player) or
            (board[0][1] == player and board[1][1] == player and board[2][1] == player) or
            (board[0][2] == player and board[1][2] == player and board[2][2] == player) or
            (board[0][0] == player and board[1][1] == player and board[2][2] == player) or
            (board[0][2] == player and board[1][1] == player and board[2][0] == player))


def verifyWinner(player):
    global Send_Flag, Receive_Flag, Current_Player,dataSocket,gameMode,previewImg
    if isWinner(player):
        # dataSocket.close()
        # dataSocket, addr = listenSocket.accept()
        print(player, "win")
        if gameMode == 2:
            print("I have turn current_player to X")
            Current_Player = 'X'  # X先下棋
            previewImg = previewCrossImg
            if player == 'O':
                toSend = 'Over'
                dataSocket.send(toSend.encode())
                print("send_meseage:",toSend)
                Send_Flag = 0
                Receive_Flag = 0  ##一开始不发送也不接受，主机

        score[player] += 1
        ctypes.windll.user32.MessageBoxW(0, player + ' 获胜！', '提示', 0)
        resetBoard()
        return True
    return False


def isBoardFull():
    for i in range(3):
        for j in range(3):
            if board[i][j] == '':
                return False
    return True


def resetBoard():
    for i in range(3):
        for j in range(3):
            board[i][j] = ''

def Common_Reset():##对方刷新引起的刷新
    global Send_Flag,Receive_Flag,gameMode,Current_Player,previewImg,dataSocket,over_pos
    resetBoard()
    over_pos = []
    score['X'] = 0
    score['O'] = 0
    previewImg = previewCrossImg
    Current_Player = 'X'


def resetGame():
    global Send_Flag,Receive_Flag,gameMode,Current_Player,previewImg,dataSocket,over_pos
    over_pos= []
    resetBoard()
    score['X'] = 0
    score['O'] = 0
    if gameMode == 2:
        Current_Player = 'X'
        print("I have turn the picture to Cross")
        previewImg = previewCrossImg


global i
i = 0

def handle(rec):
    global send_row, send_col, Send_Flag, row, col, Receive_Flag, i, Current_Player, previewImg, message,over_pos
    global pi_sure_flag, pi_row, pi_col, pr_flash,pi_row,pi_reg
    if rec:
        print("rec    in re",rec)
        re_sure_flag = int(pi_sure_flag.search(rec).group(1))
        re_row = int(pi_row.search(rec).group(1))
        re_col = int(pi_col.search(rec).group(1))
        re_flash = int(pi_flash.search(rec).group(1))
        re_reg = int(pi_reg.search(rec).group(1))
        if re_sure_flag == 1:
            counter_row = re_row
            counter_col = re_col
            board[counter_row][counter_col] = "O"
            over_pos.append((counter_row,counter_col))
            drawBoard()
            Current_Player = 'X'  ##收到对面信息后回到主场
            previewImg = previewCrossImg
            pygame.display.update()

        if re_flash:
            Common_Reset()
        if re_reg == 1:
            print("接收reg")
            lenth = len(over_pos)
            if lenth > 0:
                x = over_pos[lenth - 1][0]
                y = over_pos[lenth - 1][1]
                del over_pos[lenth - 1]
                if lenth == 1:
                    resetGame()
                elif board[x][y] == "X":
                    print("regret x")
                    Current_Player = "X"
                    previewImg = previewCrossImg
                    board[x][y] = ''
                    drawBoard()
                elif board[x][y] == "O":
                    print("regret o")
                    Current_Player = "O"
                    previewImg = previewCircleImg
                    board[x][y] = ''
                    drawBoard()
                pygame.display.update()
            # time.sleep(0.5)



def TCP_Server():
    global send_row, send_col, Send_Flag, row, col, Receive_Flag, i, current_player, previewImg, message,sure_flag,flash_flag,SOR,gameMode,Socket_init_Flag,dataSocket
    global pi_send_flag, pi_received_flag, pi_row, pi_col, pr_flash

    while True:
        if Socket_init_Flag == 1:
            print("进入TCP")
            if SOR == 0:
                time.sleep(0.3)
                print("Send_message", message)
                dataSocket.send(message.encode())
                sure_flag = 0
                flash_flag = 0
                regret_flag = 0
                message = "sure_f" + str(sure_flag) + "row" + str(send_row) + " col" + str(send_col) + "flash" + str(
                    flash_flag) + "reg" + str(regret_flag)
                print("waiting for receiving...........")
                # time.sleep(0.1)
                SOR = 1
            if SOR == 1:
                recved = dataSocket.recv(BUFLEN)
                rec = recved.decode()
                if not recved:
                    break
                if rec:
                    # re_SOR = pi_sr.search(rec)
                    # SOR = re_SOR.group(1)
                    handle(rec)
                    print("received", rec)
                    dataSocket.send(message.encode())
                    SOR = 0


server_thread = threading.Thread(target = TCP_Server )
server_thread.start()
menu()
dataSocket.close()
listenSocket.close()
```

#### 客户端

```python
import pygame
import ctypes
#  === TCP 客户端程序 client.py ===
import time
from socket import *
import threading
import re

global pi_reg,pi_sure_flag,pi_row,pi_col,pi_flash,message,SOR,sure_flag,flash_flag,over_pos,regret_flag,over_flag

pi_sure_flag=re.compile(r'sure_f(\d)')
pi_row=re.compile(r'row(\d)')
pi_col=re.compile(r'col(\d)')
pi_flash=re.compile(r'flash(\d)')##刷新参数
pi_reg = re.compile(r'reg(\d)')
message= "sure_f0 row0 col0 flash0 SenOrRec0 reg0"
SOR = 1
sure_flag = 0
flash_flag = 0
regret_flag = 0
over_pos= []
# IP = '127.0.0.1'
IP ='192.168.196.156'
SERVER_PORT = 50000
BUFLEN = 1024

# 实例化一个socket对象，指明协议
dataSocket = socket(AF_INET, SOCK_STREAM)
global Send_Flag,Receive_Flag,current_player,previewImg,gameMode
Send_Flag = 0
Receive_Flag = 1
current_player = 'X'#服务端先下
gameMode = 0
send_row = 0
send_col = 0
# 连接服务端socket
dataSocket.connect((IP, SERVER_PORT))
# 初始化 pygame
pygame.init()

# 定义颜色
blue = (78, 140, 243)
light_blue = (100, 100, 255)
red = (242, 89, 97)
light_red = (255, 100, 100)
dark_grey = (85, 85, 85)
light_grey = (100, 100, 100)
background_color = (225, 225, 225)

# 创建窗口
screen = pygame.display.set_mode((600, 800))
pygame.display.set_caption('井字棋-客户端')

# 游戏图片
crossImg = pygame.image.load('Images/crossImg.png')
crossImg_rect = crossImg.get_rect()
crossImg_rect.center = (200, 300)
circleImg = pygame.image.load('Images/circleImg.png')
circleImg_rect = crossImg.get_rect()
circleImg_rect.center = (400, 300)
previewCrossImg = pygame.image.load('Images/prev_crossImg.png')
previewCircleImg = pygame.image.load('Images/prev_circleImg.png')
previewImg = previewCrossImg
# 按钮图片
restartImg = pygame.image.load('Images/restart.png')
restartHoveredImg = pygame.image.load('Images/restart_hovered.png')
ReGretImg = pygame.image.load('Images/button4Img.png')

# 定义棋盘
board = [['', '', ''],
         ['', '', ''],
         ['', '', '']]

# 定义计分板
score = {'X': 0, 'O': 0}
font = pygame.font.Font('freesansbold.ttf', 32)
X_score = pygame.image.load('Images/X_scoreImg.png')
O_score = pygame.image.load('Images/O_scoreImg.png')

# 菜单图片
buttom1 = pygame.image.load('Images/button1Img.png')
buttom1_rect = buttom1.get_rect()
buttom1_rect.center = (300, 312)
buttom2 = pygame.image.load('Images/button2Img.png')
buttom2_rect = buttom2.get_rect()
buttom2_rect.center = (300, 472)
buttom3 = pygame.image.load('Images/button3Img.png')
buttom3_rect = buttom3.get_rect()
buttom3_rect.center = (300, 632)
buttom4_rect = ReGretImg.get_rect()
buttom4_rect.center = (478, 751)
logo = pygame.image.load('Images/logo.png')

# 选择菜单图片
chooseImg = pygame.image.load('Images/choose.png')


def menu():
    global gameMode
    running = True
    while running:
        screen.fill(background_color)
        mx, my = pygame.mouse.get_pos()
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if buttom1_rect.collidepoint((mx, my)):
                    gameMode= 0
                    game(0, 'X')
                elif buttom2_rect.collidepoint((mx, my)):
                    player = choose()
                    if player is not None:
                        gameMode= 1
                        game(1, player)
                elif buttom3_rect.collidepoint((mx, my)):
                    gameMode = 2
                    game(2, 'O')
        screen.blit(logo, (8, 25))
        screen.blit(buttom1, (100, 250))
        screen.blit(buttom2, (100, 410))
        screen.blit(buttom3, (100, 570))
        pygame.display.update()


def game(gameMode, player):
    global send_row, send_col, Send_Flag, Receive_Flag,row, col,current_player,previewImg,message,sure_flag,flash_flag,over,regret_flag
    my = player
    player = "X"
    running = True
    if gameMode == 2:
        previewImg = previewCrossImg  # 服务端先下
    else:
        if player == 'X':
            previewImg = previewCrossImg
        else:
            previewImg = previewCircleImg
    while running:
        mouse = pygame.mouse.get_pos()
        row, col = int(mouse[0] / 200), int(mouse[1] / 200)
        for event in pygame.event.get():
            if verifyWinner('O'):
                player = 'X'
                previewImg = previewCircleImg

            if verifyWinner('X'):
                player = 'X'
                previewImg = previewCrossImg

            if event.type == pygame.QUIT:
                resetGame()
                running = False
            elif isBoardFull():
                ctypes.windll.user32.MessageBoxW(0, '平局', '提示', 0)
                resetBoard()
            elif gameMode == 1 and player != my:
                computerMove(player)
                drawBoard()
                pygame.display.update()
                if verifyWinner(player):
                    player = 'X'
                    previewImg = previewCrossImg
                else:
                    player, previewImg = updatePlayer(player)
            # elif gameMode == 2 and player != my:
            #     CounterMove(player)
            #     drawBoard()
            #     pygame.display.update()
            #     if verifyWinner(player):
            #         player = 'O'
            #         previewImg = previewCrossImg
            #     else:
            #         player, previewImg = updatePlayer(player)
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if gameMode != 2:
                    if row < 3 and col < 3 and board[row][col] == '':
                        send_row = row
                        send_col = col
                        playerMove(player, row, col)
                        drawBoard()
                        # Send_Flag = 1
                        # time.sleep(0.5)
                        if verifyWinner('O'):
                            player = 'X'
                            previewImg = previewCrossImg
                        else :
                            player, previewImg = updatePlayer(player)
                    #
                    #     else:
                    #         Receive_Flag = 1
                    # elif 550 < mouse[0] < 582 and 610 < mouse[1] < 642:
                    #     resetGame()
                if gameMode == 2:
                    if row < 3 and col < 3 and board[row][col] == '':
                        print("Current_Player", current_player)
                    if row < 3 and col < 3 and board[row][col] == '' and current_player == 'O':#自己的回合鼠标才能点击
                        send_row = row
                        send_col = col
                        sure_flag =1
                        message = "sure_f" + str(sure_flag) + "row" + str(send_row) + " col" + str(
                            send_col) + "flash" + str(
                            flash_flag) + "reg" + str(regret_flag)
                        playerMove('O', row, col)
                        drawBoard()
                        current_player = 'X'#下完换对方
                        previewImg = previewCrossImg
                        regret_flag = 0
                        Send_Flag = 1
                        Receive_Flag = 1
                        print("I am going to send O message")
                        # time.sleep(0.5)
                        print("I am wating for message")
                        # if verifyWinner(player):
                        #     player = 'O'
                        #     previewImg = previewCrossImg
                        # elif gameMode != 2:
                        #
                    # else:
                    #         Receive_Flag = 1
                if 550 < mouse[0] < 582 and 610 < mouse[1] < 642:
                    flash_flag = 1
                    message = "sure_f" + str(sure_flag) + "row" + str(send_row) + " col" + str(
                        send_col) + "flash" + str(flash_flag) + "reg" + str(regret_flag)
                    resetGame()
                if buttom4_rect.collidepoint((mouse[0], mouse[1])):
                    if gameMode != 1:
                        print("悔棋一次")
                        lenth =len(over_pos)
                        if lenth > 0:
                            x = over_pos[lenth - 1][0]
                            y = over_pos[lenth - 1][1]
                            del over_pos[lenth-1]
                            if lenth == 1:
                                resetGame()
                                player = 'X'
                                current_player = 'X'
                                previewImg = previewCrossImg
                            elif board[x][y] == "X":
                                print("regret x")
                                player = "X"
                                current_player = "X"
                                previewImg = previewCrossImg
                                board[x][y] = ''
                                drawBoard()
                            elif board[x][y] == "O":
                                print("regret o")
                                player = "O"
                                current_player = "O"
                                previewImg = previewCircleImg
                                board[x][y] = ''
                                drawBoard()
                            pygame.display.update()
                    if gameMode == 1:
                        print("按钮有效")
                        lenth =len(over_pos)
                        print("regret,computer1111")
                        if lenth > 1 and current_player == my:
                            print("regret,computer")
                            x1 = over_pos[lenth - 1][0]
                            y1 = over_pos[lenth - 1][1]
                            x2 = over_pos[lenth - 2][0]
                            y2 = over_pos[lenth - 2][1]
                            del over_pos[lenth-1]
                            del over_pos[lenth-2]
                            board[x1][y1]= ''
                            board[x2][y2]= ''
                            drawBoard()
                            pygame.display.update()
                    if gameMode == 2 :
                        print("regret.....in  ..here")
                        regret_flag = 1
                        message = "sure_f"+str(sure_flag) + "row" + str(send_row)+" col"+str(send_col) + "flash"+ str(flash_flag)+"reg"+str(regret_flag)
        screen.fill(background_color)
        drawBoard()
        drawBottomMenu(mouse)
        if row < 3 and col < 3:
            visualizeMove(row, col, previewImg)
        pygame.display.update()


def choose():
    player = None
    running = True
    while running:
        mouse = pygame.mouse.get_pos()
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if crossImg_rect.collidepoint((mouse[0], mouse[1])):
                    player = 'X'
                    running = False
                elif circleImg_rect.collidepoint((mouse[0], mouse[1])):
                    player = 'O'
                    running = False
        screen.blit(crossImg, (80, 300))
        screen.blit(circleImg, (340, 300))
        screen.blit(chooseImg, (8, 25))
        pygame.display.update()
    return player


def drawBoard():
    # 画棋子
    for row in range(3):
        for col in range(3):
            pos = (row * 200 + 12, col * 200 + 12)
            if board[row][col] == 'X':
                screen.blit(crossImg, pos)
            elif board[row][col] == 'O':
                screen.blit(circleImg, pos)
    # 画网格
    width = 10
    color = dark_grey
    pygame.draw.line(screen, color, (200, 0), (200, 600), width)
    pygame.draw.line(screen, color, (400, 0), (400, 600), width)
    pygame.draw.line(screen, color, (0, 200), (600, 200), width)
    pygame.draw.line(screen, color, (0, 400), (600, 400), width)
    # 画边框
    pygame.draw.rect(screen, color, (0, 0, 10, 600))
    pygame.draw.rect(screen, color, (0, 0, 600, 10))
    pygame.draw.rect(screen, color, (590, 0, 10, 600))


def drawBottomMenu(mouse):
    pygame.draw.rect(screen, dark_grey, (0, 600, 600, 100))
    pygame.draw.rect(screen, light_grey, (10, 610, 580, 80))
    screen.blit(restartImg, (550, 610))
    screen.blit(ReGretImg,(400,720))
    # Hover animation
    if 550 < mouse[0] < 582 and 610 < mouse[1] < 642:
        screen.blit(restartHoveredImg, (548, 608))
    screen.blit(X_score, (200, 610))
    screen.blit(O_score, (370, 610))
    scoreboard = font.render(': %d x %d :' % (score['X'], score['O']), True, background_color, light_grey)
    screen.blit(scoreboard, (244, 610))


def visualizeMove(row, col, previewImg):
    if board[row][col] == '':
        screen.blit(previewImg, (row * 200 + 12, col * 200 + 12))


def playerMove(player, row, col):
    board[row][col] = player
    over_pos.append((row,col))

def computerMove(player):
    global  over_pos
    bestScore = float('inf')
    for row in range(3):
        for col in range(3):
            if board[row][col] == '':
                board[row][col] = 'O'
                score = minimax(board, 'X')
                board[row][col] = ''
                if score < bestScore:
                    bestScore = score
                    bestMove = (row, col)
    board[bestMove[0]][bestMove[1]] = player
    over_pos.append((bestMove[0],bestMove[1]))

scores = {'X': 1, 'O': -1, 'tie': 0}


def minimax(board, cur_player):
    if isWinner('X'):
        return scores['X']
    elif isWinner('O'):
        return scores['O']
    elif isBoardFull():
        return scores['tie']
    if cur_player == 'X':
        bestScore = float('-inf')
        nextPlayer = 'O'
        minORmax = max
    else:
        bestScore = float('inf')
        nextPlayer = 'X'
        minORmax = min
    for row in range(3):
        for col in range(3):
            if board[row][col] == '':
                board[row][col] = cur_player
                score = minimax(board, nextPlayer)
                board[row][col] = ''
                bestScore = minORmax(score, bestScore)
            if bestScore == scores[cur_player]:
                return bestScore
    return bestScore


def updatePlayer(player):
    if player == 'X':
        newPlayer = 'O'
        previewImg = previewCircleImg
    else:
        newPlayer = 'X'
        previewImg = previewCrossImg
    return newPlayer, previewImg



def isWinner(player):
    return ((board[0][0] == player and board[0][1] == player and board[0][2] == player) or
            (board[1][0] == player and board[1][1] == player and board[1][2] == player) or
            (board[2][0] == player and board[2][1] == player and board[2][2] == player) or
            (board[0][0] == player and board[1][0] == player and board[2][0] == player) or
            (board[0][1] == player and board[1][1] == player and board[2][1] == player) or
            (board[0][2] == player and board[1][2] == player and board[2][2] == player) or
            (board[0][0] == player and board[1][1] == player and board[2][2] == player) or
            (board[0][2] == player and board[1][1] == player and board[2][0] == player))


def verifyWinner(player):
    global  Send_Flag,Receive_Flag,current_player,dataSocket,previewImg,gameMode,SOR
    if isWinner(player):
        print(player, "win")
        if gameMode ==2:
            previewImg = previewCrossImg
            current_player = 'X'  # 服务端先下
            SOR = 0
            # if player == 'X':
                # toSend = 'Over'
                # dataSocket.send(toSend.encode())
                # print("send_meseage:", toSend)
                # Send_Flag = 0
                # Receive_Flag = 1
        score[player] += 1
        ctypes.windll.user32.MessageBoxW(0, player + ' 获胜！', '提示', 0)
        resetBoard()
        return True
    return False


def isBoardFull():
    for i in range(3):
        for j in range(3):
            if board[i][j] == '':
                return False
    return True


def resetBoard():
    for i in range(3):
        for j in range(3):
            board[i][j] = ''

def Common_Reset():##对方刷新引起的刷新，被动刷新
    global Send_Flag,Receive_Flag,gameMode,current_player,previewImg,dataSocket
    resetBoard()
    score['X'] = 0
    score['O'] = 0
    if gameMode == 2:
        current_player = 'X'
        print("I have turn the picture to Cross")
        previewImg = previewCrossImg
def resetGame():##主动刷新
    global Send_Flag, Receive_Flag, gameMode, current_player, previewImg, dataSocket,over_pos
    resetBoard()
    over_pos= []
    score['X'] = 0
    score['O'] = 0
    if gameMode == 2:
        current_player = 'X'
        print("I have turn the picture to Cross")
        previewImg = previewCrossImg

    resetBoard()
    score['X'] = 0
    score['O'] = 0
global i
i = 0
def handle(rec):
    global send_row, send_col ,Send_Flag,row, col,Receive_Flag, i, current_player, previewImg,message,over_pos
    global pi_sure_flag, pi_row, pi_col, pr_flash
    if rec:
        re_sure_flag = int(pi_sure_flag.search(rec).group(1))
        re_row = int(pi_row.search(rec).group(1))
        re_col = int(pi_col.search(rec).group(1))
        re_flash = int(pi_flash.search(rec).group(1))
        re_reg = int(pi_reg.search(rec).group(1))
        if re_sure_flag == 1:
            counter_row = re_row
            counter_col = re_col
            board[counter_row][counter_col] = "X"
            over_pos.append((counter_row,counter_col))
            drawBoard()
            current_player = 'O'  ##收到对面信息后回到主场
            previewImg = previewCircleImg
            pygame.display.update()
        if re_flash ==1 :
            Common_Reset()
        if re_reg == 1:
            print("悔棋一次")
            lenth = len(over_pos)
            if lenth > 0:
                x = over_pos[lenth - 1][0]
                y = over_pos[lenth - 1][1]
                del over_pos[lenth - 1]
                if lenth == 1:
                    resetGame()
                elif board[x][y] == "X":
                    print("regret x")
                    current_player = "X"
                    previewImg = previewCrossImg
                    board[x][y] = ''
                    drawBoard()
                elif board[x][y] == "O":
                    print("regret o")
                    current_player = "O"
                    previewImg = previewCircleImg
                    board[x][y] = ''
                    drawBoard()
                pygame.display.update()



def TCP_Client():
    global send_row, send_col ,Send_Flag,row, col,Receive_Flag, i, current_player, previewImg,message,SOR,sure_flag,flash_flag,regret_flag
    global pi_send_flag, pi_received_flag, pi_row, pi_col, pr_flash
    pi_sr = re.compile(r'SenOrRec(\d)')
    while True:
        if SOR == 1:
            print("waiting for receiving...........")
            recved = dataSocket.recv(BUFLEN)
            rec = recved.decode()
            if not recved:
                break
            if rec:
                handle(rec)
                print("received", rec)
                dataSocket.send(message.encode())
                SOR = 0
        # time.sleep(0.3)
        if SOR == 0:
            print("sending",message)
            dataSocket.send(message.encode())
            sure_flag = 0
            flash_flag = 0
            regret_flag = 0
            message = "sure_f" + str(sure_flag) + "row" + str(send_row) + " col" + str(send_col) + "flash" + str(
                flash_flag) + "reg" + str(regret_flag)
            # time.sleep(0.1)
            SOR = 1


client_thread = threading.Thread(target=TCP_Client)
client_thread.start()

menu()
dataSocket.close()
```
## TCP连接基本没问题
### 服务端
```python

import pygame, sys, random,time
from pygame.locals import *
import numpy as np
from socket import *
import threading
import time
import re


global SOR,Socket_init_Flag,message,sure_f, row ,col
IP = '192.168.2.95'
PORT = 50000
BUFLEN = 1024
Socket_init_Flag = 0
SOR = 0 #0是
sure_f = 0
message = "sure_f0 row0 col0 T0"
row = 0
col =1

BACKGROUNDCOLOR = (255, 255, 255)
BLACK = (255, 255, 255)
BLUE = (0, 0, 255)
CELLWIDTH = 40
CELLHEIGHT = 40
PIECEWIDTH = 47
PIECEHEIGHT = 47
BOARDX = 2
BOARDY = 2
FPS = 40
INF_VALUE = 1000000
iteration_depth = 5
HASHMAP_SIZE = 8
windowSurface2 = pygame.display.set_mode((320, 420))
# 菜单图片
background = pygame.image.load('background.png')
background = pygame.transform.smoothscale(background,(320,420))
logo = pygame.image.load('logo.png')
logo =pygame.transform.smoothscale(logo,(160,80))

buttom1 = pygame.image.load('button1.png')
buttom1 = pygame.transform.smoothscale(buttom1,(160,80))
buttom1_rect = buttom1.get_rect()
buttom1_rect.center = (80, 140)
buttom2 = pygame.image.load('button2.png')
buttom2 = pygame.transform.smoothscale(buttom2,(160,80))
buttom2_rect = buttom2.get_rect()
buttom2_rect.center = (80, 240)

buttom3 = pygame.image.load('button3.png')
buttom3 = pygame.transform.smoothscale(buttom3,(160,80))
buttom3_rect = buttom3.get_rect()
buttom3_rect.center = (80, 340)

def Client_socket():
    global dataSocket,Socket_init_Flag,dataSocket
    # 实例化一个socket对象
    # 参数 AF_INET 表示该socket网络层使用IP协议
    # 参数 SOCK_STREAM 表示该socket传输层使用TCP协议
    listenSocket = socket(AF_INET, SOCK_STREAM)

    # socket绑定地址和端口
    listenSocket.bind((IP, PORT))

    # 使socket处于监听状态，等待客户端的连接请求
    # 参数 8 表示 最多接受多少个等待连接的客户端
    listenSocket.listen(8)
    print(f'服务端启动成功，在{PORT}端口等待客户端连接...')

    dataSocket, addr = listenSocket.accept()
    Socket_init_Flag = 1
    print('接受一个客户端连接:', addr)

def getNewZobrist():
    board = []
    for i in range(8):
        board.append([random.randint(0,2**HASHMAP_SIZE - 1) for i in range(8)])
    return board

def get_hashcode(hashcode,board,tile):
    for i in range(8):
        for j in range(8):
            if board[i][j] == 'black':
                hashcode ^= zobrist_black[i][j]
            elif board[i][j] == 'white':
                hashcode ^= zobrist_white[i][j]

    if tile == 'white':
        hashcode ^= zobrist_swap_player[0]
    else:
        hashcode ^= zobrist_swap_player[1]
    return hashcode
class Hashtable_Node:
    lower = -INF_VALUE
    upper = INF_VALUE
    bestmove = [0,0]
    depth = 0
class Hashtable:
    lock = 0
    deepest = Hashtable_Node()
    newest = Hashtable_Node()

hashmap = {}

zobrist_white = getNewZobrist()
zobrist_black = getNewZobrist()
zobrist_swap_player = [random.randint(0, 2 ** HASHMAP_SIZE - 1), random.randint(0, 2 ** HASHMAP_SIZE - 1)]


def hash_update(hashcode,lower,upper,bestmove,depth):
    p = hashmap.get(hashcode)
    if depth == p.deepest.depth :
        if lower > p.deepest.lower:
            p.deepest.lower = lower
            p.deepest.bestmove = bestmove
        if upper < p.deepest.upper:
            p.deepest.upper = upper
    elif depth == p.newest.depth:
        if lower > p.newest.lower:
            p.newest.lower = lower
            p.newest.bestmove = bestmove
        if upper < p.newest.upper:
            p.newest.upper = upper
    elif depth > p.deepest.depth:
        p.newest.lower = p.deepest.lower
        p.newest.upper = p.deepest.upper
        p.newest.bestmove = p.deepest.bestmove
        p.newest.depth = p.deepest.depth

        p.deepest.lower = lower
        p.deepest.upper = upper
        p.deepest.bestmove = bestmove
        p.deepest.depth = depth

def hash_get(p,depth):
    if depth == p.deepest.depth:
        return p.deepest
    elif depth == p.newest.depth:
        return p.newest
    else:
        return None

def alpha_beta_with_hashtable(board,computerTile,playerTile,flag,alpha,beta,depth):
    if flag is True:
        Tile = computerTile
    else:
        Tile = playerTile
    hashcode = 0
    hashcode = get_hashcode(hashcode,board,Tile)
    bestmove = []
    p = hashmap.get(hashcode)

    if p is not None :
        global find_number
        find_number += 1
        # print('find number is %d***********'%find_number)
        node = hash_get(p, current_depth + iteration_depth - depth)
        if node is not None:
            if node.lower > alpha:
                alpha = node.lower
                if alpha >= beta:
                    return alpha
            if node.upper < beta:
                beta = node.upper
                if beta <= alpha:
                    return beta
    else:
        global non_find_number
        non_find_number += 1
        # print('not find number is %d$$$$$$$$' % non_find_number)
        newTable = Hashtable()
        newTable.lock = hashcode
        hashmap[hashcode] = newTable
        # print('hash map size is %d??????????' %len(hashmap))

    temp = alpha_beta(board,computerTile,playerTile,flag,alpha,beta,depth)
    if isinstance(temp,float) or isinstance(temp,int):
        best_value = temp
    else:
        best_value = temp[0]
        bestmove = temp[1]
    if best_value >= beta:
        hash_update(hashcode, best_value, INF_VALUE, bestmove, current_depth + iteration_depth - depth)
    elif best_value <= alpha:
        hash_update(hashcode, -INF_VALUE, best_value, bestmove, current_depth + iteration_depth - depth)
    else:
        hash_update(hashcode, best_value, best_value, bestmove, current_depth + iteration_depth - depth)
    return best_value
# alpha_beta减枝算法
#传进来如果flag是True 那么就是computer下
#传进来flag为false 那么就是player下
def alpha_beta(board,computerTile,playerTile,flag,alpha,beta,depth):
    bestValue = -INF_VALUE
    bestMove = []
    if flag is True:
        Tile = computerTile
    else:
        Tile = playerTile
    possible = getValidMoves(board,Tile)
    for x,y in possible:
        copyBoard = getBoardCopy(board)
        makeMove(copyBoard,Tile,x,y)
        if depth <= 1:
            Value = getEvaluationOfBoard(copyBoard)[Tile]
        else:
            temp = alpha_beta(copyBoard,computerTile,playerTile,not flag,-beta,-alpha,depth-1)
            if isinstance(temp,float) or isinstance(temp,int):
                Value = -temp
            else:
                Value = -temp[0]
        if Value >= beta:
            return Value
        if Value > bestValue:
            bestValue = Value
            bestMove = [x,y]
            if Value > alpha:
                alpha = Value

    return bestValue,bestMove
def mtd(board,computerTile,playerTile,flag,alpha,beta,test,depth):
    bestValue = -INF_VALUE
    while alpha < beta:
        temp = alpha_beta(board,computerTile,playerTile,flag,test-1,test,depth)
        if isinstance(temp, float):
            bestValue = temp
        else:
            bestValue = temp[0]
    if bestValue < test:
        beta = bestValue
        test = bestValue
    else:
        alpha = bestValue
        test = bestValue + 1
    return bestValue
def pvs(board,computerTile,playerTile,flag,alpha,beta,depth):
    bestValue = -INF_VALUE
    if flag is True:
        Tile = computerTile
    else:
        Tile = playerTile
    possible = getValidMoves(board,Tile)
    for x,y in possible:
        copyBoard = getBoardCopy(board)
        makeMove(copyBoard,Tile,x,y)
        if depth <= 1:
            Value = getEvaluationOfBoard(copyBoard)[Tile]
        elif bestValue == -INF_VALUE:
            Value = -pvs(copyBoard,computerTile,playerTile,not flag,-beta,-alpha,depth-1)
        else:
            Value = -pvs(copyBoard,computerTile,playerTile,not flag,-alpha-1,-alpha,depth-1)
            if Value >alpha and Value < beta:
                alpha = Value
                Value = -pvs(copyBoard, computerTile, playerTile, not flag, -beta, -alpha, depth - 1)
        if Value >= beta:
            return Value
        if Value > bestValue:
            bestValue = Value
            if Value > alpha:
                alpha = Value
    return bestValue
# 退出
def terminate():
    pygame.quit()
    sys.exit()

# 初始化棋盘

def resetBoard(board):
    for x in range(8):
        for y in range(8):
            board[x][y] = 'none'
    #初始布局:
    board[3][3] = 'black'
    board[3][4] = 'white'
    board[4][3] = 'white'
    board[4][4] = 'black'

# 开局时建立新棋盘
def getNewBoard():
    board = []
    for i in range(8):
        board.append(['none'] * 8)
    return board

# 是否是合法走法，返回false或者此走法能够被翻转的棋子位置
def isValidMove(board, tile, xstart, ystart):
    # 如果该位置已经有棋子或者出界了，返回False
    if not isOnBoard(xstart, ystart) or board[xstart][ystart] != 'none':
        return False
    # 临时将tile 放到指定的位置
    board[xstart][ystart] = tile
    if tile == 'black':
        otherTile = 'white'
    else:
        otherTile = 'black'
    # 要被翻转的棋子
    tilesToFlip = []
    for xdirection, ydirection in [[0, 1], [1, 1], [1, 0], [1, -1], [0, -1], [-1, -1], [-1, 0], [-1, 1]]:
        x, y = xstart, ystart
        x += xdirection
        y += ydirection
        if isOnBoard(x, y) and board[x][y] == otherTile:
            x += xdirection
            y += ydirection
            if not isOnBoard(x, y):
                continue
            # 一直走到出界或不是对方棋子的位置
            while board[x][y] == otherTile:
                x += xdirection
                y += ydirection
                if not isOnBoard(x, y):
                    break
            # 出界了，则没有棋子要翻转OXXXXX
            if not isOnBoard(x, y):
                continue
            # 是自己的棋子OXXXXXXO
            if board[x][y] == tile:
                while True:
                    x -= xdirection
                    y -= ydirection
                    # 回到了起点则结束
                    if x == xstart and y == ystart:
                        break
                    # 需要翻转的棋子
                    tilesToFlip.append([x, y])
    # 将前面临时放上的棋子去掉，即还原棋盘
    board[xstart][ystart] = 'none'  # restore the empty space
    # 没有要被翻转的棋子，则走法非法。翻转棋的规则。
    if len(tilesToFlip) == 0:  # If no tiles were flipped, this is not a valid move.
        return False
    return tilesToFlip

# 是否出界
def isOnBoard(x, y):
    return x >= 0 and x <= 7 and y >= 0 and y <= 7

# 获取可落子的位置，返回这些坐标，并作出标记

def getValidMoves(board, tile):
    validMoves = []
    for x in range(8):
        for y in range(8):
            if isValidMove(board, tile, x, y) != False:
                validMoves.append([x, y])
    return validMoves

# 获取棋盘上黑白双方的棋子数
def getEvaluationOfBoard(board):
    BoardBlack = np.zeros((8,8))
    BoardWhite = np.zeros((8,8))
	# 棋盘估值表
    Vmap = np.array([[500, -25, 10, 5, 5, 10, -25, 500], [-25, -45, 1, 1, 1, 1, -45, -25], [10, 1, 3, 2, 2, 3, 1, 10],
                     [5, 1, 2, 1, 1, 2, 1, 5], [5, 1, 2, 1, 1, 2, 1, 5], [10, 1, 3, 2, 2, 3, 1, 10],
                     [-25, -45, 1, 1, 1, 1, -45, -25], [500, -25, 10, 5, 5, 10, -25, 500]])
    for x in range(8):
        for y in range(8):
            if board[x][y] == 'black':
                BoardBlack[x][y] = 1
            if board[x][y] == 'white':
                BoardWhite[x][y] = 1
    # #
    # print(BoardWhite,end='**************')
    # print(BoardBlack,end='$$$$$$$$$$$$$$$$$$$')
    BoardBlack = BoardBlack * Vmap
    BoardWhite = BoardWhite * Vmap
    BlackValue = np.sum(BoardBlack)
    WhiteValue = np.sum(BoardWhite)
    return {'black': BlackValue, 'white': WhiteValue}

def getScoreOfBoard(board):
    xscore = 0
    oscore = 0
    for x in range(8):
        for y in range(8):
            if board[x][y] == 'black':
                xscore += 1
            if board[x][y] == 'white':
                oscore += 1
    return {'black': xscore, 'white': oscore}


# 谁先走，返回turn
def whoGoesFirst():
     if random.randint(0, 1) == 0:
         return 'computer'
     else:
        return 'player'

# 将一个tile棋子放到(xstart, ystart)，返回True或False，并在board中修改值
def makeMove(board, tile, xstart, ystart):
    tilesToFlip = isValidMove(board, tile, xstart, ystart) #是否正确落子

    if tilesToFlip == False:
        return False

    board[xstart][ystart] = tile #打印出来

    for x, y in tilesToFlip:
        board[x][y] = tile

    return True

# 复制棋盘
def getBoardCopy(board):
    dupeBoard = getNewBoard()
    for x in range(8):
        for y in range(8):
            dupeBoard[x][y] = board[x][y]

    return dupeBoard

# 是否在角上
def isOnCorner(x, y):
    return (x == 0 and y == 0) or (x == 7 and y == 0) or (x == 0 and y == 7) or (x == 7 and y == 7)

# 电脑走法，AI，返回最佳走法的坐标
def getComputerMove(board, computerTile):
    # 获取所以合法走法
    flag = True
    bestMove = []
    possibleMoves = getValidMoves(board, computerTile)
    # 打乱所有合法走法
    sscore = []
    random.shuffle(possibleMoves)
    # [x, y]在角上，则优先走，因为角上的不会被再次翻转
    for x, y in possibleMoves:
        if isOnCorner(x, y):
            return [x, y]
    bestScore = -1
    for x, y in possibleMoves:
        dupeBoard = getBoardCopy(board)
        makeMove(dupeBoard, computerTile, x, y)
        #score = getScoreOfBoard(dupeBoard)[computerTile]
        # score = pvs(dupeBoard,computerTile,playerTile,flag,-INF_VALUE,INF_VALUE,iteration_depth)
        # score = mtd(dupeBoard,computerTile,playerTile,flag,-INF_VALUE,INF_VALUE,10,iteration_depth)
        score = alpha_beta_with_hashtable(dupeBoard,computerTile,playerTile,flag,-INF_VALUE,INF_VALUE,iteration_depth)
        # sscore.append(score)
        # print(sscore)
        if score is not INF_VALUE and score > bestScore:
            bestMove = [x, y]
            bestScore = score
    if len(bestMove) == 0:
        for x, y in possibleMoves:
            bestMove = [x,y]
            break

    print(bestMove)
    return bestMove


# 是否游戏结束

def isGameOver(board):
    for x in range(8):
        for y in range(8):
            if board[x][y] == 'none':
                return False

    return True

# 画出棋子，无返回值
def drawTile(board):
    for x in range(8):
        for y in range(8):
            rectDst = pygame.Rect(BOARDX + x * CELLWIDTH + 2, BOARDY + y * CELLHEIGHT + 2, PIECEWIDTH, PIECEHEIGHT)
            if mainBoard[x][y] == 'black':
                windowSurface2.blit(blackImage, rectDst, blackRect)
            elif mainBoard[x][y] == 'white':
                windowSurface2.blit(whiteImage, rectDst, whiteRect)

# 画出能够落子的位置，无返回值
def drawValidMoves(validmoves):
    for [x,y] in validMoves:
        rectDst = pygame.Rect(BOARDX + x * CELLWIDTH + 2, BOARDY + y * CELLHEIGHT + 2, PIECEWIDTH, PIECEHEIGHT)
        windowSurface2.blit(chooseImage, rectDst, chooseRect)

#游戏结束时的界面显示
def drawGameOver(board):
    scorePlayer = getScoreOfBoard(board)[playerTile]
    scoreComputer = getScoreOfBoard(board)[computerTile]
    outputStr = gameoverStr + str(scorePlayer) + ":" + str(scoreComputer)
    text = basicFont.render(outputStr, True, BLACK, BLUE)
    textRect = text.get_rect()
    textRect.centerx = windowSurface2.get_rect().centerx
    textRect.centery = windowSurface2.get_rect().centery
    windowSurface2.blit(text, textRect)
def drawWhosTurn1(board,tile):
    # print('tile',tile)
    if tile == "player":
        tile = "Player1"
    else:
        tile = "Player2"
    outstr = "it is " + tile + "'s turn"
    text = basicFont.render(outstr, True, BLACK, BLUE)
    textRect = text.get_rect()
    textRect.centerx = windowSurface2.get_rect().centerx
    textRect.centery = windowSurface2.get_rect().centery + 150
    windowSurface2.blit(text, textRect)

    scorePlayer = getScoreOfBoard(board)[playerTile]
    scoreComputer = getScoreOfBoard(board)[computerTile]
    outputStr = "Player1 vs Player2  " + str(scorePlayer) + ":" + str(scoreComputer)
    text = basicFont.render(outputStr, True, BLACK, BLUE)
    textRect = text.get_rect()
    textRect.centerx = windowSurface2.get_rect().centerx
    textRect.centery = windowSurface2.get_rect().centery + 180
    windowSurface2.blit(text, textRect)
def drawWhosTurn(board,tile):
    outstr = "it is " + tile + "'s turn"
    text = basicFont.render(outstr, True, BLACK, BLUE)
    textRect = text.get_rect()
    textRect.centerx = windowSurface2.get_rect().centerx
    textRect.centery = windowSurface2.get_rect().centery + 150
    windowSurface2.blit(text, textRect)

    scorePlayer = getScoreOfBoard(board)[playerTile]
    scoreComputer = getScoreOfBoard(board)[computerTile]
    outputStr = "Player vs Computer  " + str(scorePlayer) + ":" + str(scoreComputer)
    text = basicFont.render(outputStr, True, BLACK, BLUE)
    textRect = text.get_rect()
    textRect.centerx = windowSurface2.get_rect().centerx
    textRect.centery = windowSurface2.get_rect().centery + 180
    windowSurface2.blit(text, textRect)
def PVP():
    global mainBoard,sure_f,message,playerTile,computerTile,row,col
    global turn, gameOver
    mainBoard = getNewBoard()
    resetBoard(mainBoard)
    global  validMoves
    global current_depth
    # turn = whoGoesFirst()#随机返回“computer或player”,computer作为主机，Player作为客户端
    turn = 'player'
    if turn == 'player':
        playerTile = 'black'#先手黑棋
        computerTile = 'white'
    else:
        playerTile = 'white'
        computerTile = 'black'
    print(turn)
    gameOver = False

    while True:
        for event in pygame.event.get():
            # print("i am here server 111")
            if event.type == QUIT:
                terminate()
            # if event.type == MOUSEBUTTONDOWN :
            #     print("i am here server")
            if gameOver == False and turn == 'player' and event.type == MOUSEBUTTONDOWN and event.button == 1:
                print(playerTile)
                x, y = pygame.mouse.get_pos()
                col = int((x - BOARDX) / CELLWIDTH)
                row = int((y - BOARDY) / CELLHEIGHT)
                if makeMove(mainBoard, playerTile, col, row) == True: ##成功行走
                    current_depth += 1
                    print(current_depth)
                    validMoves = getValidMoves(mainBoard, computerTile)
                    if validMoves != []: #还能不能继续走
                        sure_f = 1
                        message = "sure_f" + str(sure_f) + " " + "row" + str(row) + " " + "col" + str(col) + " " + "T0"
                        turn = 'computer'
                else:
                    if len(getValidMoves(mainBoard, playerTile)) == 0:
                        if getValidMoves(mainBoard, computerTile) != []:
                            sure_f = 1
                            message = "sure_f" + str(sure_f) + " " + "row" + str(row) + " " + "col" + str(
                                col) + " " + "T0"
                            turn = 'computer'
                        else:
                            sure_f = 1
                            message = "sure_f" + str(sure_f) + " " + "row" + str(row) + " " + "col" + str(
                                col) + " " + "T0"
                            turn = 'computer'
                            gameOver = True
        windowSurface2.fill(BACKGROUNDCOLOR)
        windowSurface2.blit(boardImage, boardRect, boardRect)
        drawValidMoves(validMoves)
        drawTile(mainBoard)
        drawWhosTurn1(mainBoard, turn)
        if isGameOver(mainBoard) or gameOver is True:
            drawGameOver(mainBoard)
        # 刷新显示与计时
        pygame.display.update()
        mainClock.tick(FPS)


#人机对战
def rjdz():
    global mainBoard
    mainBoard = getNewBoard()
    resetBoard(mainBoard)
    global  validMoves
    global current_depth
    turn = whoGoesFirst()
    if turn == 'player':
        playerTile = 'black'
        computerTile = 'white'
    else:
        playerTile = 'white'
        computerTile = 'black'
    print(turn)
    gameOver = False

    while True:
        for event in pygame.event.get():
            if event.type == QUIT:
                terminate()
            if gameOver == False and turn == 'player' and event.type == MOUSEBUTTONDOWN and event.button == 1:
                x, y = pygame.mouse.get_pos()

                col = int((x - BOARDX) / CELLWIDTH)
                row = int((y - BOARDY) / CELLHEIGHT)

                if makeMove(mainBoard, playerTile, col, row) == True:
                    current_depth += 1
                    print(current_depth)
                    validMoves = getValidMoves(mainBoard, computerTile)
                    if validMoves != []:
                        turn = 'computer'
                else:
                    if len(getValidMoves(mainBoard, playerTile)) == 0:
                        if getValidMoves(mainBoard, computerTile) != []:
                            turn = 'computer'
                        else:
                            gameOver = True
        windowSurface2.fill(BACKGROUNDCOLOR)
        windowSurface2.blit(boardImage, boardRect, boardRect)
        drawWhosTurn(mainBoard, turn)
        drawValidMoves(validMoves)
        drawTile(mainBoard)
        if isGameOver(mainBoard) or gameOver is True:
            drawGameOver(mainBoard)

        # 刷新显示与计时
        pygame.display.update()

        mainClock.tick(FPS)

        if (gameOver == False and turn == 'computer'):
            tmp = getComputerMove(mainBoard, computerTile)
            if len(tmp):
                x, y = tmp
            else:
                if getValidMoves(mainBoard, playerTile) != []:
                    turn = 'player'
                else:
                    gameOver = True
            time.sleep(1)
            makeMove(mainBoard, computerTile, x, y)
            current_depth += 1
            print(current_depth)
            # 玩家有可行的走法
            validMoves = getValidMoves(mainBoard, playerTile)
            if validMoves != []:
                turn = 'player'
def menu():
    global Socket_init_Flag
    running = True
    windowSurface2.blit(background, (0, 0))
    windowSurface2.blit(logo, (80, 0))
    windowSurface2.blit(buttom1, (80, 140))
    windowSurface2.blit(buttom2, (80, 240))
    windowSurface2.blit(buttom3, (80, 340))
    pygame.display.update()



    validMoves = [[2, 4], [3, 5], [4, 2], [5, 3]]
    current_depth = 0
    find_number = 0
    non_find_number = 0
    while running:
        windowSurface2.fill(BACKGROUNDCOLOR)
        mx, my = pygame.mouse.get_pos()
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                terminate()
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if buttom1_rect.collidepoint((mx, my)):

                    rjdz()

                elif buttom2_rect.collidepoint((mx, my)):
                    Client_socket()
                    PVP()
                elif buttom3_rect.collidepoint((mx,my)):
                    terminate()

# 初始化
pygame.init()
mainClock = pygame.time.Clock()
# 加载图片
boardImage = pygame.image.load('board.png')
boardRect = boardImage.get_rect()
blackImage = pygame.image.load('black.png')
blackRect = blackImage.get_rect()
whiteImage = pygame.image.load('white.png')
whiteRect = whiteImage.get_rect()


chooseImage = pygame.image.load('choose.png')
chooseRect = chooseImage.get_rect()

basicFont = pygame.font.SysFont(None, 36)

gameoverStr = 'Game Over Score '
mainBoard = getNewBoard()
resetBoard(mainBoard)

# 设置窗口界面

pygame.display.set_caption('黑白棋-服务端')

gameOver = False

def handele(rec):
    global turn , gameOver,current_depth,playerTile,computerTile,mainBoard
    global validMoves, handle_flag,d
    pi_T = re.compile(r'T(\d)')
    pi_sure_flag = re.compile(r'sure_f1')
    d = 0
    if pi_sure_flag:
        for i in  range(0,len(rec)):
            if rec[i] == 'f' and rec[i+1] =='1':
                d = i+2
                break
        rec = rec[d:]
    re_T = int(pi_T.search(rec).group(1))
    pi_row = re.compile(r'row(\d)')
    pi_col = re.compile(r'col(\d)')

    re_col = int(pi_col.search(rec).group(1))
    re_row = int(pi_row.search(rec).group(1))
    # print("re_sure_flag",re_sure_flag)

    if pi_sure_flag.search(rec) and re_T == 1 :
        print("sure_flag to handle")
        if turn == 'computer' :#对方下棋
            print(computerTile)
            col = re_col
            row = re_row
            # print("makeMove(mainBoard, computerTile, col, row)",makeMove(mainBoard, computerTile, col, row))
            if makeMove(mainBoard, computerTile, col, row) == True:  ##成功行走
                current_depth += 1
                print(current_depth)
                validMoves = getValidMoves(mainBoard, playerTile)
                print("validMoves",validMoves)
                if validMoves != []:  # 还能不能继续走
                    turn = 'player'
                    print("turn to player-myself here")

            else:
                print("validMoves", validMoves)
                if len(getValidMoves(mainBoard, computerTile)) == 0:
                    if getValidMoves(mainBoard, playerTile) != []:
                        turn = 'player'
                        print("turn to player-myself here")
                    else:
                        gameOver = True
            windowSurface2.fill(BACKGROUNDCOLOR)
            windowSurface2.blit(boardImage, boardRect, boardRect)
            drawWhosTurn(mainBoard, turn)
            drawValidMoves(validMoves)
            drawTile(mainBoard)
    # handle_flag = 1





def TCP_Server():
    global SOR,Socket_init_Flag,dataSocket,message,BUFLEN,sure_f, handle_flag,row , col
    handle_flag = 1#一开始发数据
    while True:
        if Socket_init_Flag == 1:
            print("进入TCP")
            if SOR == 0 :
                # time.sleep(0.3)
                if sure_f ==1 :
                    time.sleep(0.3)
                    temp = message
                    print("Send_message", temp)
                    dataSocket.send(temp.encode())
                #     time.sleep(0.3)
                print("Send_message", message)
                dataSocket.send(message.encode())
                sure_f = 0
                message = "sure_f" + str(sure_f) + " " + "row" + str(row) + " " + "col" + str(col) + " " + "T0"
                # sure_flag = 0
                # flash_flag = 0
                # regret_flag = 0
                # message = "sure_f" + str(sure_flag) + "row" + str(send_row) + " col" + str(send_col) + "flash" + str(
                #     flash_flag) + "reg" + str(regret_flag)
                # print("waiting for receiving...........")
                # # time.sleep(0.1)
                SOR = 1
            if SOR == 1:
                recved = dataSocket.recv(BUFLEN)
                rec = recved.decode()
                if not recved:
                    break
                if rec:
                    print("received", rec)
                    # handle_flag = 0
                    handele(rec)
                    ##关键代码，需要进行延时处理，不然会出现Handle无法完全执行，又开始进行发送数据
                    time.sleep(0.5)
                    dataSocket.send(message.encode())
                    SOR = 0





# 游戏主循环
validMoves = [[2,4],[3,5],[4,2],[5,3]]
current_depth = 0
find_number = 0
non_find_number = 0
turn = whoGoesFirst()
if turn == 'player':
                    playerTile = 'black'
                    computerTile = 'white'
else:
                    playerTile = 'white'
                    computerTile = 'black'


running = True
gameoverStr = 'Game Over Score '
server_thread = threading.Thread(target=TCP_Server)
server_thread.start()
while running:
    menu()
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            terminate()

```
### 客户端
```python

import pygame, sys, random,time
from pygame.locals import *
import numpy as np
from socket import *
import threading
import time
import re





BACKGROUNDCOLOR = (255, 255, 255)
BLACK = (255, 255, 255)
BLUE = (0, 0, 255)
CELLWIDTH = 40
CELLHEIGHT = 40
PIECEWIDTH = 47
PIECEHEIGHT = 47
BOARDX = 2
BOARDY = 2
FPS = 40
INF_VALUE = 1000000
iteration_depth = 5
HASHMAP_SIZE = 8
windowSurface2 = pygame.display.set_mode((320, 420))
# 菜单图片
background = pygame.image.load('background.png')
background = pygame.transform.smoothscale(background,(320,420))
logo = pygame.image.load('logo.png')
logo =pygame.transform.smoothscale(logo,(160,80))

buttom1 = pygame.image.load('button1.png')
buttom1 = pygame.transform.smoothscale(buttom1,(160,80))
buttom1_rect = buttom1.get_rect()
buttom1_rect.center = (80, 140)
buttom2 = pygame.image.load('button2.png')
buttom2 = pygame.transform.smoothscale(buttom2,(160,80))
buttom2_rect = buttom2.get_rect()
buttom2_rect.center = (80, 240)

buttom3 = pygame.image.load('button3.png')
buttom3 = pygame.transform.smoothscale(buttom3,(160,80))
buttom3_rect = buttom3.get_rect()
buttom3_rect.center = (80, 340)




IP = '192.168.2.95'
# 端口号
SERVER_PORT = 50000
# 定义一次从socket缓冲区最多读入512个字节数据
BUFLEN = 1024
global dataSocket, SOR, message,sure_f, row ,col
SOR =1
sure_f = 0
row = 0
col =1
# 实例化一个socket对象，指明协议
dataSocket = socket(AF_INET, SOCK_STREAM)
# 连接服务端socket
dataSocket.connect((IP, SERVER_PORT))
message = "sure_f0 row0 col0 for client T1"
def getNewZobrist():
    board = []
    for i in range(8):
        board.append([random.randint(0,2**HASHMAP_SIZE - 1) for i in range(8)])
    return board

def get_hashcode(hashcode,board,tile):
    for i in range(8):
        for j in range(8):
            if board[i][j] == 'black':
                hashcode ^= zobrist_black[i][j]
            elif board[i][j] == 'white':
                hashcode ^= zobrist_white[i][j]

    if tile == 'white':
        hashcode ^= zobrist_swap_player[0]
    else:
        hashcode ^= zobrist_swap_player[1]
    return hashcode
class Hashtable_Node:
    lower = -INF_VALUE
    upper = INF_VALUE
    bestmove = [0,0]
    depth = 0
class Hashtable:
    lock = 0
    deepest = Hashtable_Node()
    newest = Hashtable_Node()

hashmap = {}

zobrist_white = getNewZobrist()
zobrist_black = getNewZobrist()
zobrist_swap_player = [random.randint(0, 2 ** HASHMAP_SIZE - 1), random.randint(0, 2 ** HASHMAP_SIZE - 1)]


def hash_update(hashcode,lower,upper,bestmove,depth):
    p = hashmap.get(hashcode)
    if depth == p.deepest.depth :
        if lower > p.deepest.lower:
            p.deepest.lower = lower
            p.deepest.bestmove = bestmove
        if upper < p.deepest.upper:
            p.deepest.upper = upper
    elif depth == p.newest.depth:
        if lower > p.newest.lower:
            p.newest.lower = lower
            p.newest.bestmove = bestmove
        if upper < p.newest.upper:
            p.newest.upper = upper
    elif depth > p.deepest.depth:
        p.newest.lower = p.deepest.lower
        p.newest.upper = p.deepest.upper
        p.newest.bestmove = p.deepest.bestmove
        p.newest.depth = p.deepest.depth

        p.deepest.lower = lower
        p.deepest.upper = upper
        p.deepest.bestmove = bestmove
        p.deepest.depth = depth

def hash_get(p,depth):
    if depth == p.deepest.depth:
        return p.deepest
    elif depth == p.newest.depth:
        return p.newest
    else:
        return None

def alpha_beta_with_hashtable(board,computerTile,playerTile,flag,alpha,beta,depth):
    if flag is True:
        Tile = computerTile
    else:
        Tile = playerTile
    hashcode = 0
    hashcode = get_hashcode(hashcode,board,Tile)
    bestmove = []
    p = hashmap.get(hashcode)

    if p is not None :
        global find_number
        find_number += 1
        # print('find number is %d***********'%find_number)
        node = hash_get(p, current_depth + iteration_depth - depth)
        if node is not None:
            if node.lower > alpha:
                alpha = node.lower
                if alpha >= beta:
                    return alpha
            if node.upper < beta:
                beta = node.upper
                if beta <= alpha:
                    return beta
    else:
        global non_find_number
        non_find_number += 1
        # print('not find number is %d$$$$$$$$' % non_find_number)
        newTable = Hashtable()
        newTable.lock = hashcode
        hashmap[hashcode] = newTable
        # print('hash map size is %d??????????' %len(hashmap))

    temp = alpha_beta(board,computerTile,playerTile,flag,alpha,beta,depth)
    if isinstance(temp,float) or isinstance(temp,int):
        best_value = temp
    else:
        best_value = temp[0]
        bestmove = temp[1]
    if best_value >= beta:
        hash_update(hashcode, best_value, INF_VALUE, bestmove, current_depth + iteration_depth - depth)
    elif best_value <= alpha:
        hash_update(hashcode, -INF_VALUE, best_value, bestmove, current_depth + iteration_depth - depth)
    else:
        hash_update(hashcode, best_value, best_value, bestmove, current_depth + iteration_depth - depth)
    return best_value
# alpha_beta减枝算法
#传进来如果flag是True 那么就是computer下
#传进来flag为false 那么就是player下
def alpha_beta(board,computerTile,playerTile,flag,alpha,beta,depth):
    bestValue = -INF_VALUE
    bestMove = []
    if flag is True:
        Tile = computerTile
    else:
        Tile = playerTile
    possible = getValidMoves(board,Tile)
    for x,y in possible:
        copyBoard = getBoardCopy(board)
        makeMove(copyBoard,Tile,x,y)
        if depth <= 1:
            Value = getEvaluationOfBoard(copyBoard)[Tile]
        else:
            temp = alpha_beta(copyBoard,computerTile,playerTile,not flag,-beta,-alpha,depth-1)
            if isinstance(temp,float) or isinstance(temp,int):
                Value = -temp
            else:
                Value = -temp[0]
        if Value >= beta:
            return Value
        if Value > bestValue:
            bestValue = Value
            bestMove = [x,y]
            if Value > alpha:
                alpha = Value

    return bestValue,bestMove
def mtd(board,computerTile,playerTile,flag,alpha,beta,test,depth):
    bestValue = -INF_VALUE
    while alpha < beta:
        temp = alpha_beta(board,computerTile,playerTile,flag,test-1,test,depth)
        if isinstance(temp, float):
            bestValue = temp
        else:
            bestValue = temp[0]
    if bestValue < test:
        beta = bestValue
        test = bestValue
    else:
        alpha = bestValue
        test = bestValue + 1
    return bestValue
def pvs(board,computerTile,playerTile,flag,alpha,beta,depth):
    bestValue = -INF_VALUE
    if flag is True:
        Tile = computerTile
    else:
        Tile = playerTile
    possible = getValidMoves(board,Tile)
    for x,y in possible:
        copyBoard = getBoardCopy(board)
        makeMove(copyBoard,Tile,x,y)
        if depth <= 1:
            Value = getEvaluationOfBoard(copyBoard)[Tile]
        elif bestValue == -INF_VALUE:
            Value = -pvs(copyBoard,computerTile,playerTile,not flag,-beta,-alpha,depth-1)
        else:
            Value = -pvs(copyBoard,computerTile,playerTile,not flag,-alpha-1,-alpha,depth-1)
            if Value >alpha and Value < beta:
                alpha = Value
                Value = -pvs(copyBoard, computerTile, playerTile, not flag, -beta, -alpha, depth - 1)
        if Value >= beta:
            return Value
        if Value > bestValue:
            bestValue = Value
            if Value > alpha:
                alpha = Value
    return bestValue
# 退出
def terminate():
    pygame.quit()
    sys.exit()

# 初始化棋盘

def resetBoard(board):
    for x in range(8):
        for y in range(8):
            board[x][y] = 'none'
    #初始布局:
    board[3][3] = 'black'
    board[3][4] = 'white'
    board[4][3] = 'white'
    board[4][4] = 'black'

# 开局时建立新棋盘
def getNewBoard():
    board = []
    for i in range(8):
        board.append(['none'] * 8)
    return board

# 是否是合法走法，返回false或者此走法能够被翻转的棋子位置
def isValidMove(board, tile, xstart, ystart):
    # 如果该位置已经有棋子或者出界了，返回False
    if not isOnBoard(xstart, ystart) or board[xstart][ystart] != 'none':
        return False
    # 临时将tile 放到指定的位置
    board[xstart][ystart] = tile
    if tile == 'black':
        otherTile = 'white'
    else:
        otherTile = 'black'
    # 要被翻转的棋子
    tilesToFlip = []
    for xdirection, ydirection in [[0, 1], [1, 1], [1, 0], [1, -1], [0, -1], [-1, -1], [-1, 0], [-1, 1]]:
        x, y = xstart, ystart
        x += xdirection
        y += ydirection
        if isOnBoard(x, y) and board[x][y] == otherTile:
            x += xdirection
            y += ydirection
            if not isOnBoard(x, y):
                continue
            # 一直走到出界或不是对方棋子的位置
            while board[x][y] == otherTile:
                x += xdirection
                y += ydirection
                if not isOnBoard(x, y):
                    break
            # 出界了，则没有棋子要翻转OXXXXX
            if not isOnBoard(x, y):
                continue
            # 是自己的棋子OXXXXXXO
            if board[x][y] == tile:
                while True:
                    x -= xdirection
                    y -= ydirection
                    # 回到了起点则结束
                    if x == xstart and y == ystart:
                        break
                    # 需要翻转的棋子
                    tilesToFlip.append([x, y])
    # 将前面临时放上的棋子去掉，即还原棋盘
    board[xstart][ystart] = 'none'  # restore the empty space
    # 没有要被翻转的棋子，则走法非法。翻转棋的规则。
    if len(tilesToFlip) == 0:  # If no tiles were flipped, this is not a valid move.
        return False
    return tilesToFlip

# 是否出界
def isOnBoard(x, y):
    return x >= 0 and x <= 7 and y >= 0 and y <= 7

# 获取可落子的位置，返回这些坐标，并作出标记

def getValidMoves(board, tile):
    validMoves = []
    for x in range(8):
        for y in range(8):
            if isValidMove(board, tile, x, y) != False:
                validMoves.append([x, y])
    return validMoves

# 获取棋盘上黑白双方的棋子数
def getEvaluationOfBoard(board):
    BoardBlack = np.zeros((8,8))
    BoardWhite = np.zeros((8,8))
	# 棋盘估值表
    Vmap = np.array([[500, -25, 10, 5, 5, 10, -25, 500], [-25, -45, 1, 1, 1, 1, -45, -25], [10, 1, 3, 2, 2, 3, 1, 10],
                     [5, 1, 2, 1, 1, 2, 1, 5], [5, 1, 2, 1, 1, 2, 1, 5], [10, 1, 3, 2, 2, 3, 1, 10],
                     [-25, -45, 1, 1, 1, 1, -45, -25], [500, -25, 10, 5, 5, 10, -25, 500]])
    for x in range(8):
        for y in range(8):
            if board[x][y] == 'black':
                BoardBlack[x][y] = 1
            if board[x][y] == 'white':
                BoardWhite[x][y] = 1
    # #
    # print(BoardWhite,end='**************')
    # print(BoardBlack,end='$$$$$$$$$$$$$$$$$$$')
    BoardBlack = BoardBlack * Vmap
    BoardWhite = BoardWhite * Vmap
    BlackValue = np.sum(BoardBlack)
    WhiteValue = np.sum(BoardWhite)
    return {'black': BlackValue, 'white': WhiteValue}

def getScoreOfBoard(board):
    xscore = 0
    oscore = 0
    for x in range(8):
        for y in range(8):
            if board[x][y] == 'black':
                xscore += 1
            if board[x][y] == 'white':
                oscore += 1
    return {'black': xscore, 'white': oscore}


# 谁先走，返回turn
def whoGoesFirst():
     if random.randint(0, 1) == 0:
         return 'computer'
     else:
        return 'player'

# 将一个tile棋子放到(xstart, ystart)，返回True或False，并在board中修改值
def makeMove(board, tile, xstart, ystart):
    tilesToFlip = isValidMove(board, tile, xstart, ystart) #是否正确落子

    if tilesToFlip == False:
        return False

    board[xstart][ystart] = tile #打印出来

    for x, y in tilesToFlip:
        board[x][y] = tile

    return True

# 复制棋盘
def getBoardCopy(board):
    dupeBoard = getNewBoard()
    for x in range(8):
        for y in range(8):
            dupeBoard[x][y] = board[x][y]

    return dupeBoard

# 是否在角上
def isOnCorner(x, y):
    return (x == 0 and y == 0) or (x == 7 and y == 0) or (x == 0 and y == 7) or (x == 7 and y == 7)

# 电脑走法，AI，返回最佳走法的坐标
def getComputerMove(board, computerTile):
    # 获取所以合法走法
    flag = True
    bestMove = []
    possibleMoves = getValidMoves(board, computerTile)
    # 打乱所有合法走法
    sscore = []
    random.shuffle(possibleMoves)
    # [x, y]在角上，则优先走，因为角上的不会被再次翻转
    for x, y in possibleMoves:
        if isOnCorner(x, y):
            return [x, y]
    bestScore = -1
    for x, y in possibleMoves:
        dupeBoard = getBoardCopy(board)
        makeMove(dupeBoard, computerTile, x, y)
        #score = getScoreOfBoard(dupeBoard)[computerTile]
        # score = pvs(dupeBoard,computerTile,playerTile,flag,-INF_VALUE,INF_VALUE,iteration_depth)
        # score = mtd(dupeBoard,computerTile,playerTile,flag,-INF_VALUE,INF_VALUE,10,iteration_depth)
        score = alpha_beta_with_hashtable(dupeBoard,computerTile,playerTile,flag,-INF_VALUE,INF_VALUE,iteration_depth)
        # sscore.append(score)
        # print(sscore)
        if score is not INF_VALUE and score > bestScore:
            bestMove = [x, y]
            bestScore = score
    if len(bestMove) == 0:
        for x, y in possibleMoves:
            bestMove = [x,y]
            break

    print(bestMove)
    return bestMove


# 是否游戏结束

def isGameOver(board):
    for x in range(8):
        for y in range(8):
            if board[x][y] == 'none':
                return False

    return True

# 画出棋子，无返回值
def drawTile(board):
    for x in range(8):
        for y in range(8):
            rectDst = pygame.Rect(BOARDX + x * CELLWIDTH + 2, BOARDY + y * CELLHEIGHT + 2, PIECEWIDTH, PIECEHEIGHT)
            if mainBoard[x][y] == 'black':
                windowSurface2.blit(blackImage, rectDst, blackRect)
            elif mainBoard[x][y] == 'white':
                windowSurface2.blit(whiteImage, rectDst, whiteRect)

# 画出能够落子的位置，无返回值
def drawValidMoves(validmoves):
    for [x,y] in validMoves:
        rectDst = pygame.Rect(BOARDX + x * CELLWIDTH + 2, BOARDY + y * CELLHEIGHT + 2, PIECEWIDTH, PIECEHEIGHT)
        windowSurface2.blit(chooseImage, rectDst, chooseRect)

#游戏结束时的界面显示
def drawGameOver(board):
    scorePlayer = getScoreOfBoard(board)[playerTile]
    scoreComputer = getScoreOfBoard(board)[computerTile]
    outputStr = gameoverStr + str(scorePlayer) + ":" + str(scoreComputer)
    text = basicFont.render(outputStr, True, BLACK, BLUE)
    textRect = text.get_rect()
    textRect.centerx = windowSurface2.get_rect().centerx
    textRect.centery = windowSurface2.get_rect().centery
    windowSurface2.blit(text, textRect)
def drawWhosTurn1(board,tile):
    # print('tile',tile)
    if tile == "player":
        tile = "Player1"
    else:
        tile = "Player2"
    outstr = "it is " + tile + "'s turn"
    text = basicFont.render(outstr, True, BLACK, BLUE)
    textRect = text.get_rect()
    textRect.centerx = windowSurface2.get_rect().centerx
    textRect.centery = windowSurface2.get_rect().centery + 150
    windowSurface2.blit(text, textRect)

    scorePlayer = getScoreOfBoard(board)[playerTile]
    scoreComputer = getScoreOfBoard(board)[computerTile]
    outputStr = "Player1 vs Player2  " + str(scorePlayer) + ":" + str(scoreComputer)
    text = basicFont.render(outputStr, True, BLACK, BLUE)
    textRect = text.get_rect()
    textRect.centerx = windowSurface2.get_rect().centerx
    textRect.centery = windowSurface2.get_rect().centery + 180
    windowSurface2.blit(text, textRect)
def drawWhosTurn(board,tile):
    outstr = "it is " + tile + "'s turn"
    text = basicFont.render(outstr, True, BLACK, BLUE)
    textRect = text.get_rect()
    textRect.centerx = windowSurface2.get_rect().centerx
    textRect.centery = windowSurface2.get_rect().centery + 150
    windowSurface2.blit(text, textRect)

    scorePlayer = getScoreOfBoard(board)[playerTile]
    scoreComputer = getScoreOfBoard(board)[computerTile]
    outputStr = "Player vs Computer  " + str(scorePlayer) + ":" + str(scoreComputer)
    text = basicFont.render(outputStr, True, BLACK, BLUE)
    textRect = text.get_rect()
    textRect.centerx = windowSurface2.get_rect().centerx
    textRect.centery = windowSurface2.get_rect().centery + 180
    windowSurface2.blit(text, textRect)
def PVP():
    global mainBoard, sure_f, message, row, col
    global turn, gameOver
    mainBoard = getNewBoard()
    resetBoard(mainBoard)
    global  validMoves
    global current_depth
    # turn = whoGoesFirst()#随机返回“computer或player”
    turn = 'player'
    if turn == 'player':
        playerTile = 'black'#先手黑棋
        computerTile = 'white'
    else:
        playerTile = 'white'
        computerTile = 'black'
    print("turn on begining",turn)
    gameOver = False

    while True:
        for event in pygame.event.get():
            if event.type == QUIT:
                terminate()
            # if (event.type == MOUSEBUTTONDOWN ):
            #     print(" i am here client")
            if (gameOver == False and turn == 'computer' and event.type == MOUSEBUTTONDOWN and event.button == 1):
                print("computerTile: ", computerTile)
                x, y = pygame.mouse.get_pos()
                col = int((x - BOARDX) / CELLWIDTH)
                row = int((y - BOARDY) / CELLHEIGHT)
                if makeMove(mainBoard, computerTile, col, row) == True:  ##成功行走
                    current_depth += 1
                    print(current_depth)
                    validMoves = getValidMoves(mainBoard, playerTile)
                    if validMoves != []:  # 还能不能继续走
                        sure_f = 1
                        message = "sure_f" + str(sure_f) + " " + "row" + str(row) + " " + "col" + str(col) + " " + "T1"
                        turn = 'player'
                else:
                    if len(getValidMoves(mainBoard, computerTile)) == 0:
                        if getValidMoves(mainBoard, playerTile) != []:
                            sure_f = 1
                            message = "sure_f" + str(sure_f) + " " + "row" + str(row) + " " + "col" + str(
                                col) + " " + "T1"
                            turn = 'player'
                        else:
                            sure_f = 1
                            message = "sure_f" + str(sure_f) + " " + "row" + str(row) + " " + "col" + str(
                                col) + " " + "T1"
                            turn = 'player'
                            gameOver = True

        windowSurface2.fill(BACKGROUNDCOLOR)
        windowSurface2.blit(boardImage, boardRect, boardRect)
        drawValidMoves(validMoves)
        drawTile(mainBoard)
        drawWhosTurn1(mainBoard, turn)
        if isGameOver(mainBoard) or gameOver is True:
            drawGameOver(mainBoard)
        # 刷新显示与计时
        pygame.display.update()
        mainClock.tick(FPS)


#人机对战
def rjdz():
    global mainBoard
    mainBoard = getNewBoard()
    resetBoard(mainBoard)
    global  validMoves
    global current_depth
    turn = whoGoesFirst()
    if turn == 'player':
        playerTile = 'black'
        computerTile = 'white'
    else:
        playerTile = 'white'
        computerTile = 'black'
    print(turn)
    gameOver = False

    while True:
        for event in pygame.event.get():
            if event.type == QUIT:
                terminate()
            if gameOver == False and turn == 'player' and event.type == MOUSEBUTTONDOWN and event.button == 1:
                x, y = pygame.mouse.get_pos()

                col = int((x - BOARDX) / CELLWIDTH)
                row = int((y - BOARDY) / CELLHEIGHT)

                if makeMove(mainBoard, playerTile, col, row) == True:
                    current_depth += 1
                    print(current_depth)
                    validMoves = getValidMoves(mainBoard, computerTile)
                    if validMoves != []:
                        turn = 'computer'
                else:
                    if len(getValidMoves(mainBoard, playerTile)) == 0:
                        if getValidMoves(mainBoard, computerTile) != []:
                            turn = 'computer'
                        else:
                            gameOver = True
        windowSurface2.fill(BACKGROUNDCOLOR)
        windowSurface2.blit(boardImage, boardRect, boardRect)
        drawWhosTurn(mainBoard, turn)
        drawValidMoves(validMoves)
        drawTile(mainBoard)
        if isGameOver(mainBoard) or gameOver is True:
            drawGameOver(mainBoard)

        # 刷新显示与计时
        pygame.display.update()

        mainClock.tick(FPS)

        if (gameOver == False and turn == 'computer'):
            tmp = getComputerMove(mainBoard, computerTile)
            if len(tmp):
                x, y = tmp
            else:
                if getValidMoves(mainBoard, playerTile) != []:
                    turn = 'player'
                else:
                    gameOver = True
            time.sleep(1)
            makeMove(mainBoard, computerTile, x, y)
            current_depth += 1
            print(current_depth)
            # 玩家有可行的走法
            validMoves = getValidMoves(mainBoard, playerTile)
            if validMoves != []:
                turn = 'player'
def menu():
    running = True
    windowSurface2.blit(background, (0, 0))
    windowSurface2.blit(logo, (80, 0))
    windowSurface2.blit(buttom1, (80, 140))
    windowSurface2.blit(buttom2, (80, 240))
    windowSurface2.blit(buttom3, (80, 340))
    pygame.display.update()



    validMoves = [[2, 4], [3, 5], [4, 2], [5, 3]]
    current_depth = 0
    find_number = 0
    non_find_number = 0
    while running:
        windowSurface2.fill(BACKGROUNDCOLOR)
        mx, my = pygame.mouse.get_pos()
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                terminate()
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if buttom1_rect.collidepoint((mx, my)):

                    rjdz()

                elif buttom2_rect.collidepoint((mx, my)):
                    PVP()
                elif buttom3_rect.collidepoint((mx,my)):
                    terminate()

# 初始化
pygame.init()
mainClock = pygame.time.Clock()
# 加载图片
boardImage = pygame.image.load('board.png')
boardRect = boardImage.get_rect()
blackImage = pygame.image.load('black.png')
blackRect = blackImage.get_rect()
whiteImage = pygame.image.load('white.png')
whiteRect = whiteImage.get_rect()


chooseImage = pygame.image.load('choose.png')
chooseRect = chooseImage.get_rect()

basicFont = pygame.font.SysFont(None, 36)

gameoverStr = 'Game Over Score '
mainBoard = getNewBoard()
resetBoard(mainBoard)

# 设置窗口界面

pygame.display.set_caption('黑白棋-客户端')

gameOver = False


def handle(rec):
    global turn, gameOver,current_depth,playerTile,computerTile,mainBoard,handle_flag
    global validMoves,d
    pi_T = re.compile(r'T(\d)')
    pi_sure_flag = re.compile(r'sure_f1')
    d = 0
    if pi_sure_flag:
        for i in  range(0,len(rec)):
            if rec[i] == 'f' and rec[i+1] =='1':
                d = i+2
                break
        rec = rec[d:]
    re_T = int(pi_T.search(rec).group(1))
    pi_row = re.compile(r'row(\d)')
    pi_col = re.compile(r'col(\d)')
    # re_sure_flag = pi_sure_flag.search(rec).group(1)
    re_col = int(pi_col.search(rec).group(1))
    re_row = int(pi_row.search(rec).group(1))
    # print("re_sure_flag",re_sure_flag)
    if pi_sure_flag.search(rec) and  re_T == 0:
        print("sure_flag to handle")
        if turn == 'player' :
            print(playerTile)
            col = re_col
            row = re_row
            # print("makeMove(mainBoard, playerTile, col, row) ",makeMove(mainBoard, playerTile, col, row) )
            if makeMove(mainBoard, playerTile, col, row) == True:  ##成功行走
                current_depth += 1
                print(current_depth)
                validMoves = getValidMoves(mainBoard, computerTile)
                print("makeMove is True")
                print("validMoves",validMoves)
                if validMoves != []:  # 还能不能继续走
                    turn = 'computer'
                    print("turn to computer-myself here")
            else:
                print("makeMove is Flase")
                print("validMoves", validMoves)
                if len(getValidMoves(mainBoard, playerTile)) == 0:
                    if getValidMoves(mainBoard, computerTile) != []:
                        turn = 'computer'
                        print("turn to computer-myself here")
                    else:
                        gameOver = True
            windowSurface2.fill(BACKGROUNDCOLOR)
            windowSurface2.blit(boardImage, boardRect, boardRect)
            drawWhosTurn(mainBoard, turn)
            drawValidMoves(validMoves)
            drawTile(mainBoard)
    # handle_flag = 1

def TCP_Client():
    global dataSocket, SOR, message,BUFLEN, handle_flag,sure_f,row, col

    while True:
        if SOR == 1 :
            # print("waiting for receiving...........")
            recved = dataSocket.recv(BUFLEN)
            rec = recved.decode()
            if not recved:
                break
            if rec:
                print("received", rec)
                # handle_flag = 0
                handle(rec)
                ##关键代码，需要进行延时处理，不然会出现Handle无法完全执行，又开始进行发送数据
                time.sleep(0.5)
                SOR = 0
        # time.sleep(0.3)
        if SOR == 0 :
            # if sure_f == 1:
            #     time.sleep(0.3)
            if sure_f == 1:
                time.sleep(0.3)
                temp = message
                print("Send_message", temp)
                dataSocket.send(temp.encode())
            print("sending",message)
            dataSocket.send(message.encode())
            sure_f = 0
            message = "sure_f" + str(sure_f) + " " + "row" + str(row) + " " + "col" + str(col) + " " + "T1"
            # sure_flag = 0
            # flash_flag = 0
            # regret_flag = 0
            # message = "sure_f" + str(sure_flag) + "row" + str(send_row) + " col" + str(send_col) + "flash" + str(
            #     flash_flag) + "reg" + str(regret_flag)
            # # time.sleep(0.1)
            SOR = 1






# 游戏主循环
validMoves = [[2,4],[3,5],[4,2],[5,3]]
current_depth = 0
find_number = 0
non_find_number = 0
turn = whoGoesFirst()
if turn == 'player':
                    playerTile = 'black'
                    computerTile = 'white'
else:
                    playerTile = 'white'
                    computerTile = 'black'


running = True
gameoverStr = 'Game Over Score '
client_thread = threading.Thread(target=TCP_Client)
client_thread.start()

while running:
    menu()
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            terminate()
```
